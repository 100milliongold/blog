[{"title":"@RequiredArgsConstructor","type":0,"sectionRef":"#","url":"/blog/post/2022/04/04/RequiredArgsConstructor","content":"","keywords":""},{"title":"@RequiredArgsConstructor​","type":1,"pageTitle":"@RequiredArgsConstructor","url":"/blog/post/2022/04/04/RequiredArgsConstructor#requiredargsconstructor","content":"이 어노테이션은 초기화 되지않은 final 필드나, @NonNull 이 붙은 필드에 대해 생성자를 생성해 줍니다. 주로 의존성 주입(Dependency Injection) 편의성을 위해서 사용되곤 합니다. 스프링 의존성 주입의 특징 중 한가지를 이용하는데 다음과 같습니다. 어떠한 빈(Bean)에 생성자가 오직 하나만 있고, 생성자의 파라미터 타입이 빈으로 등록 가능한 존재라면 이 빈은 @Autowired 어노테이션 없이도 의존성 주입이 가능하다. "},{"title":"Example​","type":1,"pageTitle":"@RequiredArgsConstructor","url":"/blog/post/2022/04/04/RequiredArgsConstructor#example","content":"@Service @RequiredArgsConstructor public class RequiredArgsConstructorDIServiceExample { private final FirstRepository firstRepository; private final SecondRepository secondRepository; private final ThirdRepository thirdRepository; // ... }  클래스 파일을 보면 @ConstructorProperties 어노테이션과 함께 final 필드를 매개변수로 하는 생성자가 생성되었습니다. 매개변수로 있는 3개의 리포지토리(repository)는 빈으로 등록이 가능한 존재이므로, @Autowired 어노테이션 없이 의존성 주입이 이루어지게 되는 것입니다. "},{"title":"결론​","type":1,"pageTitle":"@RequiredArgsConstructor","url":"/blog/post/2022/04/04/RequiredArgsConstructor#결론","content":"@RequiredArgsConstructor 을 이용해서 편리하게 의존성 주입하는 방법을 배워봤습니다. 추가적으로 롬복 어노테이션이(@Getter 혹은 @Setter 등) 사용할땐 편하지만, 단점도 있습니다. setter 메서드가 필요없는 필드에 대해서도 setter 메서드를 강제로 생성하게 되니, 필드 값이 변경될 위험이 생기게 됩니다. 이런 부분들은 전부 리팩토링의 대상이지만, 롬복을 사용하게될 경우 리팩토링이 힘들어지는 부분도 있으니 너무 무분별하게 사용하는것은 좋지 않다고 생각합니다. 출처 : @RequiredArgsConstructor 를 이용한 의존성 주입(Dependency Injection) "},{"title":"Ingress 와 egress 차이","type":0,"sectionRef":"#","url":"/blog/post/2022/04/25/Ingress-와-egress-차이","content":"일반적으로, 네트워크 트래픽은 Ingress와 egress 으로 구분된다. Ingress는 외부로부터 서버 내부로 유입되는 네트워크 트래픽을, egress는 서버 내부에서 외부로 나가는 트래픽을 의미한다","keywords":""},{"title":"networkpolicy 생성","type":0,"sectionRef":"#","url":"/blog/post/2022/04/25/networkpolicy-생성","content":"apiVersion: networking.k8s.io/v1 kind: NetworkPolicy metadata: name: internal-policy namespace: default spec: podSelector: matchLabels: name: internal policyTypes: - Egress - Ingress ingress: - {} egress: - to: - podSelector: matchLabels: name: mysql ports: - protocol: TCP port: 3306 - to: - podSelector: matchLabels: name: payroll ports: - protocol: TCP port: 8080 - ports: - port: 53 protocol: UDP - port: 53 protocol: TCP ","keywords":""},{"title":"Lombok을 이용해 Builder 패턴을 만들어보자.","type":0,"sectionRef":"#","url":"/blog/post/2022/05/02/Lombok을-이용해-Builder-패턴을-만들어보자","content":"Builder 패턴이란? 출처 - Effective Java 규칙 2 - 조슈아 블로그 생성자에 인자가 많을 때는 빌더 패턴을 고려하라 빌더 패턴(Builder pattern) 이란 복합 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴이다. (출처: 위키백과) 난 생성자가 많아지면 빌더 패턴을 만드는 편인데, 개발자 성향에 따라 다를수도 있구나를 느꼈다. 빌더패턴을 활용하면 어떤 필드에 어떤 인자를 넣어줬는지 명확히 알 수 있고, 넣어줄 필요 없는 필드(null)는 굳이 선언할 필요 없으니 좋다고 생각했다. 근데 다른 분은 어떤 필드에 null이 들어간다는걸 명확히 볼 수 있는 점 때문에 생성자를 통해 객체를 생성하시는 방법을 택했다고 하셨다. intelliJ는 들어갈 필드의 값을 표시해주는 기능이 있어서 생성자를 통해 객체를 생성해도 어떤 필드를 넣어줘야하는지 보인다. 첫 회사에서는 STS를 썼기 때문에 intelliJ의 다양한 기능적인 혜택을 누리지 못했기도 해서 빌더 패턴이 유용했다. 코틀린을 사용할 경우에는.... 굳이 빌더 패턴을 쓸 필요가 없을 것 같다 싶었던 이유가 생성자 인자에 필드 명도 함께 표기할 수 있다. // 예시 fun foo() { val member = Member(name = &quot;zorba&quot;, job = &quot;developer&quot;) } 하지만, java를 쓸 때는 자주 사용하는 디자인 패턴이다. 빌더 패턴의 장점 객체들마다 들어가야할 인자가 각각 다를 때 유연하게 사용할 수 있다. 무조건 setter 생성을 방지하고 불변객체로 만들 수 있다. 필수 argument를 지정할 수 있다.(보통의 경우, PK 역할을 할 Id 값이 될 것이다.) Builder 패턴은 어떻게 작성하나? 이 페이지를 들어가면 명확하게 빌더 패턴을 어떻게 작성해야하는지 알 수 있다. 빌더 패턴 예제코드 Java 사용자라면 잘 아는 StringBuilder가 이 빌더 패턴으로 작성된 라이브러리다. 근데 클래스를 만들 때마다 이 기나긴 코드를 짜기 불편하다! 그래서 Java 개발자들의 보일러플레이트 코드를 획기적으로 줄여준 라이브러리인 Lombok을 활용해보자. 바로 @Builder 애노테이션 을 사용하면 예제코드처럼 긴 코드를 작성하지 않아도 된다. Builder 패턴을 적용할 클래스 @AllArgsConstructor(access = AccessLevel.PRIVATE) @Builder(builderMethodName = &quot;travelCheckListBuilder&quot;) @ToString public class TravelCheckList { private Long id; private String passport; private String flightTicket; private String creditCard; private String internationalDriverLicense; private String travelerInsurance; public static TravelCheckListBuilder builder(Long id) { if(id == null) { throw new IllegalArgumentException(&quot;필수 파라미터 누락&quot;); } return travelCheckListBuilder().id(id); } } 확인용 클래스 public class MainClass { public static void main(String[] args) { // 빌더패턴을 통해 어떤 필드에 어떤 값을 넣어주는지 명확히 눈으로 확인할 수 있다! TravelCheckList travelCheckList = TravelCheckList.builder(145L) .passport(&quot;M12345&quot;) .flightTicket(&quot;Paris flight ticket&quot;) .creditCard(&quot;Shinhan card&quot;) .internationalDriverLicense(&quot;1235-5345&quot;) .travelerInsurance(&quot;Samsung insurance&quot;) .build(); System.out.println(&quot;빌더 패턴 적용하기 : &quot; + travelCheckList.toString()); } // 결과 // 빌더 패턴 적용하기 : TravelCheckList(id=1, passport=M12345, flightTicket=Paris flight ticket, creditCard=Shinhan card, internationalDriverLicense=1235-5345, travelerInsurance=Samsung insurance) } @AllArgsConstructor(access = AccessLevel.PRIVATE) : @Builder 애노테이션을 선언하면 전체 인자를 갖는 생성자를 자동으로 만든다. @AllArgsConstructor는 전체 인자를 갖는 생성자를 만드는데, 접근자를 private으로 만들어서 외부에서 접근할 수 없도록 만든다. @Builder : 위에서 설명했던 Builder 패턴을 자동으로 생성해주는데, builderMethodName에 들어간 이름으로 빌더 메서드를 생성해준다. 나같은 경우, 혼동을 줄이기 위해 클래스 명과 동일하게 놔두고 Builder로 선언했다. 클래스 내부 builder 메서드 : 필수로 들어가야할 필드들을 검증하기 위해 만들었다. 꼭 id가 아니라도 해당 클래스를 객체로 생성할 때 필수적인 필드가 있다면 활용할 수 있다. 이렇게 Lombok을 활용하면 반복적으로 길게 짜야하는 코드(보일러 플레이트 코드)를 엄청나게 줄여줄 수 있다. 빌더 패턴을 사용하면서 무분별한 setter를 남용한다면.... 빌더패턴의 장점을 극대화해서 사용하는 건 아닌 것 같다.","keywords":""},{"title":"다시 깃헙페이지로 이사갑니다.","type":0,"sectionRef":"#","url":"/blog/post/2023/02/12/이사중/inde","content":"","keywords":""},{"title":"이사중​","type":1,"pageTitle":"다시 깃헙페이지로 이사갑니다.","url":"/blog/post/2023/02/12/이사중/inde#이사중","content":"커스터마이징 하는겸 구글에 노출되기 위해서 "},{"title":"할일​","type":1,"pageTitle":"다시 깃헙페이지로 이사갑니다.","url":"/blog/post/2023/02/12/이사중/inde#할일","content":" 메인화면 제작 곳곳에 있는 자료들 통합 사이트 등록 댓글 기능 개발 "},{"title":"Linux Large File Copy(Linux 대량 파일 복사) | by jelly | Medium","type":0,"sectionRef":"#","url":"/blog/post/2023/02/20/Linux-Large-File-Copy-Linux-대량-파일-복사","content":"https://jellybeanz.medium.com/tip-linux-large-file-copy-linux-%EB%8C%80%EB%9F%89-%ED%8C%8C%EC%9D%BC-%EB%B3%B5%EC%82%AC-2d7c18f48d77 Ubuntu 를 사용하다 보면 파일을 복사하가나 백업하는 등의 일을 자주 하게 된다. 이런 경우는 대부분 아래에 적은 cp 명령어를 주로 사용하곤 한다. cp 사용 cp -rf [source] [target] rsync 사용 cp 를 사용하는 경우 진행 % 를 볼수 없지만 rsync 는 progress 옵션을 이용해서 현재 복사되고 있는 파일의 진행 % 를 볼수 있다. rsync -anv --progress [sorce] [target] 하지만!!! 몇만개, 수백기가 단위의 파일을 복사 하는 경우 cp 명령어는 어느 순간부터 느려지는 문제가 발생하곤 한다. 이런 문제를 해결하기 위해서는 파일을 tar 로 압축하여 복사를 하는 방법으로 해결 하곤 했지만, 다시 압축을 풀어야 하는 불편함이 있었다. 최근에 이런 번거로움을 해결하는 방법을 찾았다. tar 압축/해제 사용 tar cvf - [source] | (cd [target] ; tar xvf -) tar 명령어를 | 와 함께 사용하면 source 를 압축하고 target 에 압축 해제를 한번에 해주게 된다. 이 방법을 이용하면 대량/대용량 파일을 복사하는데 있어서 속도 문제가 발생하지 않는다. cp, rsync, tar 를 이용하는 방법 중에서는 tar 를 이용하는 방법이 제일 좋다.","keywords":""},{"title":"1. 자바스크립트와 엔진의 특성","type":0,"sectionRef":"#","url":"/blog/post/2023/02/15/자바스크립트와-엔진","content":"","keywords":""},{"title":"1.1. 자바스크립트의 특성​","type":1,"pageTitle":"1. 자바스크립트와 엔진의 특성","url":"/blog/post/2023/02/15/자바스크립트와-엔진#11-자바스크립트의-특성","content":"javascript는 웹을 구성하는 3대장 중 하나다. HTML 그리고 CSS와 함께 웹 페이지를 구성하는데 사용된다. HTML이 웹페이지의 UI 구성을 만드는데 사용되고 CSS가 스타일링을 입힌 다면, 그 둘을 유저와의 상호작용을 구현하는데 javascript를 사용한다. 초보자들이 배우기 쉽고 매우 자유로운 언어라고 한다. 자유롭다는 말은 문법이 간단하고 멀티-패러다임 언어로 명령형, 함수형, 객체지향형 언어등 다양하게 활용이 가능해서 그런것 같다. 또한 객체 기반의 언어지만 하지만 상속과 클래스라는 개념은 없다. (이 부분은 추가 리서치 필요) "},{"title":"1.2. 크롬 V8엔진​","type":1,"pageTitle":"1. 자바스크립트와 엔진의 특성","url":"/blog/post/2023/02/15/자바스크립트와-엔진#12-크롬-v8엔진","content":"자바스크립트는 실행되는 환경에 따라 사용되는 엔진이 상이하기도 하다. 일반적으로 chrome에 내장된 chrome V8 엔진이 대표적이다. V8엔진에 의해 실행되는 javascript는 compile(번역)과 interpreter(통역) 두개의 일련의 과정을 거쳐야한다. 여담으로 V8엔진에는 원래 interpreter가 없었지만 2017년 5.9버전이 나오면서 추가 되었다. 어쨋든 compile도 하고 interpret도 거쳐야 하는 자바스크립트는 컴파일언어라고 하기도, 인터프리터 언어라고 하기도 애매하다. 아무튼 compile과 interpreter 두 개의 과정을 거치는 것이 특징인 자바스크립트는 이 과정들을 머신코드로 해석되고 통역되어 브라우저에서 인식할 수 있게 된다. 또 다른 특징은 JIT(just-in-time)이라고 불리는 방식으로 위의 과정을 거치는데 말 그대로 브라우저가(대표적인 javascript가 실행되는 환경) javascript를 읽어 들이는 순간부터 compiler과 interpreter가 실행된다는 것이다. 그래도 가장 대표적인 특징은 V8엔진은 자바스크립트 코드를 단일 스레드, call stack에서 동기적으로 실행 한다. 이는 아마 V8엔진이 JIT 방식으로 compile과 interprete를 거쳐 머신 코드로 변환시키기 때문에 안정화 때문이지 않을까 하는 추측을 해본다. 2. 자바스크립트 엔진의 실행 방식 자바스크립트 엔진, 대표적으로 V8은 자바스크립트 코드를 동기적으로 실행 한다고 했다. 그럼 동기적으로 실행한다는 것이 무슨 뜻일까? 엔진 내부를 살짝 들여다보면서 살펴보자. "},{"title":"2.1. 동기적인 실행 방식​","type":1,"pageTitle":"1. 자바스크립트와 엔진의 특성","url":"/blog/post/2023/02/15/자바스크립트와-엔진#21-동기적인-실행-방식","content":"동기적으로 어떤 작업들을 한다는 말은 작업들을 한 작업 한 작업씩 처리한다는 뜻이다. 조금 더 자세히 살펴보자. V8엔진은 싱글 스레드인 하나의 call stack을 가지고 있다. 작업을 처리하는 공간인 call stack은 하나 밖에 없기 때문에 실행이 필요한 javascript 코드들은 이 하나의 call stack에 차곡 차곡 쌓인다. 만약 5개의 코드가 실행이 필요해 call stack에 차곡 차곡 쌓였다. (실행 순서는 나중에 조금 더 자세히 살펴볼 것이다. 지금은 단지 동기적 처리 방식에 대해서만 설명) 이 5개의 작업들을 동기적으로 처리하면 다음과 같은 순서로 진행될 것이다. 첫 번째 순서의 코드가 실행이 된다.이 때 다음 순서인 두 번째 순서의 코드는 실행이 되지 않는다. 그 대신 첫 번째 순서의 코드의 실행이 완료될 때 까지 대기하게 된다.일정 시간이 흐른 후 첫 번째 순서의 코드 실행이 완료되었다. 이제 두 번째 순서의 코드 실행이 시작된다.똑같이 세 번째 순서의 코드는 실행이 되지 않고 자신 앞 순서의 코드 실행이 완료 될 때까지 대기한다.쭉 반복 이렇게 작동하는 것이 동기적인 작동 방식인데 실행의 요청에 의해 작업이 시작되고 응답이 오면 작업을 완료하고 종료시킨다. 그 후 다음 작업에 대해 실행을 시작한다. 자바스크립트 엔진의 call stack은 이 방식으로 javascript 코드를 실행한다. 하지만 그 순서가 조금은 특이한데 바로 first-in, last-out, 즉 선입후출 방식으로 진행된다. 말로 먼저 설명하자면 함수 호출의 코드를 엔진이 읽어 들이면 call stack에 쌓는다. 근데 방금 호출된 함수 안에는 또 다른 함수의 호출이 있다. 그럼 안에서 호출된 함수에 대응하여 그 함수의 실행을 call stack에 쌓는데 이때는 처음 쌓인 call stack 위에 쌓인다. 안에서 호출된 함수 내부에는 또 다른 함수 호출이 없다. 그래서 엔진은 call stack에 쌓인 함수들을 실행하려 하는데 이 때 늦게 들어온 순서대로 코드실행을 진행한다. "},{"title":"2.2. 예제​","type":1,"pageTitle":"1. 자바스크립트와 엔진의 특성","url":"/blog/post/2023/02/15/자바스크립트와-엔진#22-예제","content":"말로하니 역시나 어렵다. 다음 예제로 살펴보자. const funcOne =() =&gt; { 2️⃣console.log(&quot;No.1&quot;) 3️⃣funcTwo() } const funcTwo =() =&gt; { 4️⃣console.log(&quot;No.2&quot;) 5️⃣funcThree() } const funcThree =()=&gt; { 6️⃣console.log(&quot;No.3&quot;) } 1️⃣funcOne() // 결과값 'No.1' 'No.2' 'No.3'  위 코드는 중첩된 함수에 대한 예제이다. 실제로 호출이 되면 call stack에 쌓이는 모습을 살펴보자. 위의 움짤처럼 쌓이고 위의 쌓인 순서대로 실행되고 실행이 완료되면 사라진다. 함수가 호출되어 call stack에 쌓이면 내부 코드를 순서대로 call stack에 쌓는걸 볼 수 있다. 그 후 함수 내부에 다른 함수의 호출이 존재하면 그 함수를 call stack에 쌓는데 그 함수가 실행이 완료되어 call stack에서 사라지기전에 외부함수의 실행도 완료되지 않는점을 명심하자. 3. 비동기 함수와 자바스크립트 엔진 javascrit 엔진 V8이 자바스크립트 코드를 실행하는 과정을 보면 정말 똑똑하다. (실제로 공식 문서를 보면 매번 업데이트에 성능 향상과 최적화에 엄청 공을 들인다.) 성능적으로도 똑똑하지만 (컴퓨터도, 인터넷도 성능이 뛰어난 요즘시대이기에 처음 자바스크립트를 실행시켰을 때 나는 동기적으로 한번에 실행된다고 느꼈다. 하지만 정말 미묘하게 아~주 미묘하게 순서대로 실행되는 것이였다.) 브라우저애서 실행 된다는 점에서 JIT방식으로 실행을 하기 때문에 코드을 읽어 들어와 연산하여 인식하는 과정은 조금 불안정할 수 도 있다. 그렇기 때문에 동기적인 방식으로 실행하는 것 같다는 느낌이 든다. 순차대로 적은 코드들에 대해 순서를 보장해 주는 것이다. 그래서 자바스크립트 엔진을 어느 정도 (아주 조금이지만) 파해쳐보니 조금 더 효율적이고 나은 코드 작성을 준수해야 되겠다는 생각이 크게 든다. (hoisting, execution context, lexical closure 등과 함께 날잡고 정리해야겠다.) 하지만 자바스크립트 엔진이 아무리 최적화하여 똑똑하게 실행을 처리한다고 한들 순서가 보장되지 못하는 경우가 발생하기도 한다. 바로 비동기 함수다. 간단하게 비동기 함수는 자바스크립트의 원칙, 실행 순서를 보장 받는다,를 깨고 비동기로 처리된다. 즉 순서를 보장받지 못하고 뒤로 밀리게 된다. 그럼 비동기 함수는 무엇이며 자바스크립트 엔진은 왜 이런식으로 처리하는 것일까? "},{"title":"3.1. 비동기 함수​","type":1,"pageTitle":"1. 자바스크립트와 엔진의 특성","url":"/blog/post/2023/02/15/자바스크립트와-엔진#31-비동기-함수","content":"대표적인 비동기 함수는 DOM 이벤트 API요청 setTimeout같은 내장 함수들이 있다. setTimeout으로 대표되는 DOM API, fetch 등으로 대표되는 XMLHttpRequest 등의 AJAX 등이 바로 비동기로 처리되는 대표적인 함수들이다. 그런데 이들의 위치가 조금 생소하다. 이 형태를 javascript runtime의 모습으로 살펴보자. "},{"title":"3.2. Javascript Runtime​","type":1,"pageTitle":"1. 자바스크립트와 엔진의 특성","url":"/blog/post/2023/02/15/자바스크립트와-엔진#32-javascript-runtime","content":"자바스크립트 엔진에는 memory heap이라는 공간도 존재한다. 설명상으로는 변수와 객체에 대한 모든 메모리 할당이 이루어 지는 곳이라고 하는데 조금 더 리서치가 필요한 부분이다. 하지만 이번 자바스크립트의 코드 실행 방식에는 큰 영향을 주는 것 같지 않다. (그래서 넘어가겠다는 소리) 어찌돼었던 이런 자바스크립트의 실행환경을 보면 엔진 밖에 Web API들이 모여있는 곳이 있다. 자바스크립트 엔진이 제공하는 것이 아닌 브라우저에서 제공해주는 것이다. 다시 말해 이들은 다른 누군가에 의해 정의되고 브라우저에 내장된 내장함수라고 생각해도 무관한데 이들은 비동기 함수이고 브라우저에 위치하고 있다. 다른말로는 자바스크립트 엔진이 콜스텍에 쌓고 실행을 처리하는 함수는우리가 자바스크립트라는 언어로 작성한 커스텀 함수다. "},{"title":"3.3. 자바스크립트 엔진의 코드 처리 방식​","type":1,"pageTitle":"1. 자바스크립트와 엔진의 특성","url":"/blog/post/2023/02/15/자바스크립트와-엔진#33-자바스크립트-엔진의-코드-처리-방식","content":"자바스크립트 엔진은 자바스크립트로 작성된 코드들의 실행을 담당한다. 물론 실행을 하기 위해 머신코드로 변환하는 작업을 거치긴 하지만 지금은 논외로 해보자. "},{"title":"3.3.1. 일반적인 코드 처리​","type":1,"pageTitle":"1. 자바스크립트와 엔진의 특성","url":"/blog/post/2023/02/15/자바스크립트와-엔진#331-일반적인-코드-처리","content":"자바스크립트로 작성된 코드는 순차적으로 call stack에 쌓이게 된다. call stack에 쌓이는 순간은 바로 코드가 해당 코드를 실행시키도록 작성되어있을 때 이다. 즉 자바스크립트 엔진은 call stack에 코드를 실행하라고 요청을 보내고 그 요청이 call stack에 쌓이는 것이다. 그러면 call stack에서는 해당 코드에 대한 작업을 하고 완료되면 응답을 보내 call stack에서 빼버린다. 명심해야 할 것은 코드 작업의 실행과정은 요청과 응답 이라는 것이다. 하나의 코드 실행은 요청에 의해 작업이 시작되고 완료되어 응답이 오면 비로소 완료되어 사라지는 것이다. "},{"title":"3.3.2. 비동기 함수 처리​","type":1,"pageTitle":"1. 자바스크립트와 엔진의 특성","url":"/blog/post/2023/02/15/자바스크립트와-엔진#332-비동기-함수-처리","content":"만약 우리가 Web API 작업을 포함하는 함수를 자바스크립트로 작성하고 실행시킨다고 가정해보면 call stack에 쌓고 실행 요청을 보낸다. 함수 내부를 살펴보니 Web API를 실행해야하는데 자바스크립트 엔진내에 존재하는 함수가 아니다. 그러면 자바스크립트는 이 실행을 본인 내부에서 하지 않고 Web API가 있는곳에 그에 관련한 요청을 보낸다. 요청에 대한 응답으로 필요한 다른 응답에 대해 다른곳에 요청을 보내는 것이다. 그 요청을 비동기 함수의 callback함수와 같이 보낸다. 브라우저는 요청에 대한 응답으로 callback함수를 보내오는데 그 응답을 call stack에서 처리한다. 그러면 예제의 실행은 완료되는데 자바스크립트는 비동기 함수를 조금 특이하게 처리한다. 앞서 call stack에 요청된 Web API의 실행은 call stack에서 하지 않고 Web API에 위임한다고 했다. 이때 call stack에서는 해당 요청을 사라진다. 즉 해당 요청에 대한 응답을 본인이 처리하지 않기에 브라우저에 요청을 보내고 해당 작업에 대한 모든 정보를, 즉 callback을 call stack에서는 Web API쪽으로 함께 보내버리는 것이다.(위임) 그렇기 때문에 같이 보내진 콜백 함수는 순서를 보장 받기도 전에 다른 곳에 위임이 되어버린다. 하지만 브라우저는 Web API 실행 요청에 대한 응답으로 callback 함수를 보내고 그 함수를 다시 call stack에서 처리한다고 하지 않았는가? 브라우저의 응답으로 온 callback 함수를 실행하라고 call stack에 요청하고 쌓는다. 이때는 제대로 실행 순서를 보장받는다. 쉽게 말해 어린아이가 귤을 먹고 싶은데 (call stack에 요청) 껍질을 본인이 깔 수 없어 엄마한테 껍질을 까달라고 요청하고 (Web API 요청 with callback) 그 요청의 응답으로 알맹이가 돌아오고 (콜백) 그 알맹이를 먹을 수 있게 (call stack에서 실행) 되는 것이다. 그렇기 때문에 call stack은 본인이 수행할 수 있는 요청이 아니기에 브라우저에 껍대기를 까달라고 요청과 함께 비동기 함수안에 정의된 callback 함수도 함께 보낸다. (API 함수에 대한 실행요청으로 실행하려 했지만 실행을 하지도 않고 다른곳으로 위임한다. 그리고 내부에 정의된 콜백함수는 순서를 배정받기도 전에 같이 보내지는 것이다.) 그 후 브라우저에서 껍대기를 까고 알맹이를 돌려주면 (callback 함수) 다시 call stack에서 실행을 요청하고 연산 후 응답으로 보내주면 실행을 완료하고 call stack에서 사라진다. "},{"title":"3.3.3. callback queue와 event loop​","type":1,"pageTitle":"1. 자바스크립트와 엔진의 특성","url":"/blog/post/2023/02/15/자바스크립트와-엔진#333-callback-queue와-event-loop","content":"하지만 그 callback 함수가 call stack으로 들어가기전에 규칙이 있다. Web API가 요청으로 응답을 보내주기까지 call stack은 기다리지 않고 다른 일을 순차적으로 동기적으로 처리한다. 아직 100개의 일이 call stack에서 처리되어야 한다고 가정해보자. callback함수는 그 중간에 끼어들어 순서를 바꿔버릴까? 그렇게 되면 코드 실행은 엉창진창이 되버릴 것이다. 그래서 대신 callback queue라는 곳에서 기다린다. 일종의 유명한 식당에서 줄을 서며 기다리는 것이다. 이 callback queue에서 기다리가닥 들어온 순서대로 call stack으로 옮겨지는데 event loop라는 친구가 항상 call stack과 callback queue를 지켜보고 있다가 call stack이 비워지게 되면 callback queue에서 대기중인 함수 실행을 call stack을 보내 callback 함수를 실행하게 된다. 결국 call stack과 callback queue는 동기적으로 작동하는데 비동기 함수는 그 순서가 밀리는 것이다. 말로하니 역시 어렵다. 예제 코드를 작성하고 어떤 이동이 일어나는지 살펴보자. let someVal = 1 let API_EXAMPLE = ()=&gt; { setTimeout(function() { someVal + 10 },3000) return someVal } let someFinalVal = API_EXAMPLE() + 100 console.log(someFinalVal)  콘솔창에 어떤 결과값이 찍힐까? 111? 아니면 101? 진행과정을 보고 한번 살펴보자.  setTimeout이라는 Web API는 비동기 방식으로 처리되었기 때문에someVal1에 10을 더하지 못한채 API_EXAMPLE함수 실행은 완료되었다. 그래서 결국 콘솔에 찍힐 someFinalVal의 값은 1+100인 101이 되는 것이다. 이렇게 자바스크립트 엔진은 비동기 함수를 실행시킬 때 그 안에 작성된 콜백 함수를 Web API를 처리하는 곳으로 보내고 비동기 함수가 실행되는 동안 call stack에 보장된 순서대로 다음 함수들을 처리한다. 그 사이 비동기 함수가 연산을 마치면 같이 보내진 콜백 함수를 callback queue로 보내고 event loop가 지켜보고 있다가 call stack이 비워지면 콜백 함수를 call stack에 다시 밀어넣고 보장된 순서대로 실행 시키는 것이 바로 자바스크립트가 비동기 함수를 처리하는 방법이다. 비동기 함수가 어떻게 처리되는지 알아봤는데 왜 자바스크립트 엔진은 헷갈리게 브라우저 내장 함수들을 이렇게 처리하는지 이유에 대해서 알아보자. "},{"title":"3.4. 비동기 처리 방식의 이유​","type":1,"pageTitle":"1. 자바스크립트와 엔진의 특성","url":"/blog/post/2023/02/15/자바스크립트와-엔진#34-비동기-처리-방식의-이유","content":"이유는 간단하게 blocking script를 방지하기 위해서다. 위의 예제에서 setTimeout라는 Web API를 사용했는데 이 함수는 지정된 시간이 지난 후 실행 되는 대표적인 비동기 함수다. 예제에 이 함수를 사용한 이유는 fetch나 axios 등으로 대표되는 서버와의 통신으로 데이터를 받아오는데 사용되는 Web API를 구현하기 위해서다. 만약 통신으로 데이터를 받아오는데 위 예제처럼 3초가 아니라 10분이 걸린다고 가정해보자. 그리고 이런 함수를 비동기가 아닌 동기로 처리한다고 가정해보자. 그러면 10분동안 아무것도 화면에 나오지 않을 것이다. 만약 통신으로 뉴스의 사진을 받아온다고 가정한다면 통신 다음에 실행되어야 할 코드들이 실행을 계속 기다리게 된다. 이것이 바로 blocking script다. 자바스크립트는 동기로 코드를 실행시키는데 한 코드에 소요 되는 시간이 너무 길기 때문에 그 코드 이후에 실행으로 순서를 부여받은 코드들은 10분을 더 기다려야 실행이 된다. 하지만 만약 비동기로 처리한다면 어떨까? 화면에는 사진만 나오지 않고 글은 보일 것이다. 그리고 유저는 10분뒤 사진을 받아볼 수 있을 것이다. AJAX 요청이, 대표적으로, 비동기로 처리되는 이유는 웹 페이지에 필요한 리소스들을 대부분 서버로부터 전송받아 viw에 보여주기 때문이다. 그런데 이런 리소스들 때문에 스크립트가 막힌다면 페이지 자체를 보여줄 수 없기 때문이다. 4. 이슈: 결론은 Promise다. 이로 인해 발생하는 이슈는 무엇일까? 바로 위 예제와 같다. 만약 서버와의 통신으로 데이터를 받아와서 그 값을 재연산해서 최종값으로 사용하려 한다면 위의 예제처럼 &quot;+10&quot;이라는 재연산을 하지 못한채 값을 사용하게 된다. 그러면 어떻게 해야할까? 바로 Promise를 사용하는 것이다. Promise는 비동기 함수를 동기적으로 처리할 수 있게 해주는 아주 대단한 친구다. Promise에 대한 정리는 다음에 하도록 하겠다. 5. 추가: Job Queue 인터넷에서 재밌는 글을 읽었는데 바로 Job Queue에 관한 것이다. 먼저 다시 비동기 함수 작동방식을 살펴보면, 비동기 함수는 본인의 함수를 실행하고 콜백으로 넘겨진 콜백함수를 callback queue로 보낸다. 그리고 event loop가 call stack을 지켜보고 있다가 다 비워지면 callback queue에서 first-in, first-out 방식으로 call stack에 밀어 넣는다. 즉 다른 일반 함수의 실행이 모두 끝나야 비동기 함수가 실행 순서를 배부받고 보장받는 것인데 비동기 함수는 call stack 맨 끝부분에 추가된다고 봐도 무방하다. 그런데 이 job queue라는 재밌는 녀석은 비동기 함수한테 조금 더 빠른 순서를 제공한다. 물론 조건이 필요한데 그 조건은 비동기 함수가 실행되는 현재 함수가 끝나기전에 비동기 함수의 실행이 완료되면 현재 함수의 실행이 완료된 후 바로 실행되는 순서를 제공받는다. 다시 말해 다른 일반 함수들의 실행이 끝나 call stack이 비워지기 전에 순서를 제공받는 것이다. "},{"title":"PyScript 란? - HTML에서 파이썬 코드 작성","type":0,"sectionRef":"#","url":"/blog/post/2023/02/20/pyscript-란","content":"","keywords":""},{"title":"PyScript​","type":1,"pageTitle":"PyScript 란? - HTML에서 파이썬 코드 작성","url":"/blog/post/2023/02/20/pyscript-란#pyscript","content":"HTML 에 파이썬을 끼워넣은 시스템파이썬 코드를 HTML에서 작성하고 동작시킬 수 있고, PyScript에서 Javascript 라이브러리 들을 부르고, 파이썬으로 모든 웹 개발을 할 수 있음데이터 사이언스 (혹은 머신러닝 엔지니어) 로써 우리의 데시보드나 모델을 HTML 파일로 공유할 수 있고, 웹브라우저에서 열기만 하면 코드를 실행시킬 수 있음 - streamlit 같은 데모 프레임워크 없이도 웹에서 시연 가능  "},{"title":"PyScript의 원리​","type":1,"pageTitle":"PyScript 란? - HTML에서 파이썬 코드 작성","url":"/blog/post/2023/02/20/pyscript-란#pyscript의-원리","content":"CPython 과 WebAssembly/Emscripten은 포팅해주는 Pyodide로 만들어짐PyScript는 미래에 다른 언어들까지의 지원을 제공할 것  "},{"title":"WebAssembly​","type":1,"pageTitle":"PyScript 란? - HTML에서 파이썬 코드 작성","url":"/blog/post/2023/02/20/pyscript-란#webassembly","content":"파이썬으로 웹사이트를 작성할 수 있게 만들어주는 근원적인 기술WebAssembly가 원래 개발될때는, 웹 브라우저는 오직 Javascript만 지원했음2017년에 처음 release 되고 빠르게 2019년 W3C (World Wide Web Consortium) 표준이 됨사람이 읽을 수 있는 .wat 텍스트 포멧 언어를 브라우저에서 실행시킬 수 있는 .wasm 바이너리 형식으로 전환모든 언어에서 코드를 작성할 수 있게 허용해주고, WebAssembly로 컴파일할 수 있게 해주고, web browser에서 동작할 수 있게 해줌! "},{"title":"Get Started​","type":1,"pageTitle":"PyScript 란? - HTML에서 파이썬 코드 작성","url":"/blog/post/2023/02/20/pyscript-란#get-started","content":""},{"title":"To try PyScript​","type":1,"pageTitle":"PyScript 란? - HTML에서 파이썬 코드 작성","url":"/blog/post/2023/02/20/pyscript-란#to-try-pyscript","content":"&lt;link rel=&quot;stylesheet&quot; href=&quot;https://pyscript.net/alpha/pyscript.css&quot; /&gt; &lt;script defer src=&quot;https://pyscript.net/alpha/pyscript.js&quot;&gt;&lt;/script&gt;  PyScript를 시도해보기 위해서는, 적절한 pyscript 파일들이 import된 HTML 페이지를 위 태그와 함께 별도의 환경 구축 없이 작성하면 됨 "},{"title":"py-env​","type":1,"pageTitle":"PyScript 란? - HTML에서 파이썬 코드 작성","url":"/blog/post/2023/02/20/pyscript-란#py-env","content":"파이썬 코드에서 동작하기 위해 필요한 파이썬 패키지들을 정의함 &lt;py-env&gt; - bokeh - matplotlib - pandas - scikit-learn - path: - ./my-custom-py-module.py &lt;/py-env&gt;  파이썬 표준 라이브러리나 써드파티 OSS 패키지들과 함께 사용하기 위해서는 py-env 태그에 dependency 들을 명시하면 됨 각자가 작성한 파이썬 모듈에 대해서는 다음과 같은 path 아래에 위치에 맞게 작성하면 됨 "},{"title":"py-script​","type":1,"pageTitle":"PyScript 란? - HTML에서 파이썬 코드 작성","url":"/blog/post/2023/02/20/pyscript-란#py-script","content":"웹 페이지에서 실행될 파이썬 코드를 작성 &lt;py-script&gt; print('Hello, World!') &lt;/py-script&gt;   &lt;py-script src=&quot;./python_file.py&quot;&gt; &lt;/py-script&gt;  파이썬 코드를 위처럼 직접 작성하거나, 작성된 py 파일을 불러올 수 있음 "},{"title":"py-repl​","type":1,"pageTitle":"PyScript 란? - HTML에서 파이썬 코드 작성","url":"/blog/post/2023/02/20/pyscript-란#py-repl","content":"코드 유저가 입력하고 확인할 수 있는 REPL (read-eval-prin loop) 컴포넌트를 생성 &lt;py-repl&gt; import numpy as np print(np.random.randn(10)) &lt;/py-repl&gt;   "},{"title":"예제:랜덤 플롯 시각화​","type":1,"pageTitle":"PyScript 란? - HTML에서 파이썬 코드 작성","url":"/blog/post/2023/02/20/pyscript-란#예제랜덤-플롯-시각화","content":"&lt;html&gt; &lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://pyscript.net/alpha/pyscript.css&quot; /&gt; &lt;script defer src=&quot;https://pyscript.net/alpha/pyscript.js&quot;&gt;&lt;/script&gt; &lt;py-env&gt; - numpy - paths: - ./data.py &lt;/py-env&gt; &lt;/head&gt; &lt;body&gt; &lt;py-script&gt; print('Hello world!') &lt;/py-script&gt; &lt;h1&gt;Let's plot random numbers&lt;/h1&gt; &lt;div id=&quot;plot&quot;&gt;&lt;/div&gt; &lt;py-script output=&quot;plot&quot;&gt; import matplotlib.pyplot as plt from data import make_x_and_y x, y = make_x_and_y(n=1000) fig, ax = plt.subplots() ax.scatter(x, y) fig &lt;/py-script&gt; &lt;/body&gt; &lt;/html&gt;  import numpy as np def make_x_and_y(n): x = np.random.randn(n) y = np.random.randn(n) return x, y  "},{"title":"🚧 주의사항​","type":1,"pageTitle":"PyScript 란? - HTML에서 파이썬 코드 작성","url":"/blog/post/2023/02/20/pyscript-란#-주의사항","content":"PyScript는 현재 매우 alpha 단계에 있고 많은 알려진 이슈들이 있으며 (로딩 시간 등) PyScript를 활용해 다양한 것을 시도해보기를 권하지만 production 단계에서 사용하는 것을 권장하지 않는다고 합니다. "},{"title":"Reference​","type":1,"pageTitle":"PyScript 란? - HTML에서 파이썬 코드 작성","url":"/blog/post/2023/02/20/pyscript-란#reference","content":"[홈페이지] PyScript[Github] PyScript[Github] PyScirpt 더 많은 예제[아나콘다] PyScript 설명 "},{"title":"Ambari Agent가 실행되고도 Ambari 에서는 heartbeat lost가 발생할경우","type":0,"sectionRef":"#","url":"/blog/post/Ambari-Agent가-실행되고도-Ambari-에서는-heartbeat-lost가-발생할경우","content":"","keywords":""},{"title":"시간동기화 문제​","type":1,"pageTitle":"Ambari Agent가 실행되고도 Ambari 에서는 heartbeat lost가 발생할경우","url":"/blog/post/Ambari-Agent가-실행되고도-Ambari-에서는-heartbeat-lost가-발생할경우#시간동기화-문제","content":"해당 호스트들이 몇초 이상 시간차가 나서 인식을 안할수도 있다. 해결방안 : 각각의 Ambari Node 서버들에서 다음과 같은 명령어를 실행한다. systemctl stop ntpd ntpdate 0.centos.pool.ntp.org systemctl start ntpd ambari-agent restart open ssl 설정문제 "},{"title":"Ambari metric collector connection timeout","type":0,"sectionRef":"#","url":"/blog/post/Ambari-metric-collector-connection-timeout","content":"","keywords":""},{"title":"증상​","type":1,"pageTitle":"Ambari metric collector connection timeout","url":"/blog/post/Ambari-metric-collector-connection-timeout#증상","content":"Ambari 메인화면 에서 리소스 그래프가 로딩중으로 표시되고 출력이 안되었고 /var/log/ambari-server/ambari-server.log 파일을 보면 다음과 같은 에러메세지가 출력이 된다. 18 Mar 2019 22:21:50,455 ERROR [ambari-client-thread-2396] MetricsRequestHelper:115 - Error getting timeline metrics : Read timed out MetricsRequestHelper:122 - Cannot connect to collector: SocketTimeoutException  "},{"title":"해결방안​","type":1,"pageTitle":"Ambari metric collector connection timeout","url":"/blog/post/Ambari-metric-collector-connection-timeout#해결방안","content":"Ambari Metric Collector 서버를 재시작 $ ambari-metrics-collector restart  Ambari Server가 느려서 그럴수도 있다. Ambari &gt;&gt; Ambari Metrics &gt;&gt; Configs &gt;&gt; Metrics service checkpoint delay 항목을 60초에서 1800 초로 증가 시켰다. Ambari Metric Collector 서버의 메모리 용량을 증가 시켰다.기존의 데이터를 지우고 다시 Ambari Metric Collector 서버를 재시작 한다. a. Ambari metcic server 을 maintenance 모드로 전환시킨다. b. Ambari metcic server 을 중지시킨다. c. Ambari metcic server 의 config 화면에서 다음을 참고한다. i. 'Metrics Service operation mode' (embedded or distributed) ii. hbase.rootdir iii. hbase.zookeeper.property.dataDir d. AMS 서버내부에 hbase.rootdir 내부의 파일들을 백업 및 지운다. - 만약 Metrics Service operation mode 가 embedded 이면 로컬에서 지우고 - distributed 일경우에는 hdfs 을 이용하여 지운다 e. 'hbase.tmp.dir'/zookeeper 폴더안의 내용도 백업 및 지운다. f. 'hbase.tmp.dir'/phoenix-spool 폴더안의 내용도 백업 및 지운다. g. AMS 재 시작 및 maintenance 모드를 헤제 한다. "},{"title":"AMBARI METRICS COLLECTOR 이동법","type":0,"sectionRef":"#","url":"/blog/post/AMBARI-METRICS-COLLECTOR-이동법","content":"curl -u admin:admin -H &quot;X-Requested-By:ambari&quot; - i -X DELETE http://192.168.1.191:8080/api/v1/clusters/supercom_test/hosts/node04/host_components/METRICS_COLLECTOR 2. 새로운 호스트에 METRICS_COLLECTOR 설치 curl -u admin:admin -H &quot;X-Requested-By:ambari&quot; -i -X POST http://192.168.1.191:8080/api/v1/clusters/supercom_test/hosts/node02/host_components/METRICS_COLLECTOR ","keywords":""},{"title":"useMemo-정의","type":0,"sectionRef":"#","url":"/blog/post/2023/02/21/useMemo-정의","content":"","keywords":""},{"title":"1. React.memo()​","type":1,"pageTitle":"useMemo-정의","url":"/blog/post/2023/02/21/useMemo-정의#1-reactmemo","content":"React는 먼저 컴퍼넌트를 렌더링(rendering) 한 뒤, 이전 렌더된 결과와 비교하여 DOM 업데이트를 결정한다. 만약 렌더 결과가 이전과 다르다면, React는 DOM을 업데이트한다. 다음 렌더링 결과와 이전 결과의 비교는 빠르다. 하지만 어떤 상황에서는 이 과정의 속도를 좀 더 높일 수 있다. 컴퍼넌트가 React.memo()로 래핑 될 때, React는 컴퍼넌트를 렌더링하고 결과를 메모이징(Memoizing)한다. 그리고 다음 렌더링이 일어날 때 props가 같다면, React는 메모이징(Memoizing)된 내용을 재사용한다. 예시를 살펴보자. 함수형 컴퍼넌트 Movie가 React.memo()로 래핑 되어 있다. export function Movie({ title, releaseDate }) { return ( &lt;div&gt; &lt;div&gt;Movie title: {title}&lt;/div&gt; &lt;div&gt;Release date: {releaseDate}&lt;/div&gt; &lt;/div&gt; ); } export const MemoizedMovie = React.memo(Movie);  React.memo(Movie)는 새로 메모이징된 컴퍼넌트인 MemoizedMovie를 반환한다. 한 가지 차이점을 제외하고 원래의 Movie 컴퍼넌트와 같은 결과를 나타낼 것이다. MemoizedMovie의 렌더링 결과는 메모이징 되어있다. 만약 title이나 releaseData 같은 props가 변경 되지 않는다면 다음 렌더링 때 메모이징 된 내용을 그대로 사용하게 된다. // 첫 렌더이다. React는 MemoizedMovie 함수를 호출한다. &lt;MemoizedMovie movieTitle=&quot;Heat&quot; releaseDate=&quot;December 15, 1995&quot; /&gt; // 다시 렌더링 할 때 React는 MemoizedMovie 함수를 호출하지 않는다. // 리렌더링을 막는다. &lt;MemoizedMovie movieTitle=&quot;Heat&quot; releaseDate=&quot;December 15, 1995&quot; /&gt;   메모이징 한 결과를 재사용 함으로써, React에서 리렌더링을 할 때 가상 DOM에서 달라진 부분을 확인하지 않아 성능상의 이점을 누릴 수 있다. 클래스 컴퍼넌트 또한 PureComponent로 동일한 내용이 구현되어 있다. "},{"title":"1.1 props 동등 비교 커스터마이징​","type":1,"pageTitle":"useMemo-정의","url":"/blog/post/2023/02/21/useMemo-정의#11-props-동등-비교-커스터마이징","content":"React.memo()는 props 혹은 props의 객체를 비교할 때 얕은(shallow) 비교를 한다. 비교 방식을 수정하고 싶다면 React.memo() 두 번째 매개변수로 비교함수를 만들어 넘겨주면 된다. React.memo(Component, [areEqual(prevProps, nextProps)]);  areEqual(prevProps, nextProps) 함수는 prevProps와 nextProps가 같다면 true를 반환할 것이다. 예를들어 Movie의 props가 동일한지 수동으로 비교해보자. function moviePropsAreEqual(prevMovie, nextMovie) { return ( prevMovie.title === nextMovie.title &amp;&amp; prevMovie.releaseDate === nextMovie.releaseDate ); } const MemoizedMovie2 = React.memo(Movie, moviePropsAreEqual);  moviePropsAreEqual() 함수는 이전 props와 현재 props가 같다면 true를 반환할 것이다. "},{"title":"2. 언제 React.memo()를 써야할까​","type":1,"pageTitle":"useMemo-정의","url":"/blog/post/2023/02/21/useMemo-정의#2-언제-reactmemo를-써야할까","content":" "},{"title":"2.1 같은 props로 렌더링이 자주 일어나는 컴퍼넌트​","type":1,"pageTitle":"useMemo-정의","url":"/blog/post/2023/02/21/useMemo-정의#21-같은-props로-렌더링이-자주-일어나는-컴퍼넌트","content":"React.memo()는 함수형 컴퍼넌트에 적용되어 같은 props에 같은 렌더링 결과를 제공한다. React.memo()를 사용하기 가장 좋은 케이스는 함수형 컴퍼넌트가 같은 props로 자주 렌더링 될거라 예상될 때이다. 일반적으로 부모 컴퍼넌트에 의해 하위 컴퍼넌트가 같은 props로 리렌더링 될 때가 있다. 위에서 정의한 Movie를 다시 사용해서 예시를 들어보자. 여기 Movie의 부모 컴퍼넌트인 실시간으로 업데이트되는 영화 조회수를 나타내는 MovieViewsRealtime 컴퍼넌트가 있다. function MovieViewsRealtime({ title, releaseDate, views }) { return ( &lt;div&gt; &lt;Movie title={title} releaseDate={releaseDate} /&gt; Movie views: {views} &lt;/div&gt; ); }  이 어플리케이션은 주기적(매초)으로 서버에서 데이터를 폴링(Polling)해서 MovieViewsRealtime 컴퍼넌트의 views를 업데이트한다. // Initial render &lt;MovieViewsRealtime views={0} title=&quot;Forrest Gump&quot; releaseDate=&quot;June 23, 1994&quot; /&gt; // After 1 second, views is 10 &lt;MovieViewsRealtime views={10} title=&quot;Forrest Gump&quot; releaseDate=&quot;June 23, 1994&quot; /&gt; // After 2 seconds, views is 25 &lt;MovieViewsRealtime views={25} title=&quot;Forrest Gump&quot; releaseDate=&quot;June 23, 1994&quot; /&gt; // etc  views가 새로운 숫자가 업데이트 될 때 마다 MoviewViewsRealtime 컴퍼넌트 또한 리렌더링 된다. 이때 Movie 컴퍼넌트 또한 title이나 releaseData가 같음에도 불구하고 리렌더링 된다. 이때가 Movie 컴퍼넌트에 메모이제이션을 적용할 적절한 케이스다. MovieViewsRealtime에 메모이징된 컴퍼넌트인 MemoizedMovie를 대신 사용해 성능을 향상해보자. function MovieViewsRealtime({ title, releaseDate, views }) { return ( &lt;div&gt; &lt;MemoizedMovie title={title} releaseDate={releaseDate} /&gt; Movie views: {views} &lt;/div&gt; ); }  title 혹은 releaseDate props가 같다면, React는 MemoizedMovie를 리렌더링 하지 않을 것이다. 이렇게 MovieViewsRealtime 컴퍼넌트의 성능을 향상할 수 있다. 컴퍼넌트가 같은 props로 자주 렌더링되거나, 무겁고 비용이 큰 연산이 있는 경우, React.memo()로 컴퍼넌트를 래핑할 필요가 있다. profiling을 통해 React.memo()의 이점을 측정해봐라 "},{"title":"3. 언제 React.memo()를 사용하지 말아야 할까​","type":1,"pageTitle":"useMemo-정의","url":"/blog/post/2023/02/21/useMemo-정의#3-언제-reactmemo를-사용하지-말아야-할까","content":"만약 위에서 언급한 상황에 일치하지 않는다면 React.memo()를 사용할 필요가 없을 가능성이 높다. 경험적으로, 성능적인 이점을 얻지 못한다면 메모이제이션을 사용하지 않는것이 좋다. 성능 관련 변경이 잘못 적용 된다면 성능이 오히려 악화될 수 있다. React.memo()를 현명하게 사용하라. 또한, 기술적으로는 가능하지만 클래스 기반의 컴퍼넌트를 React.memo()로 래핑하는것은 적절하지 않다. 클래스 기반의 컴퍼넌트에서 메모이제이션이 필요하다면 PureComponent를 확장하여 사용하거나, shouldComponentUpdate() 메서드를 구현하는 것이 적절하다. "},{"title":"3.1 쓸모없는 props 비교​","type":1,"pageTitle":"useMemo-정의","url":"/blog/post/2023/02/21/useMemo-정의#31-쓸모없는-props-비교","content":"렌더링될 때 props가 다른 경우가 대부분인 컴포넌트를 생각해보면, 메모이제이션 기법의 이점을 얻기 힘들다. props가 자주 변하는 컴퍼넌트를 React.memo()로 래핑할지라도, React는 두 가지 작업을 리렌더링 할 때마다 수행할 것이다. 이전 props와 다음 props의 동등 비교를 위해 비교 함수를 수행한다.비교 함수는 거의 항상 false를 반환할 것이기 때문에, React는 이전 렌더링 내용과 다음 렌더링 내용을 비교할 것이다. 비교 함수의 결과는 대부분 false를 반환하기에 props 비교는 불필요하게 된다. "},{"title":"4. React.memo() 와 콜백 함수​","type":1,"pageTitle":"useMemo-정의","url":"/blog/post/2023/02/21/useMemo-정의#4-reactmemo-와-콜백-함수","content":"함수 객체는 &quot;일반&quot; 객체와 동일한 비교 원칙을 따른다. 함수 객체는 오직 자신에게만 동일하다. 몇가지 함수를 비교해보자. function sumFactory() { return (a, b) =&gt; a + b; } const sum1 = sumFactory(); const sum2 = sumFactory(); console.log(sum1 === sum2); // =&gt; false console.log(sum1 === sum1); // =&gt; true console.log(sum2 === sum2); // =&gt; true  sumFactory()는 팩토리 함수이다. 이 함수는 2가지 숫자를 더해주는 화살표 함수를 반환한다. 함수 sum1과 sum2는 팩토리에 의해 생성된 함수다. 두 함수 모두 두 숫자를 더해주는 함수이다. 그러나 sum1과 sum2는 다른 함수 객체이다. 부모 컴퍼넌트가 자식 컴퍼넌트의 콜백 함수를 정의한다면, 새 함수가 암시적으로 생성될 수 있다. 이것이 어떻게 메모이제이션을 막는지 보고, 수정해보자. Logout 컴퍼넌트는 콜백 prop인 onLogout을 갖는다. function Logout({ username, onLogout }) { return &lt;div onClick={onLogout}&gt;Logout {username}&lt;/div&gt;; } const MemoizedLogout = React.memo(Logout);  함수의 동등성이란 함정 때문에, 메모이제이션을 적용할 때는 콜백을 받는 컴퍼넌트 관리에 주의해야한다. 리렌더를 할 때 마다 부모 함수가 다른 콜백 함수의 인스턴스를 넘길 가능성이 있다. function MyApp({ store, cookies }) { return ( &lt;div className=&quot;main&quot;&gt; &lt;header&gt; &lt;MemoizedLogout username={store.username} onLogout={() =&gt; cookies.clear()} /&gt; &lt;/header&gt; {store.content} &lt;/div&gt; ); }  동일한 username 값이 전달되더라고, MemoizedLogout은 새로운 onLogout 콜백 때문에 리렌더링을 하게 된다. 메모이제이션이 중단되게 되는 것이다. 이 문제를 해결하려면 onLogout prop의 값을 매번 동일한 콜백 인스턴스로 설정해야만 한다.useCallback()을 이용해서 콜백 인스턴스를 보존시켜보자. const MemoizedLogout = React.memo(Logout); function MyApp({ store, cookies }) { const onLogout = useCallback(() =&gt; { cookies.clear(); }, []); return ( &lt;div className=&quot;main&quot;&gt; &lt;header&gt; &lt;MemoizedLogout username={store.username} onLogout={onLogout} /&gt; &lt;/header&gt; {store.content} &lt;/div&gt; ); }  useCallback(() =&gt; { cookies.clear() }, []) 는 항상 같은 함수 인스턴스를 반환한다. MemoizedLogout의 메모이제이션이 정상적으로 동작하도록 수정되었다. "},{"title":"5. React.memo() 은 성능 개선의 도구다​","type":1,"pageTitle":"useMemo-정의","url":"/blog/post/2023/02/21/useMemo-정의#5-reactmemo-은-성능-개선의-도구다","content":"엄밀히 말하면, React에서는 성능 개선을 위한 하나의 도구로 메모이제이션을 사용한다. 대부분의 상황에서 React는 메모이징 된 컴퍼넌트의 리렌더링을 피할 수 있지만, 렌더링을 막기 위해 메모이제이션에 의존하면 안된다. "},{"title":"6. 결론​","type":1,"pageTitle":"useMemo-정의","url":"/blog/post/2023/02/21/useMemo-정의#6-결론","content":"React.memo()는 함수형 컴퍼넌트에서도 메모이제이션의 장점을 얻게 해 주는 훌륭한 도구다. 올바르게 적용 된다면 변경되지 않은 동일한 prop에 대해 리렌더링을 하는 것을 막을 수 있다. 다만, 콜백 함수를 prop으로 사용하는 컴퍼넌트에서 메모이징을 할 때 주의하라. 그리고 같은 렌더링을 할 때 이전과 동일한 콜백 함수 인스턴스를 넘기는지 확실히 하라. 그리고 메모이제이션의 성능상 이점을 측정하기 위해 profiling을 사용하는 것을 잊지 말아라. "},{"title":"Ambari View 제작","type":0,"sectionRef":"#","url":"/blog/post/Ambari-View-제작","content":"Apache Ambari 프로젝트는 Apache Hadoop 클러스터를 프로비저닝, 관리 및 모니터링하는 소프트웨어를 개발하여 Hadoop 관리를 단순화하는 것을 목표로 한다. Ambari는 REST REST API를 통해 직관적이고 사용하기 쉬운 Hadoop 관리 웹 UI를 제공한다.Apache Ambari project Ambari View Ambari Views는 Ambari Web에서 사용자 정의 시각화, 관리 및 모니터링 기능을 표면화하기 위해 UI 기능을 연결하는 체계적인 방법을 제공한다. &quot;보기&quot;는 제3자가 API, 공급자, UI와 함께 새로운 자원 유형을 지원하게 하는 Ambari를 확장하는 방법이다. 즉, 보기는 Ambari 컨테이너에 배치되는 애플리케이션이다. https://cwiki.apache.org/confluence/display/AMBARI/Views 즉 Ambari 에서 별도의 View 화면을 제공해주는 플러그인 이다 제작 절차 STS 우클릭후 New -&gt; Spring Legacy Project 에서 Spring MVC Project 생성 {% asset_img &quot;image1.png&quot; &quot;spaced title&quot; %} pom.xml 파일 설정 &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-jsp&lt;/artifactId&gt; &lt;version&gt;${jetty.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.easymock&lt;/groupId&gt; &lt;artifactId&gt;easymock&lt;/artifactId&gt; &lt;version&gt;3.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.ambari&lt;/groupId&gt; &lt;artifactId&gt;ambari-views&lt;/artifactId&gt; &lt;version&gt;2.0.0.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-server&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-server&lt;/artifactId&gt; &lt;version&gt;${jetty.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-servlet&lt;/artifactId&gt; &lt;version&gt;${jetty.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-webapp&lt;/artifactId&gt; &lt;version&gt;${jetty.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt; &lt;artifactId&gt;jetty-servlets&lt;/artifactId&gt; &lt;version&gt;${jetty.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${org.springframework-version}&lt;/version&gt; &lt;exclusions&gt; &lt;!-- Exclude Commons Logging in favor of SLF4j --&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${org.springframework-version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${org.springframework-version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${org.springframework-version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;${org.springframework-version}&lt;/version&gt; &lt;/dependency&gt; src/main/resources/view.xml 설정 &lt;view&gt; &lt;!-- ambari name --&gt; &lt;name&gt;AmbariViewTest&lt;/name&gt; &lt;label&gt;Ambari View Test&lt;/label&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;min-ambari-version&gt;2.0.*&lt;/min-ambari-version&gt; &lt;!-- ambari config data --&gt; &lt;parameter&gt; &lt;name&gt;ambari.server.url&lt;/name&gt; &lt;description&gt;Enter Ambari Server URL&lt;/description&gt; &lt;placeholder&gt;http://ambari.server:8080&lt;/placeholder&gt; &lt;default-value&gt;http://localhost:8080&lt;/default-value&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;ambari.server.containername&lt;/name&gt; &lt;description&gt;Enter Ambari Container Name&lt;/description&gt; &lt;/parameter&gt; &lt;parameter&gt; &lt;name&gt;ambari.server.username&lt;/name&gt; &lt;description&gt;Enter Ambari Server username&lt;/description&gt; &lt;default-value&gt;admin&lt;/default-value&gt; &lt;/parameter&gt; &lt;!-- ambari view Properties --&gt; &lt;resource&gt; &lt;name&gt;configurations&lt;/name&gt; &lt;service-class&gt;com.test.lustre.dao&lt;/service-class&gt; &lt;/resource&gt; &lt;/view&gt; Spring Web 개발 maven 빌드 mvn clean packge /var/lib/ambari-server/resources/viwes 에 빌드된 파일 이동 ambari 재시작 ambari-server restart 확인","keywords":""},{"title":"manjaro linux(arch linux) 에서 한컴뷰어 설치","type":0,"sectionRef":"#","url":"/blog/post/arch-linux-에서-한컴뷰어-설치","content":"참고: 아치리눅스 한국사용자 모임 - 한컴뷰어2014 부탁 좀 드려요..최근에 기존에 설치되었던 우분투를 지우고 만자로 리눅스를 설치했다. apt 패키지 매니저 대신 pacman 패키지를 사용하는거 제외하고는 우분투쓰는 느낌이고 업데이트 나오는 시기가 빠르다고 하는데 아직은 모르겠다. 하지만 한컴뷰어를 설치하고자 했지만 유감스럽게도 Fedora 와 Ubuntu 만 제공하고 있어 아치리눅스 기반이 만자로에서는 설치가 제한이 된다. 그러면 한컴뷰어 설치를 포기햐야 하는가? 정답은 그렇지 않다 이다. 다행히 deb 패키지를 arch linux 패키지로 변환이 가능하다. 설치 한컴 뷰어 다운로드deb -&gt; pkg.tar.xz 파일로 변환 debtap hancomoffice-hwpviewer-Ubuntu-amd64.deb 한컴뷰어 설치 sudo pacman -U ./hancomoffice-hwpviewer-9.20.0.1573-1-x86_64.pkg.tar.xz 그런데 webkitgtk 의존성 문제가 발생했다. webkitgtk 을 설치하는데 확인해보니 AUR 로 설치해야 해서 yaourt 로 진행한다. webkitgtk 설치 yaourt -S webkitgtk 설치는 되는거 같은데 .. 소스코드가 많아서 그런지 반나절이 지나도 빌드가 끝나지 않는다. 설치파일을 받아서 진행을 한다. wget https://cdn.repo.archlinuxcn.org/x86_64/webkitgtk-3%3A2.4.11-16-x86_64.pkg.tar.xz sudo pacman -U ./webkitgtk-3_2.4.11-16-x86_64.pkg.tar.xz 다시 3번을 진행하니 설치가 진행이 된다. 그런데 이제는 실행이 안되고 콘솔에서 hwpviewer 을 실행하니 다음에러가 발생했다. hwpviewer: error while loading shared libraries: libicui18n.so.63: cannot open shared object file: No such file or directory 확인해보니 내컴퓨터에서 설치된 icu 패키지 버젼은 64 이고 한컴뷰어에서 요구하는 icu 패키지 버젼이 63인거 같다. 하지만 pacman 에서는 icu 64 로만 설치가된다. AUR 로 설치하자 icu63 설치 yaourt -S icu63 다행히 빌드하는데 오래걸리지는 않았다. 한컴뷰어 실행 hwpviewer 이제야 실행이 된다 {% asset_img &quot;hwpviewer.png&quot; &quot;spaced title&quot; %} 후기 설치하면서 기존의 pacman 도 좋지만 대부분 AUR 을 이용해야만 설치가 진행이 되었다.","keywords":""},{"title":"Arrow Function (ES6) 과 Normal Function 의 차이","type":0,"sectionRef":"#","url":"/blog/post/Arrow-Function-ES6-과-Function-의-차이","content":"기존의 javascript Function 의 this 객체는 java 와 달리 자기 자신이 아니라 호출 방식에 따라 this에 바인딩되는 객체가 달라집니다. this는 전역객체(Global object)에 포함되며 이는 내부함수와 메소드의 내부함수 , 그리고 콜백함수 에서도 this는 외부함수가 아닌 전역객체에 바인딩됩니다. 하지만 Arrow Function 안의 this는 해당 함수를 포함하는 겍체의 this가 됩니다. 또한 Arrow Function(() =&gt; {}) 은 기존 Function 과 달리 new로 호출할 수 없습니다. 따라서 handleClose() 을 넘길때 다음과 같이 bind 을 해서 처리해야 합니다. class Testone extends Component { constructor(props){ super(props); this.state= { } this.handleClose = this.handleClose.bind(this); } handleClose(e){ console.log(e) } handleOpen = (e) =&gt; console.log(e); render() { return ( &lt;Testtow handleClose={this.handleClose} handleOpen={this.handleOpen} &gt; ) } } ","keywords":""},{"title":"AUR(yaourt) 설치 절차 및 debtap","type":0,"sectionRef":"#","url":"/blog/post/AUR-yaourt-설치-절차","content":"","keywords":""},{"title":"개요​","type":1,"pageTitle":"AUR(yaourt) 설치 절차 및 debtap","url":"/blog/post/AUR-yaourt-설치-절차#개요","content":"debian 패키지를 Arch Linux 에 설치 하기 위해서는 debtap 이 필요하며 이는 AUR 을 이용하여 설치하면 된다. arch linux 특징중에 하나는 유저가 패키지를 만들고 이를 공유할수 있다. 이를 이용하여 여러가지 패키지들을 설치할수 있다. "},{"title":"설치절차​","type":1,"pageTitle":"AUR(yaourt) 설치 절차 및 debtap","url":"/blog/post/AUR-yaourt-설치-절차#설치절차","content":""},{"title":"1. 관련 패키지 설치​","type":1,"pageTitle":"AUR(yaourt) 설치 절차 및 debtap","url":"/blog/post/AUR-yaourt-설치-절차#1-관련-패키지-설치","content":"sudo pacman -S binutils gcc pkgfile sudo pkgfile --update sudo pkgfile strip sudo pacman -S pkg-config sudo pacman -S make sudo pacman -S base-devel  "},{"title":"2. yaourt 설치​","type":1,"pageTitle":"AUR(yaourt) 설치 절차 및 debtap","url":"/blog/post/AUR-yaourt-설치-절차#2-yaourt-설치","content":"git clone https://aur.archlinux.org/yaourt.git cd yaourt makepkg -si  "},{"title":"3. debtap 설치​","type":1,"pageTitle":"AUR(yaourt) 설치 절차 및 debtap","url":"/blog/post/AUR-yaourt-설치-절차#3-debtap-설치","content":"yaourt -S debtap  "},{"title":"4. debtap 으로 패키지 변환하기​","type":1,"pageTitle":"AUR(yaourt) 설치 절차 및 debtap","url":"/blog/post/AUR-yaourt-설치-절차#4-debtap-으로-패키지-변환하기","content":"debtap hancomoffice-hwpviewer-Ubuntu-amd64.deb sudo pacman -U ./hancomoffice-hwpviewer-9.20.0.1573-1-x86_64.pkg.tar.xz  "},{"title":"후기​","type":1,"pageTitle":"AUR(yaourt) 설치 절차 및 debtap","url":"/blog/post/AUR-yaourt-설치-절차#후기","content":"데비안도 써보고 우분투도 써봤지만 아치리눅스 만큼 업데이트가 빠른 운영체제는 처음본거 같다. "},{"title":"Centos7 SELINUX disable 설정후 커널페닉 증상","type":0,"sectionRef":"#","url":"/blog/post/Centos7-SELINUX-disable-설정후-커널페닉-증상","content":"Centos SELINUX 설정을 비활성화 후에 재부팅시 부팅화면에서 멈추는 현상 원인 /etc/selinux/config 파일에 SELINUXTYPE=disabled 설정되어 있음 해결방안 grub 화면에서 부팅 운영체제를 선택후 e 키를 눌러서 kernel 부팅 옵션으로 들어가서 linux16 / vmlinu 가 있는 부분에 selinux = 0 추가할것 linux16 / vmlinu - 생략 - selinux = 0 완료후에 Ctrl + x 키로 리부트","keywords":""},{"title":"basic auth 구현 및 설명","type":0,"sectionRef":"#","url":"/blog/post/basic-auth-구현-및-설명","content":"","keywords":""},{"title":"basic auth 이란​","type":1,"pageTitle":"basic auth 구현 및 설명","url":"/blog/post/basic-auth-구현-및-설명#basic-auth-이란","content":"api 서버에서 데이터을 요구할때 http Authorization 헤더에 user id 와 , password 을 base64 로 인코딩한 문자열을 추가하여 인증하는 형식 참고 : HTTP 기본인증 "},{"title":"구현​","type":1,"pageTitle":"basic auth 구현 및 설명","url":"/blog/post/basic-auth-구현-및-설명#구현","content":"config 설정 @Autowired private AuthProvider authProvider; @Override /** * 스크링 시큐리트를 통하여 접근페이지 설정 */ protected void configure(HttpSecurity http) throws Exception{ http .logout() .logoutUrl(&quot;/api/logout&quot;) .and() .csrf() .disable() .authorizeRequests() .antMatchers( &quot;/&quot;, &quot;/api/v1/user/join&quot;, &quot;/static/**&quot; ).permitAll() .anyRequest().authenticated() .and() .headers().frameOptions().sameOrigin() .and() .httpBasic() .authenticationEntryPoint(new NoPopupBasicAuthenticationEntryPoint()) ; http.authenticationProvider(authProvider); } http.authenticationProvider 부분에 authProvider 추가 AuthProvider.java package com.jeaeok.myproject.testApp.configs; import java.util.ArrayList; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.authentication.AuthenticationProvider; import org.springframework.security.authentication.UsernamePasswordAuthenticationToken; import org.springframework.security.core.Authentication; import org.springframework.security.core.AuthenticationException; import org.springframework.security.core.GrantedAuthority; import org.springframework.security.core.authority.SimpleGrantedAuthority; import org.springframework.security.crypto.password.PasswordEncoder; import org.springframework.stereotype.Component; import com.jeaeok.myproject.testApp.domain.MyAuthenticaion; import com.jeaeok.myproject.testApp.domain.User; import com.jeaeok.myproject.testApp.services.UserService; @Component(&quot;authProvider&quot;) /** * 로그인 확인 하는 클레스 * @author atcis * */ public class AuthProvider implements AuthenticationProvider { @Autowired private PasswordEncoder passwordEncoder; @Autowired private UserService userService; @Override public Authentication authenticate(Authentication authentication) throws AuthenticationException { String id = authentication.getName(); String password = authentication.getCredentials().toString(); User user_info = userService.getUser(id); if (null == user_info || !passwordEncoder.matches(password, user_info.getUserPassword())) { return null; } List&lt;GrantedAuthority&gt; grantedAuthorityList = new ArrayList&lt;&gt;(); if (user_info.isAdmin()) { grantedAuthorityList.add(new SimpleGrantedAuthority(&quot;ROLE_USER&quot;)); } return new MyAuthenticaion(id, password, grantedAuthorityList, user_info); } @Override public boolean supports(Class&lt;?&gt; authentication) { return authentication.equals(UsernamePasswordAuthenticationToken.class); } } authentication.getName() : basic auth 부분에 id authentication.getCredentials().toString() : basic auth 부분에 password basic auth 은 base64 로 인코딩 되어 전송되기 때문에 중간자 공격에 취약할수도 있음 "},{"title":"css margin, padding 한줄에 적을 때 순서","type":0,"sectionRef":"#","url":"/blog/post/css-margin-padding-한줄에-적을-때-순서","content":"계속 사용하지만 기억이 안나서 따로 적는다. padding 도 동일하다. margin: [margin-top] [margin-right] [margin-bottom] [margin-left]; margin: [margin-top] [margin-left = margin-right] [margin-bottom]; margin: [margin-top=margin-bottom] [margin-left = margin-right]; margin: [margin-top = margin-bottom = margin-left = margin-right]; 순서는 상 하 좌 우 이니 참고하자","keywords":""},{"title":"componentDidUpdate() 내부에 setstate() 사용여부","type":0,"sectionRef":"#","url":"/blog/post/componentDidUpdate-내부에-setstate-사용여부","content":"react.js 을 사용하다 보면 부모 component 에서 prop 값이 변경될때 componentDidUpdate 을 사용하게된다. 하지만 componentDidUpdate 내부에서 setstate() 을 사용할경우 무한 루프에 빠지게 되어 다음과 같은 에러가 발생하게 된다. 이를 해결하기 위해서는 componentDidUpdate 내부에서 setstate() 사용시 if 문을 이용하여 제어해야 한다. * 예시 componentDidUpdate(previousProps, previousState) { if (previousProps.data !== this.props.data) { this.setState({/*....*/}) } } 아니면 componentDidUpdate 대신 componentWillReceiveProps 을 사용하면 된다. componentWillReceiveProps() : 해당 component 에서 mount 하기전에 실행되어 props 을 받음","keywords":""},{"title":"docker service log 보기","type":0,"sectionRef":"#","url":"/blog/post/docker-service-log-보기","content":"journalctl -u docker.service ","keywords":""},{"title":"docker remote port open (docker 원격 API 활성화)","type":0,"sectionRef":"#","url":"/blog/post/docker-remote-port-open-docker-원격-API-활성화","content":"","keywords":""},{"title":"1. /lib/systemd/system/docker.service 내용 수정​","type":1,"pageTitle":"docker remote port open (docker 원격 API 활성화)","url":"/blog/post/docker-remote-port-open-docker-원격-API-활성화#1-libsystemdsystemdockerservice-내용-수정","content":"[Service] EnvironmentFile=/etc/default/docker ExecStart=/usr/bin/dockerd -H fd:// $DOCKER_OPTS  "},{"title":"2. /etc/default/docker 내용 수정​","type":1,"pageTitle":"docker remote port open (docker 원격 API 활성화)","url":"/blog/post/docker-remote-port-open-docker-원격-API-활성화#2-etcdefaultdocker-내용-수정","content":"DOCKER_OPTS=&quot;--dns 8.8.8.8 --dns 8.8.4.4 -H tcp://0.0.0.0:2375 -H unix:///var/run/docker.sock&quot;  "},{"title":"3. docker 리로드 및 재시작​","type":1,"pageTitle":"docker remote port open (docker 원격 API 활성화)","url":"/blog/post/docker-remote-port-open-docker-원격-API-활성화#3-docker-리로드-및-재시작","content":"systemctl daemon-reload service docker restart  "},{"title":"4. 테스트​","type":1,"pageTitle":"docker remote port open (docker 원격 API 활성화)","url":"/blog/post/docker-remote-port-open-docker-원격-API-활성화#4-테스트","content":"curl http://localhost:2375/version {&quot;Platform&quot;:{&quot;Name&quot;:&quot;Docker Engine - Community&quot;},&quot;Components&quot;:[{&quot;Name&quot;:&quot;Engine&quot;,&quot;Version&quot;:&quot;18.09.2&quot;,&quot;Details&quot;:{&quot;ApiVersion&quot;:&quot;1.39&quot;,&quot;Arch&quot;:&quot;amd64&quot;,&quot;BuildTime&quot;:&quot;2019-02-10T03:42:13.000000000+00:00&quot;,&quot;Experimental&quot;:&quot;false&quot;,&quot;GitCommit&quot;:&quot;6247962&quot;,&quot;GoVersion&quot;:&quot;go1.10.6&quot;,&quot;KernelVersion&quot;:&quot;4.15.0-45-generic&quot;,&quot;MinAPIVersion&quot;:&quot;1.12&quot;,&quot;Os&quot;:&quot;linux&quot;}}],&quot;Version&quot;:&quot;18.09.2&quot;,&quot;ApiVersion&quot;:&quot;1.39&quot;,&quot;MinAPIVersion&quot;:&quot;1.12&quot;,&quot;GitCommit&quot;:&quot;6247962&quot;,&quot;GoVersion&quot;:&quot;go1.10.6&quot;,&quot;Os&quot;:&quot;linux&quot;,&quot;Arch&quot;:&quot;amd64&quot;,&quot;KernelVersion&quot;:&quot;4.15.0-45-generic&quot;,&quot;BuildTime&quot;:&quot;2019-02-10T03:42:13.000000000+00:00&quot;}  "},{"title":"Docker 이미지 저장 경로 변경하는 방법","type":0,"sectionRef":"#","url":"/blog/post/Docker-이미지-저장-경로-변경하는-방법","content":"/etc/default/docker 파일내용을 다음과 같이 수정 DOCKER_OPTS=&quot;--dns 8.8.8.8 -g &lt;YOUR_DIR&gt;&quot; 예시) # Docker Upstart and SysVinit configuration file # # THIS FILE DOES NOT APPLY TO SYSTEMD # # Please see the documentation for &quot;systemd drop-ins&quot;: # https://docs.docker.com/engine/admin/systemd/ # # Customize location of Docker binary (especially for development testing). #DOCKERD=&quot;/usr/local/bin/dockerd&quot; # Use DOCKER_OPTS to modify the daemon startup options. DOCKER_OPTS=&quot;--dns 8.8.8.8 --dns 8.8.4.4 -g /mnt&quot; # If you need Docker to use an HTTP proxy, it can also be specified here. #export http_proxy=&quot;http://127.0.0.1:3128/&quot; # This is also a handy place to tweak where Docker's temporary files go. #export DOCKER_TMPDIR=&quot;/mnt/bigdrive/docker-tmp&quot; /lib/systemd/system/docker.service 파일내용을 다음과 같이 수정 EnvironmentFile=/etc/default/docker ExecStart=/usr/bin/dockerd -H unix:// $DOCKER_OPTS 예시) [Service] Type=notify # the default is not to use systemd for cgroups because the delegate issues still # exists and systemd currently does not support the cgroup feature set required # for containers run by docker #ExecStart=/usr/bin/dockerd -H unix:// EnvironmentFile=/etc/default/docker ExecStart=/usr/bin/dockerd -H unix:// $DOCKER_OPTS ExecReload=/bin/kill -s HUP $MAINPID TimeoutSec=0 RestartSec=2 docker 서비스 리로딩 및 재시작 service docker stop sudo systemctl daemon-reload service docker start ","keywords":""},{"title":"elementary OS 에서 이클립스 멈춤현상","type":0,"sectionRef":"#","url":"/blog/post/elementary-OS에서-이클립스-멈춤현상","content":"이클립스를 elementary OS 에서 실행하고자 하면 이클립스 실행중으로 나오고 작동이 안된다. 원인 elementary OS 에서 쓰이는 GTK3 와 이클립스에 사용중인 GTK2이 충돌나서 그런것 같다 해결 eclipse.ini 파일에 다음을 추가한다 --launcher.GTK_version ","keywords":""},{"title":"DTO를 이너 클래스로 관리하기","type":0,"sectionRef":"#","url":"/blog/post/DTO를-이너-클래스로-관리하기","content":"","keywords":""},{"title":"Goal​","type":1,"pageTitle":"DTO를 이너 클래스로 관리하기","url":"/blog/post/DTO를-이너-클래스로-관리하기#goal","content":"DTO를 이너클래스로 관리해 개발 편의성을 올려봅니다.도메인 클래스안에 DTO를 이너클래스로 두는것이 설계상 괜찮은지에 대해서 고민해봅니다.  "},{"title":"요청별로 DTO를 외부 클래스로 나누어 관리하는 경우​","type":1,"pageTitle":"DTO를 이너 클래스로 관리하기","url":"/blog/post/DTO를-이너-클래스로-관리하기#요청별로-dto를-외부-클래스로-나누어-관리하는-경우","content":"너무 많은 DTO 클래스가 생겨 관리가 힘들어질 수 있습니다. @Getter @NoArgsConstructor(access = AccessLevel.PROTECTED) @Entity public class Member { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; public Member(final String name) { this.name = name; } }  만약 Member라는 도메인 클래스가 있다고 해봅시다. @Getter @AllArgsConstructor @NoArgsConstructor public class MemberCreateRequest { private String name; } @Getter @AllArgsConstructor public class MemberCreateResponse { private Long id; private String name; }  이때 Member를 create하는 기능이 필요할시, MemberCreateRequest, MemberCreateResponse 벌써 두개의 DTO 클래스가 필요해집니다.지금은 단순히 2개이지만, 여러 DTO가 계속 필요해지는 상황이 온다면 MemberxxxRequest 이런 DTO 클래스가 점점 늘어나게 되어 DTO를 선별하고 구분하는데 인적 리소스가 소모되게 될것입니다.  과거 진행한 프로젝트의 수많은 DTO 클래스들...  "},{"title":"DTO를 이너 클래스로 관리​","type":1,"pageTitle":"DTO를 이너 클래스로 관리하기","url":"/blog/post/DTO를-이너-클래스로-관리하기#dto를-이너-클래스로-관리","content":"DTO를 관리하는 (인적)비용이 줄어듭니다. @Getter @NoArgsConstructor(access = AccessLevel.PROTECTED) @Entity public class Member { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Long id; private String name; public Member(final String name) { this.name = name; } @Getter @AllArgsConstructor @NoArgsConstructor public static class Request { private String name; } @Getter @AllArgsConstructor public static class Response { private Long id; private String name; } }  위처럼 이너 클래스를 이용해, Member안에 Request와 Response DTO를 가지게 있게 한다면 어떻게 될까요.Member 클래스만 보고 관련된 DTO를 빠르게 찾을 수 있게되어, 인적 리소스가 줄어들고 개발의 편의성이 늘어나게 됩니다. @RestController @RequestMapping(&quot;/api/member&quot;) public class MemberController { @GetMapping(&quot;/{id}&quot;) public ResponseEntity&lt;Member.Response&gt; getMember(@PathVariable final Long id) { return ResponseEntity.ok(new Member.Response(id, &quot;unluckyjung&quot;)); } @PostMapping public ResponseEntity&lt;Member.Response&gt; create(@RequestBody final Member.Request request) { //...저장 로직 return ResponseEntity.created(URI.create(String.format(&quot;/api/member/%d&quot;, 1L))) .body(new Member.Response(1L, request.getName())); } }  이너클래스를 요청, 응답을 처리하는 컨트롤러 예제를 간단하게 작성하면, 위와 같이 구현할 수 있게 됩니다.(위 예제가 실제 개발에서 적용되는 방식은 아닙니다. 단순히 이해를 쉽기 위해서 작성한 예제일 뿐입니다.)  "},{"title":"고민되는 사항​","type":1,"pageTitle":"DTO를 이너 클래스로 관리하기","url":"/blog/post/DTO를-이너-클래스로-관리하기#고민되는-사항","content":"도메인이 DTO의 형태를 알고 있게 되는건 아닐까? 둘의 결합도가 높아지는건 아닐까? DTO를 도메인 객체와 분리해서 사용하는 이유는, DTO는 변경이 찾지만 도메인 객체는 그렇지 않습니다. 따라서 도메인을 DTO로 사용하는것은 변경이 잦은 형태에 의존성을 띠고 있는 형태가 되어, 올바르지 못한 설계가 되기때문에 도메인과 DTO 두개를 분리하는것 입니다.하지만, 위와같이 도메인(엄밀하게 따지면 엔티티이지만, 도메인으로 하겠습니다.) 객체가 DTO를 이너클래스로 가지고 있는 형태는 도메인이 DTO를 알고 있는 형태가 되어, 잘못된 설계가 아닌가? 라는 생각이 순간들었습니다. 결론적으로는 위의 예시와같은 형태는 괜찮다라고 생각합니다. 의존성을 띠고 있는 형태라 함은 Domain 객체의 로직에 DTO가 영향을 주게 되는것을 뜻하는것이라고 생각합니다.하지만 위와 같은 이너클래스 형태는 단순히 도메인 클래스안에 DTO 클래스를 들고만 있지, DTO 와 도메인의 로직에는 전혀 영향이 없는 형태입니다. 즉 로직이나 상태에 따른 의존성이 있는 형태는 아닌거죠.도메인 &lt;-&gt; DTO 끼리 연관이 생긴다는것보다는, 해당 도메인과 관련된 DTO를 같이 묶어두기 위한 정도인거죠.즉, 편의성을 위해서 도메인내에 이너 클래스를 묶어서 사용하는것이기 때문에 다른 시야로 봐야한다고 결론 내렸습니다.물론 여러 도메인들이 합쳐져서 만들어지는 DTO 라면, 한 도메인의 이너클래스로 DTO를 사용하면 안되겠죠. "},{"title":"장점​","type":1,"pageTitle":"DTO를 이너 클래스로 관리하기","url":"/blog/post/DTO를-이너-클래스로-관리하기#장점","content":"응집도가 높아지는 효과가 있습니다. 위에서 말한 여러 도메인들이 합쳐져서 만들어지는 DTO 는 이너클래스로 사용하지 않는다. 라는 룰을 지킨다면개발자 입장에서 이너클래스의 DTO를 보았을때 이너 클래스 DTO는 해당 클래스 안에서만 한정적으로 사용한다는 의미를 부여할 수 있어, 응집력이 높아지고 개발자들이 신경써야 하는 외부클래스의 개수가 줄어들어 개발 편의성을 높이는 효과를 나타낼 수 있다고 생각합니다.  "},{"title":"Conclusion​","type":1,"pageTitle":"DTO를 이너 클래스로 관리하기","url":"/blog/post/DTO를-이너-클래스로-관리하기#conclusion","content":"이너클래스를 이용해 DTO 관리의 편의성을 높일 수 있다.하지만 이너클래스로 만들어진 DTO는, 속해 있는 도메인 클래스로만 구성되는 경우에 사용해야한다.  "},{"title":"Reference​","type":1,"pageTitle":"DTO를 이너 클래스로 관리하기","url":"/blog/post/DTO를-이너-클래스로-관리하기#reference","content":"https://www.inflearn.com/questions/47205https://velog.io/@ausg/Spring-Boot%EC%97%90%EC%84%9C-%EA%B9%94%EB%81%94%ED%95%98%EA%B2%8C-DTO-%EA%B4%80%EB%A6%AC%ED%95%98%EA%B8%B0 "},{"title":"출처​","type":1,"pageTitle":"DTO를 이너 클래스로 관리하기","url":"/blog/post/DTO를-이너-클래스로-관리하기#출처","content":"DTO를 inner class로 관리하기 (https://unluckyjung.github.io/dev/2022/02/20/Dto-InnerClass/) "},{"title":"freebsd 에서 gui 환경 셋팅하기","type":0,"sectionRef":"#","url":"/blog/post/freebsd-에서-gui-환경-셋팅하기","content":"","keywords":""},{"title":"1. install gnome3​","type":1,"pageTitle":"freebsd 에서 gui 환경 셋팅하기","url":"/blog/post/freebsd-에서-gui-환경-셋팅하기#1-install-gnome3","content":"$ pkg install gnome3  "},{"title":"2. fstab 파일 설정​","type":1,"pageTitle":"freebsd 에서 gui 환경 셋팅하기","url":"/blog/post/freebsd-에서-gui-환경-셋팅하기#2-fstab-파일-설정","content":"/etc/fstab 파일에 내용추가 proc /proc procfs rw 0 0  "},{"title":"3. rc.conf 파일설정​","type":1,"pageTitle":"freebsd 에서 gui 환경 셋팅하기","url":"/blog/post/freebsd-에서-gui-환경-셋팅하기#3-rcconf-파일설정","content":"dbus_enable=&quot;YES&quot; hald_enable=&quot;YES&quot; gdm_enable=&quot;YES&quot; gnome_enable=&quot;YES&quot;  "},{"title":"4. 재부팅후 확인​","type":1,"pageTitle":"freebsd 에서 gui 환경 셋팅하기","url":"/blog/post/freebsd-에서-gui-환경-셋팅하기#4-재부팅후-확인","content":"$ reboot   참고 : freebsd handbook - 5.7. Desktop Environments "},{"title":"freebsd 에서 게스트확장 설치하기","type":0,"sectionRef":"#","url":"/blog/post/freebsd-에서-게스트확장-설치하기","content":"","keywords":""},{"title":"1. vbox guest additions 설치하기​","type":1,"pageTitle":"freebsd 에서 게스트확장 설치하기","url":"/blog/post/freebsd-에서-게스트확장-설치하기#1-vbox-guest-additions-설치하기","content":"$ pkg install virtualbox-ose-additions  "},{"title":"2. /etc/X11/xorg.conf 파일 설정​","type":1,"pageTitle":"freebsd 에서 게스트확장 설치하기","url":"/blog/post/freebsd-에서-게스트확장-설치하기#2-etcx11xorgconf-파일-설정","content":"$ vim /etc/X11/xorg.conf  Section &quot;Device&quot; Identifier &quot;Card0&quot; Driver &quot;vboxvideo&quot; VendorName &quot;InnoTek Systemberatung GmbH&quot; BoardName &quot;VirtualBox Graphics Adapter&quot; EndSection Section &quot;InputDevice&quot; Identifier &quot;Mouse0&quot; Driver &quot;vboxmouse&quot; EndSection  "},{"title":"3. /etc/rc.conf 파일 설정​","type":1,"pageTitle":"freebsd 에서 게스트확장 설치하기","url":"/blog/post/freebsd-에서-게스트확장-설치하기#3--etcrcconf-파일-설정","content":"$ vim /etc/rc.conf  /etc/rc.conf 파일에 다음과 내용 추가 vboxguest_enable=&quot;YES&quot; vboxservice_enable=&quot;YES&quot;  "},{"title":"4. reboot 후 확인​","type":1,"pageTitle":"freebsd 에서 게스트확장 설치하기","url":"/blog/post/freebsd-에서-게스트확장-설치하기#4-reboot-후-확인","content":"$ reboot   참고 : freebsd handbook - 21.5. FreeBSD as a Guest on VirtualBox "},{"title":"gitlab docker root password reset","type":0,"sectionRef":"#","url":"/blog/post/gitlab-docker-root-password-reset","content":"","keywords":""},{"title":"초기화​","type":1,"pageTitle":"gitlab docker root password reset","url":"/blog/post/gitlab-docker-root-password-reset#초기화","content":"docker console 접속 $ docker exec -it gitlab /bin/bash Ruby on Rails console 접속 $ gitlab-rails console production root 유저 설정으로 접속 irb(main):006:0&gt; user = User.where(id: 1).first or irb(main):006:0&gt; user = User.find_by(email: 'admin@example.com') 패스워드 초기화 irb(main):006:0&gt; user.password = 'secret_pass' irb(main):006:0&gt; user.password_confirmation = 'secret_pass' 저장 irb(main):006:0&gt; user.save!  "},{"title":"git pull시 'fatal: 관계 없는 커밋 내역의 병합을 거부합니다' 발생시","type":0,"sectionRef":"#","url":"/blog/post/git-pull시-fatal-관계-없는-커밋-내역의-병합을-거부합니다-발생시","content":"","keywords":""},{"title":"해결방안​","type":1,"pageTitle":"git pull시 'fatal: 관계 없는 커밋 내역의 병합을 거부합니다' 발생시","url":"/blog/post/git-pull시-fatal-관계-없는-커밋-내역의-병합을-거부합니다-발생시#해결방안","content":"$ git fetch --all $ git reset --hard origin/master $ git pull origin master  git fetch --all : git remote 에서 전체 내용을 받아온다.git reset --hard origin/master : 수정된 내역을 지우고 이전내용으로 복구한다.git pull origin master : 현재 작업하고있는 로컬에 커밋을 병합한다. "},{"title":"Hbase RegionServer 가 시간마다 셧다운될때","type":0,"sectionRef":"#","url":"/blog/post/Hbase-RegionServer-가-시간마다-셧다운될때","content":"","keywords":""},{"title":"원인 : 시간 동기화 문제​","type":1,"pageTitle":"Hbase RegionServer 가 시간마다 셧다운될때","url":"/blog/post/Hbase-RegionServer-가-시간마다-셧다운될때#원인--시간-동기화-문제","content":"로그에 다음과같은 에러 메세지 출력 2018-02-06 22:17:06,598 INFO [regionserver/node04/192.168.1.194:16020] regionserver.HRegionServer: STOPPED: Unhandled: org.apache.hadoop.hbase.ClockOutOfSyncException: Server node04,16020,1517973362638 has been rejected; Reported time is too far out of sync with master. Time difference of 37329ms &gt; max allowed of 30000ms  "},{"title":"각 노드마다 시간 동기화 필요​","type":1,"pageTitle":"Hbase RegionServer 가 시간마다 셧다운될때","url":"/blog/post/Hbase-RegionServer-가-시간마다-셧다운될때#각-노드마다-시간-동기화-필요","content":""},{"title":"hexo -> notion 으로 데이터 이전중 입니다.","type":0,"sectionRef":"#","url":"/blog/post/hexo-notion-으로-데이터-이전중-입니다","content":"ㅈㄱㄴ","keywords":""},{"title":"Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.40/containers/json: dial unix /var/run/docker.sock: connect: permission denied","type":0,"sectionRef":"#","url":"/blog/post/Got-permission-denied-while-trying-to-connect-to-the-Docker-daemon-socket-at-unix-var-run-docker-sock-Get-http-2Fvar-2Frun-2Fdocker-sock-v1-40-containers-json-dial-unix-var-run-docker-sock-connect-permission-denied","content":"docker가 root 계정으로 설치 되었을때 root 계정이 아닌 계정으로 docker를 실행하고자 하면 제목과 같은 에러가 발생할 때가 있다. $ sudo usermod -a -G docker $USER $ sudo service docker restart ","keywords":""},{"title":"hexo password 설정","type":0,"sectionRef":"#","url":"/blog/post/hexo-password-설정","content":"hexo-blog-encrypt 모듈 설치 $ npm install --save hexo-blog-encrypt _config.yml 에 다음항목 추가 encrypt: enable: true post 상단에 다음 항목추가 --- password: mikemessi abstract: Welcome to my blog, enter password to read. message: Welcome to my blog, enter password to read. --- ","keywords":""},{"title":"hexo 에서 html 문서 계시하기","type":0,"sectionRef":"#","url":"/blog/post/hexo-에서-html-문서-계시하기","content":"hexo 에서 마크다운형식으로 페이지를 만들지만 가끔씩 마크다운 문서가 아닌 html 문서로 계시해야 할 경우가 발생한다. 그럴경우 html 문서 상단에 다음과 같은 태그를 추가한다. --- title: ppts date: 2019-02-17 20:08:57 layout: false --- 하지만 css, js 파일은 인식이 안되어서 cdn 을 통하여 직접 임포트를 해야하는것 같다.","keywords":""},{"title":"hexo tags 페이지 생성","type":0,"sectionRef":"#","url":"/blog/post/hexo-tags-페이지-생성","content":"hexo new page &quot;tags&quot; source/tags/index.md header 수정 --- title: Tags date: 2018-12-27 00:55:17 type: tags --- ","keywords":""},{"title":"hexo 에서 페이지가 깨질때","type":0,"sectionRef":"#","url":"/blog/post/hexo-에서-페이지가-깨질때","content":"","keywords":""},{"title":"증상​","type":1,"pageTitle":"hexo 에서 페이지가 깨질때","url":"/blog/post/hexo-에서-페이지가-깨질때#증상","content":"hexo 에서 hexo deploy 을 실행후 다음과 같은 에러 발생 "},{"title":"원인​","type":1,"pageTitle":"hexo 에서 페이지가 깨질때","url":"/blog/post/hexo-에서-페이지가-깨질때#원인","content":"이전의 deploy 할때의 css 파일이 남아서 생긴문제 "},{"title":"해결​","type":1,"pageTitle":"hexo 에서 페이지가 깨질때","url":"/blog/post/hexo-에서-페이지가-깨질때#해결","content":"다음 명령어 입력 $ hexo clean $ hexo deploy  입력후 정상적으로 동작확인 "},{"title":"How to Disable SELinux on CentOS 7","type":0,"sectionRef":"#","url":"/blog/post/How-to-Disable-SELinux-on-CentOS-7","content":"SELinux(Security Enhanced Linux)는 관리자와 사용자가 액세스 제어에 대한 제어력을 높일 수 있는 Linux 커널 보안 모듈이다. SELinux 정책 규칙에 따라 접속할 수 있다. SELinux 정책 규칙은 프로세스와 사용자가 파일과 상호 작용하는 방법뿐만 아니라 프로세스와 사용자가 서로 상호작용하는 방법을 지정한다. 파일을 여는 프로세스처럼 액세스를 특별히 허용하는 SELinux 정책 규칙이 없는 경우, 액세스가 거부된다. Disable SELinux SELinux mode 변경 sudo setenforce 0 /etc/selinux/config 변경 SELINUX 항목을 disabled로 변경 # This file controls the state of SELinux on the system. # SELINUX= can take one of these three values: # enforcing - SELinux security policy is enforced. # permissive - SELinux prints warnings instead of enforcing. # disabled - No SELinux policy is loaded. SELINUX=disabled # SELINUXTYPE= can take one of these two values: # targeted - Targeted processes are protected, # mls - Multi Level Security protection. SELINUXTYPE=targeted Server reboot","keywords":""},{"title":"java.io.IOException: com.jcraft.jsch.JSchException: invalid privatekey: [B@24a1c17f jsch 오류발생","type":0,"sectionRef":"#","url":"/blog/post/java-io-IOException-com-jcraft-jsch-JSchException-invalid-privatekey-B-24a1c17f-jsch-오류발생","content":"jsch 운영간에 다음과 같은 에러발생 Caused by: com.jcraft.jsch.JSchException: invalid privatekey: [B@24a1c17f at com.jcraft.jsch.KeyPair.load(KeyPair.java:902) at com.jcraft.jsch.KeyPair.load(KeyPair.java:543) at com.jcraft.jsch.IdentityFile.newInstance(IdentityFile.java:40) at com.jcraft.jsch.JSch.addIdentity(JSch.java:393) at com.jcraft.jsch.JSch.addIdentity(JSch.java:353) at com.jcabi.ssh.SSH.session(SSH.java:261) 원인 jsch 에서 연동되는 .ssh/id_rsa 파일형식이 잘못되었다.cat ~/.ssh/id_rsa 파일을 확인하면 다음과 같이 출력 -----BEGIN OPENSSH PRIVATE KEY----- ........ ........ ........ -----END OPENSSH PRIVATE KEY----- 조치사항 ssh-keygen 으로 키을 생성할때 다음과 같은 옵셥추가 $ ssh-keygen -m PEM ","keywords":""},{"title":"java 랜덤 문자열 생성","type":0,"sectionRef":"#","url":"/blog/post/java-랜덤-문자열-생성","content":"pom.xml 추가 &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;/dependency&gt; 랜덤 문자열 생성 : 알파벳 랜덤 5개 생성 RandomStringUtils.randomAlphabetic(5) 랜덤 문자열 생성 : 숫자포함 알파벳 랜덤 5개 생성 RandomStringUtils.randomAlphanumeric(5) 랜덤 문자열 생성 : 아스키 코드 랜덤 5개 생성 RandomStringUtils.randomAscii(5) ","keywords":""},{"title":"java spark wordcount examples","type":0,"sectionRef":"#","url":"/blog/post/java-spark-wordcount-examples","content":"pom.xml 설정 &lt;dependency&gt; &lt;groupId&gt;org.apache.spark&lt;/groupId&gt; &lt;artifactId&gt;spark-core_2.12&lt;/artifactId&gt; &lt;version&gt;2.4.3&lt;/version&gt; &lt;/dependency&gt; . . . &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.0.2&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;archive&gt; &lt;manifest&gt; &lt;addClasspath&gt;true&lt;/addClasspath&gt; &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt; &lt;mainClass&gt;com.geekcap.javaworld.sparkexample.WordCount&lt;/mainClass&gt; &lt;/manifest&gt; &lt;/archive&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-dependency-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;copy&lt;/id&gt; &lt;phase&gt;install&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;copy-dependencies&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;outputDirectory&gt;${project.build.directory}/lib&lt;/outputDirectory&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; java example SparkConf sparkConf = new SparkConf().setMaster(&quot;local&quot;).setAppName(&quot;JD Word Counter&quot;); JavaSparkContext sc = new JavaSparkContext(sparkConf); JavaRDD&lt;String&gt; textFile = sc.textFile(&quot;text.txt&quot;); JavaPairRDD&lt;String, Integer&gt; counts = textFile .flatMap(s -&gt; Arrays.asList(s.split(&quot; &quot;)).iterator()) .mapToPair(word -&gt; new Tuple2&lt;&gt;(word, 1)) .reduceByKey((a, b) -&gt; a + b); counts.saveAsTextFile(&quot;wordcouter&quot;); ","keywords":""},{"title":"locale.Error: unsupported locale setting","type":0,"sectionRef":"#","url":"/blog/post/locale-Error-unsupported-locale-setting","content":"Traceback (most recent call last): File &quot;/bin/pip&quot;, line 9, in &lt;module&gt; load_entry_point('pip==8.1.1', 'console_scripts', 'pip')() File &quot;/usr/lib/python2.7/site-packages/pip-8.1.1-py2.7.egg/pip/__init__.py&quot;, line 215, in main locale.setlocale(locale.LC_ALL, '') File &quot;/usr/lib64/python2.7/locale.py&quot;, line 547, in setlocale return _setlocale(category, locale) locale.Error: unsupported locale setting 해결책 export LC_ALL=&quot;en_US.UTF-8&quot; export LC_CTYPE=&quot;en_US.UTF-8&quot; ","keywords":""},{"title":"linux 에서 vscode-chrome-debug 설정하기","type":0,"sectionRef":"#","url":"/blog/post/linux-에서-vscode-chrome-debug-설정하기","content":"launch.json 에서 다음과 같이 수정 { // IntelliSense를 사용하여 가능한 특성에 대해 알아보세요. // 기존 특성에 대한 설명을 보려면 가리킵니다. // 자세한 내용을 보려면 https://go.microsoft.com/fwlink/?linkid=830387을(를) 방문하세요. &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ { &quot;type&quot;: &quot;chrome&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Launch Chrome against localhost&quot;, &quot;url&quot;: &quot;http://localhost:3000&quot;, &quot;webRoot&quot;: &quot;${workspaceFolder}/src&quot;, &quot;runtimeExecutable&quot;: &quot;/usr/bin/google-chrome-stable&quot;, &quot;runtimeArgs&quot;: [ &quot;--new-window&quot;, &quot;-user-data-dir=\\&quot;/${workspaceFolder}/DevProfile\\&quot;&quot;, &quot;--remote-debugging-port=9222&quot;, &quot;--disable-background-networking&quot; ] } ] } runtimeExecutable 에 들어갈 chrome 위치 확인하기 whereis google-chrome-stable ","keywords":""},{"title":"manjaro 에서 pacman 이용시 pgp 에러 발생시","type":0,"sectionRef":"#","url":"/blog/post/manjaro-에서-pacman-이용시-pgp-에러-발생시","content":"pacman -Syyu 입력시 다음 에러가 발생할경우 $ pacman -Syyu error: fzf: signature from &quot;Ambrevar &lt;ambrevar@gmail.com&gt;&quot; is unknown trust :: File /var/cache/pacman/pkg/fzf-0.17.0.2-1-x86_64.pkg.tar.xz is corrupted (invalid or corrupted package (PGP signature)). 다음 명령어로 해결한다. sudo pacman-key --refresh-keys 다음 에러가 추가 발생시 $ sudo pacman -Syu error: GPGME error: No data error: GPGME error: No data error: GPGME error: No data error: GPGME error: No data 다음 명령어를 입력한다. sudo pacman -Sy archlinux-keyring manjaro-keyring sudo pacman-key --populate archlinux manjaro 다음에 다시한번 확인한다. sudo pacman -Syyu 원인은 자세하게 확인해봐야 하겠지만 업데이트 서버에 있는 서명과 내노트북에 있는 서명값이 달라서 생긴것 같다.","keywords":""},{"title":"Lombok을 이용해 Builder 패턴을 만들어보자.","type":0,"sectionRef":"#","url":"/blog/post/Lombok을-이용해-Builder-패턴을-만들어보자","content":"Builder 패턴이란? Effective Java 규칙 2 - 조슈아 블로그 생성자에 인자가 많을 때는 빌더 패턴을 고려하라 빌더 패턴(Builder pattern) 이란 복합 객체의 생성 과정과 표현 방법을 분리하여 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있게 하는 패턴이다. (출처: 위키백과) 난 생성자가 많아지면 빌더 패턴을 만드는 편인데, 개발자 성향에 따라 다를수도 있구나를 느꼈다. 빌더패턴을 활용하면 어떤 필드에 어떤 인자를 넣어줬는지 명확히 알 수 있고, 넣어줄 필요 없는 필드(null)는 굳이 선언할 필요 없으니 좋다고 생각했다. 근데 다른 분은 어떤 필드에 null이 들어간다는걸 명확히 볼 수 있는 점 때문에 생성자를 통해 객체를 생성하시는 방법을 택했다고 하셨다. intelliJ는 들어갈 필드의 값을 표시해주는 기능이 있어서 생성자를 통해 객체를 생성해도 어떤 필드를 넣어줘야하는지 보인다. 첫 회사에서는 STS를 썼기 때문에 intelliJ의 다양한 기능적인 혜택을 누리지 못했기도 해서 빌더 패턴이 유용했다. 코틀린을 사용할 경우에는.... 굳이 빌더 패턴을 쓸 필요가 없을 것 같다 싶었던 이유가 생성자 인자에 필드 명도 함께 표기할 수 있다. // 예시 fun foo() { val member = Member(name = &quot;zorba&quot;, job = &quot;developer&quot;) } 하지만, java를 쓸 때는 자주 사용하는 디자인 패턴이다. 빌더 패턴의 장점 객체들마다 들어가야할 인자가 각각 다를 때 유연하게 사용할 수 있다. 무조건 setter 생성을 방지하고 불변객체로 만들 수 있다. 필수 argument를 지정할 수 있다.(보통의 경우, PK 역할을 할 Id 값이 될 것이다.) Builder 패턴은 어떻게 작성하나? 이 페이지를 들어가면 명확하게 빌더 패턴을 어떻게 작성해야하는지 알 수 있다. 빌더 패턴 예제코드 Java 사용자라면 잘 아는 StringBuilder가 이 빌더 패턴으로 작성된 라이브러리다. 근데 클래스를 만들 때마다 이 기나긴 코드를 짜기 불편하다! 그래서 Java 개발자들의 보일러플레이트 코드를 획기적으로 줄여준 라이브러리인 Lombok을 활용해보자. 바로 @Builder 애노테이션 을 사용하면 예제코드처럼 긴 코드를 작성하지 않아도 된다. Builder 패턴을 적용할 클래스 @AllArgsConstructor(access = AccessLevel.PRIVATE) @Builder(builderMethodName = &quot;travelCheckListBuilder&quot;) @ToString public class TravelCheckList { private Long id; private String passport; private String flightTicket; private String creditCard; private String internationalDriverLicense; private String travelerInsurance; public static TravelCheckListBuilder builder(Long id) { if(id == null) { throw new IllegalArgumentException(&quot;필수 파라미터 누락&quot;); } return travelCheckListBuilder().id(id); } } 확인용 클래스 public class MainClass { public static void main(String[] args) { // 빌더패턴을 통해 어떤 필드에 어떤 값을 넣어주는지 명확히 눈으로 확인할 수 있다! TravelCheckList travelCheckList = TravelCheckList.builder(145L) .passport(&quot;M12345&quot;) .flightTicket(&quot;Paris flight ticket&quot;) .creditCard(&quot;Shinhan card&quot;) .internationalDriverLicense(&quot;1235-5345&quot;) .travelerInsurance(&quot;Samsung insurance&quot;) .build(); System.out.println(&quot;빌더 패턴 적용하기 : &quot; + travelCheckList.toString()); } // 결과 // 빌더 패턴 적용하기 : TravelCheckList(id=1, passport=M12345, flightTicket=Paris flight ticket, creditCard=Shinhan card, internationalDriverLicense=1235-5345, travelerInsurance=Samsung insurance) } @AllArgsConstructor(access = AccessLevel.PRIVATE) : @Builder 애노테이션을 선언하면 전체 인자를 갖는 생성자를 자동으로 만든다. @AllArgsConstructor는 전체 인자를 갖는 생성자를 만드는데, 접근자를 private으로 만들어서 외부에서 접근할 수 없도록 만든다. @Builder : 위에서 설명했던 Builder 패턴을 자동으로 생성해주는데, builderMethodName에 들어간 이름으로 빌더 메서드를 생성해준다. 나같은 경우, 혼동을 줄이기 위해 클래스 명과 동일하게 놔두고 Builder로 선언했다. 클래스 내부 builder 메서드 : 필수로 들어가야할 필드들을 검증하기 위해 만들었다. 꼭 id가 아니라도 해당 클래스를 객체로 생성할 때 필수적인 필드가 있다면 활용할 수 있다. 이렇게 Lombok을 활용하면 반복적으로 길게 짜야하는 코드(보일러 플레이트 코드)를 엄청나게 줄여줄 수 있다. 빌더 패턴을 사용하면서 무분별한 setter를 남용한다면.... 빌더패턴의 장점을 극대화해서 사용하는 건 아닌 것 같다.","keywords":""},{"title":"manjaro 에서 update 할때 npm : /usr/lib/node_modules/npm/node_modules/query-string/index.d.ts 증복오류 발생","type":0,"sectionRef":"#","url":"/blog/post/manjaro-에서-update-할때-npm-usr-lib-node-modules-npm-node-modules-query-string-index-d-ts-증복오류-발생","content":"","keywords":""},{"title":"원인​","type":1,"pageTitle":"manjaro 에서 update 할때 npm : /usr/lib/node_modules/npm/node_modules/query-string/index.d.ts 증복오류 발생","url":"/blog/post/manjaro-에서-update-할때-npm-usr-lib-node-modules-npm-node-modules-query-string-index-d-ts-증복오류-발생#원인","content":"과게에 npm 을 pacman 으로 설치하고 최근에 npm install -g npm 을 해서 중복된 파일이 발생하여 무결성 검사에 실패함 "},{"title":"조치​","type":1,"pageTitle":"manjaro 에서 update 할때 npm : /usr/lib/node_modules/npm/node_modules/query-string/index.d.ts 증복오류 발생","url":"/blog/post/manjaro-에서-update-할때-npm-usr-lib-node-modules-npm-node-modules-query-string-index-d-ts-증복오류-발생#조치","content":"$ sudo pacman -S npm --overwrite /usr/lib/node_modules/npm/node_modules/query-string/index.d.ts  명령어로 해결 pacman 설치시 중복된 파일이 있을경우 --overwrite /filepath 을 사용하자 "},{"title":"markdown 문서에서 word 문서로 변환","type":0,"sectionRef":"#","url":"/blog/post/markdown-문서에서-word-문서로-변환","content":"","keywords":""},{"title":"markdown 문서 -> 워드형식으로 변환​","type":1,"pageTitle":"markdown 문서에서 word 문서로 변환","url":"/blog/post/markdown-문서에서-word-문서로-변환#markdown-문서---워드형식으로-변환","content":"markdown 문서를 작성하다가 워드형식으로 문서가 필요했고 마크다운에서 복붙하기에는 양식이 깨져서 문제가 있었다. 해결방안을 찾다가 pandoc 이라는 것을 찾아서 적용하기로 했다. "},{"title":"설치​","type":1,"pageTitle":"markdown 문서에서 word 문서로 변환","url":"/blog/post/markdown-문서에서-word-문서로-변환#설치","content":"$ sudo pacman -S pandoc  지금 사용하는 리눅스는 manjaro 이니 설치한 리늑스에 맞추어서 사용하면 된다. "},{"title":"변환​","type":1,"pageTitle":"markdown 문서에서 word 문서로 변환","url":"/blog/post/markdown-문서에서-word-문서로-변환#변환","content":"$ pandoc README.md -f markdown -t docx -s -o README.docx  "},{"title":"참고​","type":1,"pageTitle":"markdown 문서에서 word 문서로 변환","url":"/blog/post/markdown-문서에서-word-문서로-변환#참고","content":"https://hue9010.github.io/etc/pandoc/ "},{"title":"minishift install 하기","type":0,"sectionRef":"#","url":"/blog/post/minishift-install-하기","content":"","keywords":""},{"title":"1. 개요​","type":1,"pageTitle":"minishift install 하기","url":"/blog/post/minishift-install-하기#1-개요","content":""},{"title":"2. 설치​","type":1,"pageTitle":"minishift install 하기","url":"/blog/post/minishift-install-하기#2-설치","content":"https://docs.okd.io/latest/minishift/getting-started/setting-up-virtualization-environment.html 참고 "},{"title":"2.1. libvirt qemu dnsmasq ebtables 설치​","type":1,"pageTitle":"minishift install 하기","url":"/blog/post/minishift-install-하기#21-libvirt-qemu-dnsmasq-ebtables-설치","content":"$ sudo pacman -S libvirt qemu dnsmasq ebtables  "},{"title":"2.2. 로그인된 계정을 kvm,libvir 그룹에 추가​","type":1,"pageTitle":"minishift install 하기","url":"/blog/post/minishift-install-하기#22-로그인된-계정을-kvmlibvir-그룹에-추가","content":"$ sudo usermod -a -G kvm,libvirt $(whoami)  "},{"title":"2.3. /etc/libvirt/qemu.conf 내용 추가​","type":1,"pageTitle":"minishift install 하기","url":"/blog/post/minishift-install-하기#23-etclibvirtqemuconf-내용-추가","content":"$ sudo sed -ri 's/.?group\\s?=\\s?&quot;.+&quot;/group = &quot;kvm&quot;/1' /etc/libvirt/qemu.conf  "},{"title":"2.4. libvirt 그룸생성​","type":1,"pageTitle":"minishift install 하기","url":"/blog/post/minishift-install-하기#24-libvirt-그룸생성","content":"$ newgrp libvirt  "},{"title":"2.5. root 계정에서 KVM driver binary 설치​","type":1,"pageTitle":"minishift install 하기","url":"/blog/post/minishift-install-하기#25-root-계정에서-kvm-driver-binary-설치","content":"# curl -L https://github.com/dhiltgen/docker-machine-kvm/releases/download/v0.10.0/docker-machine-driver-kvm-centos7 -o /usr/local/bin/docker-machine-driver-kvm # chmod +x /usr/local/bin/docker-machine-driver-kvm  "},{"title":"2.6. libvirt networking 설정​","type":1,"pageTitle":"minishift install 하기","url":"/blog/post/minishift-install-하기#26-libvirt-networking-설정","content":"2.6.1 네트워크 확인​  sudo virsh net-list --all 이름 상태 자동 시작 Persistent ---------------------------------------------------- default 활성화 예 예 docker-machines 활성화 예 예 minikube-net 활성화 예 예  2.6.2 default libvirt network 시작​ $ sudo virsh net-start default  2.6.3 libvirt network 자동시작 설정​ $ sudo virsh net-autostart default  "},{"title":"2.3. minishift 설치​","type":1,"pageTitle":"minishift install 하기","url":"/blog/post/minishift-install-하기#23-minishift-설치","content":" "},{"title":"3. minishift 시작​","type":1,"pageTitle":"minishift install 하기","url":"/blog/post/minishift-install-하기#3-minishift-시작","content":"$ minishift start  "},{"title":"mecab-ko-dic 품사 태그 설명","type":0,"sectionRef":"#","url":"/blog/post/mecab-ko-dic-품사-태그-설명","content":"","keywords":""},{"title":"세종 품사 태그​","type":1,"pageTitle":"mecab-ko-dic 품사 태그 설명","url":"/blog/post/mecab-ko-dic-품사-태그-설명#세종-품사-태그","content":"태그\t설명NNG NNP\t고유 명사 NNB\t의존 명사 NR\t수사 NP\t대명사 VV\t동사 VA\t형용사 VX\t보조 용언 VCP\t긍정 지정사 VCN\t부정 지정사 MM\t관형사 MAG\t일반 부사 MAJ\t접속 부사 IC\t감탄사 JKS\t주격 조사 JKC\t보격 조사 JKG\t관형격 조사 JKO\t목적격 조사 JKB\t부사격 조사 JKV\t호격 조사 JKQ\t인용격 조사 JX\t보조사 JC\t접속 조사 EP\t선어말 어미 EF\t종결 어미 EC\t연결 어미 ETN\t명사형 전성 어미 ETM\t관형형 전성 어미 XPN\t체언 접두사 XSN\t명사 파생 접미사 XSV\t동사 파생 접미사 XSA\t형용사 파생 접미사 XR\t어근 SF\t마침표, 물음표, 느낌표 SE\t줄임표 SS\t따옴표,괄호표,줄표 SP\t쉼표,가운뎃점,콜론,빗금 SO\t붙임표(물결,숨김,빠짐) SW\t기타기호 (논리수학기호,화폐기호) SL\t외국어 SH\t한자 SN\t숫자 "},{"title":"mecab-ko-dic 품사 태그​","type":1,"pageTitle":"mecab-ko-dic 품사 태그 설명","url":"/blog/post/mecab-ko-dic-품사-태그-설명#mecab-ko-dic-품사-태그","content":"태그\t설명NNG\t일반 명사 NNP\t고유 명사 NNB\t의존 명사 NNBC\t단위를 나타내는 명사 NR\t수사 NP\t대명사 VV\t동사 VA\t형용사 VX\t보조 용언 VCP\t긍정 지정사 VCN\t부정 지정사 MM\t관형사 MAG\t일반 부사 MAJ\t접속 부사 IC\t감탄사 JKS\t주격 조사 JKC\t보격 조사 JKG\t관형격 조사 JKO\t목적격 조사 JKB\t부사격 조사 JKV\t호격 조사 JKQ\t인용격 조사 JX\t보조사 JC\t접속 조사 EP\t선어말 어미 EF\t종결 어미 EC\t연결 어미 ETN\t명사형 전성 어미 ETM\t관형형 전성 어미 XPN\t체언 접두사 XSN\t명사 파생 접미사 XSV\t동사 파생 접미사 XSA\t형용사 파생 접미사 XR\t어근 SF\t마침표, 물음표, 느낌표 SE\t줄임표 … SSO\t여는 괄호 (, [ SSC\t닫는 괄호 ), ] SC\t구분자 , · / : SY SL\t외국어 SH\t한자 SN\t숫자 "},{"title":"mp4 -> gif 로 파일변환","type":0,"sectionRef":"#","url":"/blog/post/mp4-gif-로-파일변환","content":"","keywords":""},{"title":"개요​","type":1,"pageTitle":"mp4 -> gif 로 파일변환","url":"/blog/post/mp4-gif-로-파일변환#개요","content":"markdown 으로 문서작성간에 실제 사용하는 장면을 추가하고 싶지만 동영상 파일자체의 용량도 크고 마크다운에서는 이미지만 첨부가능 하여 방법을 찾다가. gif 로 변환하여 첨부하기로 했다. "},{"title":"설치​","type":1,"pageTitle":"mp4 -> gif 로 파일변환","url":"/blog/post/mp4-gif-로-파일변환#설치","content":"$ sudo pacman -S ffmpeg  "},{"title":"mp4 -> gif​","type":1,"pageTitle":"mp4 -> gif 로 파일변환","url":"/blog/post/mp4-gif-로-파일변환#mp4---gif","content":"$ ffmpeg -i Screencast\\ 2019-07-07\\ 16:27:53.mp4 Screencast\\ 2019-07-07\\ 16:27:53.gif  이렇게 변환을 했더니 용량이 50메가 넘게 나와서 업로드가 안되었다. 프레임을 낮추어서 변환을 진행했다. $ ffmpeg -i Screencast\\ 2019-07-07\\ 16:27:53.mp4 -r 5 Screencast\\ 2019-07-07\\ 16:27:53.gif  -r 5 옵션은 5프레임으로 설정한다는 뜻이다. 변환후에 용량을 확인해보니 20메가 이하로 줄었다. 확인해보니 샤나인코더도 ffmpeg 기반이라고 한다. https://namu.wiki/w/FFmpeg "},{"title":"npm build 간 javascript heap out of memory npm build 발생시","type":0,"sectionRef":"#","url":"/blog/post/npm-build-간-javascript-heap-out-of-memory-npm-build-발생시","content":"npm run build 후 다음과 같은 에러 메세지 발생 FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory 원인 이는 기본 Node.js 가용 메모리가 빌드하기에 충분하지 않아 발생하는 오류 조치 package.json 내부의 build 항목을 다음과 같이 수정 &quot;scripts&quot;: { ... &quot;build&quot;: &quot;node --max_old_space_size=8096 scripts/build.js&quot;, }, ","keywords":""},{"title":"NestJS 오류 TypeError 0 , cookie_parser_1.default is not a function","type":0,"sectionRef":"#","url":"/blog/post/NestJS-오류-TypeError-0-cookieparser1.default-is-not-a-function","content":"아래와 같은 오류를 만났다. [Nest] 21927 - 2021. 11. 09. 오후 3:38:42 LOG [InstanceLoader] TypeOrmCoreModule dependencies initialized +47ms [Nest] 21927 - 2021. 11. 09. 오후 3:38:42 LOG [InstanceLoader] TypeOrmModule dependencies initialized +1ms [Nest] 21927 - 2021. 11. 09. 오후 3:38:42 LOG [InstanceLoader] AuthModule dependencies initialized +0ms [Nest] 21927 - 2021. 11. 09. 오후 3:38:42 LOG [InstanceLoader] UsersModule dependencies initialized +1ms [Nest] 21927 - 2021. 11. 09. 오후 3:38:42 LOG [InstanceLoader] AppModule dependencies initialized +0ms /Users/xii/src/main.ts:28 app.use(cookieParser()); ^ TypeError: (0 , cookie_parser_1.default) is not a function at bootstrap (/Users/im-uchan/Desktop/~~~~~/src/main.ts:28:23) at processTicksAndRejections (node:internal/process/task_queues:96:5) import cookieParser from 'cookie-parser'; //........... app.use(cookieParser()); import때문에 발생한 문제이다. tsconfig.json에 들어가 &quot;esModuleInterop&quot;: true를 추가해주자. { &quot;compilerOptions&quot;: { &quot;module&quot;: &quot;commonjs&quot;, &quot;declaration&quot;: true, &quot;removeComments&quot;: true, &quot;emitDecoratorMetadata&quot;: true, &quot;experimentalDecorators&quot;: true, &quot;allowSyntheticDefaultImports&quot;: true, &quot;esModuleInterop&quot;: true, // 추가 &quot;target&quot;: &quot;es2017&quot;, &quot;sourceMap&quot;: true, &quot;outDir&quot;: &quot;./dist&quot;, &quot;baseUrl&quot;: &quot;./&quot;, &quot;incremental&quot;: true, &quot;skipLibCheck&quot;: true, &quot;strictNullChecks&quot;: false, &quot;noImplicitAny&quot;: false, &quot;strictBindCallApply&quot;: false, &quot;forceConsistentCasingInFileNames&quot;: false, &quot;noFallthroughCasesInSwitch&quot;: false } } ","keywords":""},{"title":"npm WARN @typescript-eslint/eslint-plugin@1.6.0 requires .... 경고발생","type":0,"sectionRef":"#","url":"/blog/post/npm-WARN-typescript-eslint-eslint-plugin-1-6-0-requires-경고발생","content":"","keywords":""},{"title":"증상​","type":1,"pageTitle":"npm WARN @typescript-eslint/eslint-plugin@1.6.0 requires .... 경고발생","url":"/blog/post/npm-WARN-typescript-eslint-eslint-plugin-1-6-0-requires-경고발생#증상","content":"npm install 간 경고창 생성 "},{"title":"해결방안​","type":1,"pageTitle":"npm WARN @typescript-eslint/eslint-plugin@1.6.0 requires .... 경고발생","url":"/blog/post/npm-WARN-typescript-eslint-eslint-plugin-1-6-0-requires-경고발생#해결방안","content":"$ rm -rf package-lock.json $ npm install --save typescript $ npm install   참고 : https://stackoverflow.com/questions/56907286/npm-warn-typescript-eslint-eslint-plugin1-6-0-requires-a-peer-of-typescript "},{"title":"nvm 설치 (node version manager)","type":0,"sectionRef":"#","url":"/blog/post/nvm-설치-node-version-manager","content":"","keywords":""},{"title":"개요​","type":1,"pageTitle":"nvm 설치 (node version manager)","url":"/blog/post/nvm-설치-node-version-manager#개요","content":"node.js 을 사용하다 보면 빠르게 버젼업이 되고 있으며 그로 인하여 패키지는 node 버젼이 안맞아서 충돌이 발생하기도 한다. nvm 을 이용하면 손쉽게 node.js 버젼관리가 되며 npm global 설치시 별도의 관리자 권한을 안줘도 된다. "},{"title":"설치​","type":1,"pageTitle":"nvm 설치 (node version manager)","url":"/blog/post/nvm-설치-node-version-manager#설치","content":"설치는 단순하다. install script 다운 및 설치 $ wget -qO- https://raw.githubusercontent.com/nvm-sh/nvm/v0.34.0/install.sh | bash 자동으로 ~/.bash_profile, ~/.zshrc, ~/.profile, ~/.bashrc 에 nvm 명령어가 추가 되겠지만 만약 안될수도 있다. 그럴경우에는 직접 스크립트를 수정한다. ~/.zshrc 수정 export NVM_DIR=~/.nvm [ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; . &quot;$NVM_DIR/nvm.sh&quot;  "},{"title":"실행​","type":1,"pageTitle":"nvm 설치 (node version manager)","url":"/blog/post/nvm-설치-node-version-manager#실행","content":"node.js 을 설치 하고자 할때 $ nvm install node  혹은 $ nvm install 6.14.4  "},{"title":"제거​","type":1,"pageTitle":"nvm 설치 (node version manager)","url":"/blog/post/nvm-설치-node-version-manager#제거","content":"npm uninstall node  "},{"title":"org.apache.ibatis.reflection.ReflectionException: 오류","type":0,"sectionRef":"#","url":"/blog/post/org-apache-ibatis-reflection-ReflectionException-오류","content":"mybatis를 사용해서 쿼리를 실행할 때 주의할 점이 있다. parameterType=&quot;string&quot; 이면서 1개 입력값만 받을 때 if test 문법으로 null 처리를 할 때 오류가 날 수 있다. 오류는 아래와 같다. org.apache.ibatis.reflection.ReflectionException: There is no getter for property named 'name' in 'class java.lang.String' 해결방안 if test 부분에 parameter 이름을 value로 하면 된다. &lt;if test=&quot;value != null and value !=''&quot;&gt; AND a.name = #{value} &lt;/if&gt; parameterType=&quot;hashmap&quot; 을 사용하면 컬럼명 그대로 사용 가능하다. &lt;if test=&quot;name != null and name !=''&quot;&gt; AND a.name = #{name } &lt;/if&gt; ","keywords":""},{"title":"해결책","type":0,"sectionRef":"#","url":"/blog/post/page/9","content":"Traceback (most recent call last): File &quot;/bin/pip&quot;, line 9, in &lt;module&gt; load_entry_point('pip==8.1.1', 'console_scripts', 'pip')() File &quot;/usr/lib/python2.7/site-packages/pip-8.1.1-py2.7.egg/pip/__init__.py&quot;, line 215, in main locale.setlocale(locale.LC_ALL, '') File &quot;/usr/lib64/python2.7/locale.py&quot;, line 547, in setlocale return _setlocale(category, locale) locale.Error: unsupported locale setting 해결책 export LC_ALL=&quot;en_US.UTF-8&quot; export LC_CTYPE=&quot;en_US.UTF-8&quot; ","keywords":""},{"title":"pip - locale.Error: unsupported locale setting","type":0,"sectionRef":"#","url":"/blog/post/pip-locale-Error-unsupported-locale-setting","content":"","keywords":""},{"title":"상황​","type":1,"pageTitle":"pip - locale.Error: unsupported locale setting","url":"/blog/post/pip-locale-Error-unsupported-locale-setting#상황","content":"sudo pip install ansible 입력시 다음과 같은 에러발생 vagrant@vagrant:~$ sudo pip install ansible Traceback (most recent call last): File &quot;/usr/bin/pip&quot;, line 11, in &lt;module&gt; sys.exit(main()) File &quot;/usr/lib/python2.7/dist-packages/pip/__init__.py&quot;, line 215, in main locale.setlocale(locale.LC_ALL, '') File &quot;/usr/lib/python2.7/locale.py&quot;, line 581, in setlocale return _setlocale(category, locale) locale.Error: unsupported locale setting  "},{"title":"해결​","type":1,"pageTitle":"pip - locale.Error: unsupported locale setting","url":"/blog/post/pip-locale-Error-unsupported-locale-setting#해결","content":"다음 명령어를 입력하여 해결 vagrant@vagrant:~$ export LC_ALL=&quot;en_US.UTF-8&quot; vagrant@vagrant:~$ export LC_CTYPE=&quot;en_US.UTF-8&quot; vagrant@vagrant:~$ sudo dpkg-reconfigure locales  다음 창이 나오면 &quot;en_US.UTF-8 UTF-8&quot; 이 체크되어 있는지 확인후에 탭키로 OK 항목으로 이동후 엔터  "},{"title":"PlayOnLinux is unable to find 32bits OpenGL libraries","type":0,"sectionRef":"#","url":"/blog/post/PlayOnLinux-is-unable-to-find-32bits-OpenGL-libraries","content":"","keywords":""},{"title":"증상​","type":1,"pageTitle":"PlayOnLinux is unable to find 32bits OpenGL libraries","url":"/blog/post/PlayOnLinux-is-unable-to-find-32bits-OpenGL-libraries#증상","content":"PlayOnLinux 실행시 다음과 같은 메세지가 출력이 된다. {% asset_img &quot;error.png&quot; &quot;spaced title&quot; %} "},{"title":"원인​","type":1,"pageTitle":"PlayOnLinux is unable to find 32bits OpenGL libraries","url":"/blog/post/PlayOnLinux-is-unable-to-find-32bits-OpenGL-libraries#원인","content":"sudo apt autoremove 을 실행하여 32bits OpenGL libraries 가 삭제 (의존성문제) "},{"title":"해결방안​","type":1,"pageTitle":"PlayOnLinux is unable to find 32bits OpenGL libraries","url":"/blog/post/PlayOnLinux-is-unable-to-find-32bits-OpenGL-libraries#해결방안","content":"저장소 추가 dpkg --add-architecture i386 기존에 설치된 라이브러리 제거 sudo apt-get purge fglrx* xorg.conf 제거 sudo rm /etc/X11/xorg.conf 패키지 재설치 sudo apt-get install --reinstall xserver-xorg-core libgl1-mesa-glx:i386 libgl1-mesa-dri:i386 libgl1-mesa-glx:amd64 libgl1-mesa-dri:amd64 xorg 재설정 sudo dpkg-reconfigure xserver-xorg 재부팅 "},{"title":"원인","type":0,"sectionRef":"#","url":"/blog/post/page/8","content":"npm run build 후 다음과 같은 에러 메세지 발생 FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory 원인 이는 기본 Node.js 가용 메모리가 빌드하기에 충분하지 않아 발생하는 오류 조치 package.json 내부의 build 항목을 다음과 같이 수정 &quot;scripts&quot;: { ... &quot;build&quot;: &quot;node --max_old_space_size=8096 scripts/build.js&quot;, }, ","keywords":""},{"title":"react.js + spring boot","type":0,"sectionRef":"#","url":"/blog/post/react-js-spring-boot","content":"Spring 프로젝트 생성프로젝트 내부에 별도의 폴더생성npm install -g create-react-appcreate-react-app &lt;APP NAME&gt; --use-npmnpm run eject (webpack 설정 필요시)package.json 내부에 다음항목추가 &quot;proxy&quot;: &quot;http://localhost:8080&quot;, config / paths.js 내부에 추가 templatesPath: resolveApp('../src/main/resources/templates'), appBuild: resolveApp('../src/main/resources/static'), script / build.js 내부에 &quot;measureFileSizesBeforeBuild&quot; 함수 then 구문안 마직막 부분에 추가 fs.rename(paths.appBuild + '/index.html', paths.templatesPath + '/index.html', function (err) { console.log('index.html move') }) 평소에는 webpack dev server 이용하다가 배포시 npm build 후에 배포","keywords":""},{"title":"react 에서 package.json 내의 버젼정보 가져오기","type":0,"sectionRef":"#","url":"/blog/post/react-에서-package-json-내의-버젼정보-가져오기","content":"루트 폴더에 .env 파일 생성후에 다음항목 입력 REACT_APP_VERSION=$npm_package_version REACT_APP_NAME=$npm_package_name react app 재시작 후에 임의의 파일에 넣고 테스트 console.log(`${process.env.REACT_APP_NAME} ${process.env.REACT_APP_VERSION}`) ","keywords":""},{"title":"react proxy server 설정","type":0,"sectionRef":"#","url":"/blog/post/react-proxy-server-설정","content":"","keywords":""},{"title":"개요​","type":1,"pageTitle":"react proxy server 설정","url":"/blog/post/react-proxy-server-설정#개요","content":"npm devserver 에서 proxy 설정을 할경우 package.json 파일에 &quot;proxy&quot;: &quot;http://localhost:&lt;PORT-GOES-HERE&gt;” 항목을 추가해서 설정을 했었다.   문제는 기본적인 주소만 설정이 되어 있어서 웹소켓 같은 세부설정이 안되는 문제가 있었다.  CRA (Create-react-app) v2 부터는 src/setupProxy.js 파일을 통하여 proxy server 을 커스터마이징 을 할수있게 되었다.   참고 @velopert Create-react-app V2 릴리즈! 무슨 변경 사항이 있을까? "},{"title":"설치​","type":1,"pageTitle":"react proxy server 설정","url":"/blog/post/react-proxy-server-설정#설치","content":"기존 프로젝트에 http-proxy-middleware 추가하기 $ npm install --save-dev http-proxy-middleware package.json 에 &quot;proxy&quot;: &quot;http://localhost:&lt;PORT-GOES-HERE&gt;” 항목 제거 src/setupProxy.js 파일 생성 및 수정 const proxy = require('http-proxy-middleware'); // create-react-app proxy 설정  // 190524 je.kim dev server 에서 proxy 사용시 세션 유지 불가 -&gt; 강제로 세션키를 맞춤 var cookie; // proxy 로 request 시 이벤트 function relayRequestHeaders(proxyReq, req) { console.debug('💥💥💥 request 💥💥💥'); Object.keys(req.headers).forEach(function (key) { console.debug(${key} : ${req.headers[key]}); }); if (cookie) { proxyReq.setHeader('cookie', cookie); } }; // proxy 로 Response 시 이벤트 function relayResponseHeaders(proxyRes, req, res) { console.debug('💥💥💥 response 💥💥💥'); Object.keys(proxyRes.headers).forEach(function (key) { console.debug(${key} : ${proxyRes.headers[key]}); }); var proxyCookie = proxyRes.headers[&quot;set-cookie&quot;]; if (proxyCookie) { cookie = proxyCookie; } }; module.exports = function(app) { // ... // 프록시 설정 app.use( proxy([ '/', ], { // 대상서버 target: 'http://localhost:8080' , secure: false, // disable SSL verification //changeOrigin: true, // for vhosted sites, changes host header to match to target's host ws : true, // websock on onProxyReq: relayRequestHeaders, onProxyRes: relayResponseHeaders, // ajax 혹은 통신이 있을경우에 로그에 표시 // logLevel: 'debug' } ) ); };   "},{"title":"react 외부 javascript 라이브러리 불려오기 (kakao map javascript)","type":0,"sectionRef":"#","url":"/blog/post/react-외부-javascript-라이브러리-불려오기-kakao-map-javascript","content":"","keywords":""},{"title":"개요​","type":1,"pageTitle":"react 외부 javascript 라이브러리 불려오기 (kakao map javascript)","url":"/blog/post/react-외부-javascript-라이브러리-불려오기-kakao-map-javascript#개요","content":"react 을 이용하다 보면 대부분의 라이브러리들은 npm 을 이용하여 손쉽게 이용이 가능하다. 하지만 cdn 혹은 kakao map 과 같은 api 을 통한 javascript 라이브러리 은 인증문제도 있어서 가져오기 애매할수도 있다.  그렇다고 해서 방법이 없는것은 아니다. scriptjs 을 통하여 외부 라이브러리를 통하여 가져올수는 있다. "},{"title":"설치​","type":1,"pageTitle":"react 외부 javascript 라이브러리 불려오기 (kakao map javascript)","url":"/blog/post/react-외부-javascript-라이브러리-불려오기-kakao-map-javascript#설치","content":"$ npm i scriptjs  "},{"title":"예시​","type":1,"pageTitle":"react 외부 javascript 라이브러리 불려오기 (kakao map javascript)","url":"/blog/post/react-외부-javascript-라이브러리-불려오기-kakao-map-javascript#예시","content":"import $script from 'scriptjs'; ... const kakao_url = `http://dapi.kakao.com/v2/maps/sdk.js?autoload=false&amp;appkey=${API_KEY}`; $script(kakao_url, () =&gt; { /*global kakao*/ this.kakao = kakao; kakao.maps.load(function () { // v3가 모두 로드된 후, 이 콜백 함수가 실행됩니다. ... }); });  scriptjs 사용시 / global {변수명} / 을 추가하여 컴파일시 에러가 나지 않도록 조치 한다. "},{"title":"react.js 와 연동 (전체 스크립트)​","type":1,"pageTitle":"react 외부 javascript 라이브러리 불려오기 (kakao map javascript)","url":"/blog/post/react-외부-javascript-라이브러리-불려오기-kakao-map-javascript#reactjs-와-연동-전체-스크립트","content":"import React, { Component , createRef} from 'react' import $script from 'scriptjs'; import * as mapApi from '../../services/maps' export default class KakaoMap extends Component { constructor(props){ super(props); this.appRef = createRef(); } state = { API_KEY: null, setLoading: true, } componentDidMount() { this.getApiKey().then(API_KEY =&gt; { this.setState({ API_KEY, setLoading: false, }); this.setKakaoMap(); }); } componentDidUpdate(){ if (this.customOverlay){ this.customOverlay.setMap(null); this.customOverlay = null; } this.setCenter(); this.setOverLay(); } /** * 서버에 api 키 가져오기 */ getApiKey = async () =&gt; { const res = await mapApi.getApiKey(); return res.data; } /** * 지도 가운데 */ setCenter = ()=&gt;{ var LatLng = this.props.LatLng; let { x, y } = LatLng; if(typeof this.kakao === 'undefined' || this.kakao == null) return false; // 이동할 위도 경도 위치를 생성합니다 var moveLatLon = new this.kakao.maps.LatLng(y, x); // 지도 중심을 이동 시킵니다 this.map.setCenter(moveLatLon); } /** * 오버레이 생성 */ setOverLay = () =&gt; { var LatLng = this.props.LatLng; let { x, y , data} = LatLng; // console.log(data); if (typeof this.kakao === 'undefined' || this.kakao == null || !data) return false; // 커스텀 오버레이에 표시할 내용입니다 // HTML 문자열 또는 Dom Element 입니다 var content = ` &lt;div id=&quot;overlay-area&quot; class=&quot;arrow_box&quot;&gt; &lt;ul&gt; &lt;li&gt;${data.address_name}&lt;/li&gt; &lt;li&gt;${data.category_name}&lt;/li&gt; &lt;li&gt;${data.phone}&lt;/li&gt; &lt;li&gt;${data.place_name}&lt;/li&gt; &lt;li&gt;${data.place_url}&lt;/li&gt; &lt;ul&gt; &lt;/div&gt; `; // 커스텀 오버레이가 표시될 위치입니다 var position = new kakao.maps.LatLng(y, x); // 커스텀 오버레이를 생성합니다 this.customOverlay = new kakao.maps.CustomOverlay({ position: position, content: content }); // 커스텀 오버레이를 지도에 표시합니다 this.customOverlay.setMap(this.map); } /** * 카카오 맵 생성 */ setKakaoMap = ()=&gt;{ var {x , y} = this.props.LatLng; const {API_KEY} = this.state; const kakao_url = `http://dapi.kakao.com/v2/maps/sdk.js?autoload=false&amp;appkey=${API_KEY}`; var that = this; $script(kakao_url, () =&gt; { //console.log(); // golobal setting /*global kakao*/ this.kakao = kakao; kakao.maps.load(function () { // v3가 모두 로드된 후, 이 콜백 함수가 실행됩니다. that.kakao = kakao; that.map = new that.kakao.maps.Map(that.appRef.current, { center: new that.kakao.maps.LatLng(y, x), // 지도의 중심좌표 level: 3 // 지도의 확대 레벨 }); }); }); } render() { const { setLoading } = this.state return ( (setLoading)? &lt;div&gt;Looooooooooooading....&lt;/div&gt; : &lt;div style={{ 'height': '850px' }} ref={this.appRef} /&gt; ) } }  "},{"title":"revealjs 에서 pdf 출력","type":0,"sectionRef":"#","url":"/blog/post/revealjs-에서-pdf-출력","content":"revealjs 페이지 에서 다음 주소를 추가 https://100milliongold.github.io/presentation/reveal.js.html?print-pdf https://100milliongold.github.io/presentation/reveal.js.html?print-pdf","keywords":""},{"title":"setState() 제어","type":0,"sectionRef":"#","url":"/blog/post/setState-제어","content":"react.js 을 이용하다 보면 상태변경을 위하여 setState() 을 자주 사용하게 된다. 하지만 setState() 메서드는 비동기 형식이기 때문에 순서를 제어하기 힘들다. 만약 setState() 을 사용후에 별도의 메서드를 실행할려도 할때 다음처럼 이용하면 된다. 예시 this.setState({ setLoading: true, }, ()=&gt;{ setTimeout(this.setState({ setLoading: false, }), 1000); }) ","keywords":""},{"title":"Spring Boot - jar로 서비스 등록하기","type":0,"sectionRef":"#","url":"/blog/post/Spring-Boot-jar로-서비스-등록하기","content":"참고: Spring Boot - jar로 Deploy(배포)하기 [허원철의 개발 블로그] 서비스 등록 서비스 등록 sudo vi /etc/init.d/myApp #!/bin/sh SERVICE_NAME=myApp PATH_TO_JAR=/usr/local/myApp.jar PID_PATH_NAME=/tmp/myApp-pid case $1 in start) echo &quot;Starting $SERVICE_NAME ...&quot; if [ ! -f $PID_PATH_NAME ]; then nohup java -jar $PATH_TO_JAR /tmp 2&gt;&gt; /dev/null &gt;&gt; /dev/null &amp; echo $! &gt; $PID_PATH_NAME echo &quot;$SERVICE_NAME started ...&quot; else echo &quot;$SERVICE_NAME is already running ...&quot; fi ;; stop) if [ -f $PID_PATH_NAME ]; then PID=$(cat $PID_PATH_NAME); echo &quot;$SERVICE_NAME stoping ...&quot; kill $PID; echo &quot;$SERVICE_NAME stopped ...&quot; rm $PID_PATH_NAME else echo &quot;$SERVICE_NAME is not running ...&quot; fi ;; restart) if [ -f $PID_PATH_NAME ]; then PID=$(cat $PID_PATH_NAME); echo &quot;$SERVICE_NAME stopping ...&quot;; kill $PID; echo &quot;$SERVICE_NAME stopped ...&quot;; rm $PID_PATH_NAME echo &quot;$SERVICE_NAME starting ...&quot; nohup java $JAVA_OPTS -jar $PATH_TO_JAR /tmp 2&gt;&gt; /dev/null &gt;&gt; /dev/null &amp; echo $! &gt; $PID_PATH_NAME echo &quot;$SERVICE_NAME started ...&quot; else echo &quot;$SERVICE_NAME is not running ...&quot; fi ;; esac 서비스 실행 service myapp start | stop | restart * spring boot 1.3부터는 별도의 스크립트 없이도 간단한 설정으로 자체적으로 실행이 가능함 Maven &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;executable&gt;true&lt;/executable&gt; &lt;/configuration&gt; &lt;/plugin&gt; Gradle bootJar { launchScript() } 서비스 등록 sudo ln -s /var/myapp/myapp.jar /etc/init.d/myapp 서비스 실행 service myapp start 참고 : Installing Spring Boot Applications","keywords":""},{"title":"spring boot 을 influxDB 와 연동하기","type":0,"sectionRef":"#","url":"/blog/post/spring-boot-을-influxDB-와-연동하기","content":"spring boot : 1.5.10.RELEASE 이상jdk : 1.8 이상influxDB : 2.7 influxDB 설치 docker 에서 설치 docker pull influxdb docker run --name influxdb-test -p8086:8086 -d influxdb 샘플 데이터 생성하기 influxDB 접속 docker exec -it influxdb-test /bin/bash influx -precision rfc3339 Connected to http://localhost:8086 version 1.4.x InfluxDB shell 1.4.x 데이터베이스 생성 CREATE DATABASE NOAA_water_database exit 샘플 데이터 다운받기 curl https://s3.amazonaws.com/noaa.water-database/NOAA_data.txt -o NOAA_data.txt 데이터를 influxDB 에 import 하기 influx -import -path=NOAA_data.txt -precision=s -database=NOAA_water_database 테스트 하기 influx -precision rfc3339 use NOAA_water_database SELECT * FROM h2o_feet LIMIT 5 spring boot 에 연동하기 spring boot 프로젝트 생성pom.xml 설정 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;influxDB-Test&lt;/artifactId&gt; &lt;version&gt;0.1.0&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.5.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.influxdb&lt;/groupId&gt; &lt;artifactId&gt;influxdb-java&lt;/artifactId&gt; &lt;version&gt;2.14&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.miwurster&lt;/groupId&gt; &lt;artifactId&gt;spring-data-influxdb&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; spring configure 설정 (InfluxDBConfiguration.java) @Configuration @EnableConfigurationProperties(InfluxDBProperties.class) public class InfluxDBConfiguration { @Bean public InfluxDBConnectionFactory connectionFactory(final InfluxDBProperties properties) { return new InfluxDBConnectionFactory(properties); } @Bean public InfluxDBTemplate&lt;Point&gt; influxDBTemplate(final InfluxDBConnectionFactory connectionFactory) { /* * You can use your own 'PointCollectionConverter' implementation, e.g. in case * you want to use your own custom measurement object. */ return new InfluxDBTemplate&lt;&gt;(connectionFactory, new PointConverter()); } @Bean public DefaultInfluxDBTemplate defaultTemplate(final InfluxDBConnectionFactory connectionFactory) { /* * If you are just dealing with Point objects from 'influxdb-java' you could * also use an instance of class DefaultInfluxDBTemplate. */ return new DefaultInfluxDBTemplate(connectionFactory); } } application.properties 설정 spring.influxdb.url=http://localhost:8086 spring.influxdb.database=NOAA_water_database spring.influxdb.username=~ spring.influxdb.retentionPolicy=autogen DTO 생성(H2oFeet.java) @Measurement(name = &quot;h2o_feet&quot;) public class H2oFeet { @Column(name = &quot;water_level&quot;) private Double water_level; @Column(name = &quot;level description&quot;) private String level_description; @Column(name = &quot;location&quot;) private String location; @Column(name = &quot;time&quot;) private Instant time; public Double getWater_level() { return water_level; } public void setWater_level(Double water_level) { this.water_level = water_level; } public String getLevel_description() { return level_description; } public void setLevel_description(String level_description) { this.level_description = level_description; } public String getLocation() { return location; } public void setLocation(String location) { this.location = location; } public Instant getTime() { return time; } public void setTime(Instant time) { this.time = time; } } controller 생성 (MainController.java) @Controller @RequestMapping(path=&quot;/api/v1/NOAAWater&quot;) public class MainController { @Autowired private MainService mainService; @GetMapping(path=&quot;/h2os&quot;) public @ResponseBody List&lt;H2oFeet&gt; h2o_list() { return mainService.h2o_list(); } } service 생성 (MainService.java) @Service public class MainService { @Autowired private InfluxDBTemplate&lt;Point&gt; influxDBTemplate; public List&lt;H2oFeet&gt; h2o_list() { Query query = QueryBuilder.newQuery(&quot;SELECT * FROM h2o_feet LIMIT 1000&quot;) .forDatabase(&quot;NOAA_water_database&quot;) .create(); QueryResult queryResult = influxDBTemplate.query(query); InfluxDBResultMapper resultMapper = new InfluxDBResultMapper(); // thread-safe - can be reused return resultMapper.toPOJO(queryResult, H2oFeet.class); } } Test curl $curl -X GET http://localhost:8080/api/v1/NOAAWater/h2os github : https://github.com/gadian88/influxDB-Test","keywords":""},{"title":"ssh port forwording","type":0,"sectionRef":"#","url":"/blog/post/ssh-port-forwording","content":"local ssh -L 80:intra.example.com:80 gw.example.com remote ssh -R 8080:localhost:80 public.example.com 이를 이용하여 ssh 을 통하여 port 포워딩이 가능해진다.","keywords":""},{"title":"Spring Security 에서 로그인 팝업창 안나오게 설정","type":0,"sectionRef":"#","url":"/blog/post/Spring-Security-에서-로그인-팝업창-안나오게-설정","content":"Spring Security 을 사용하면 가끔식 로그인 팝업창이 나오는데 출력을 헤제할수가 있다. 중요한건 NoPopupBasicAuthenticationEntryPoint.java 에서 제어하는 것이다. WebSecurityConfig.java package com.jeaeok.myproject.testApp.configs; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import org.springframework.security.crypto.password.PasswordEncoder; @Configuration /** 스프링 시큐리티 설정 @author atcis */ public class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private AuthProvider authProvider; @Bean public PasswordEncoder getEncoder() { return new BCryptPasswordEncoder(); } @Override /** * 스크링 시큐리트를 통하여 접근페이지 설정 */ protected void configure(HttpSecurity http) throws Exception{ http .logout() .logoutUrl(&quot;/api/logout&quot;) .and() .csrf() .disable() .authorizeRequests() .antMatchers( &quot;/&quot;, &quot;/api/v1/user/join&quot;, &quot;/static/**&quot; ).permitAll() .anyRequest().authenticated() .and() .headers().frameOptions().sameOrigin() .and() .httpBasic() .authenticationEntryPoint(new NoPopupBasicAuthenticationEntryPoint()) ; http.authenticationProvider(authProvider); } } NoPopupBasicAuthenticationEntryPoint.java package com.jeaeok.myproject.testApp.configs; import java.io.IOException; import javax.servlet.ServletException; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.security.core.AuthenticationException; import org.springframework.security.web.AuthenticationEntryPoint; public class NoPopupBasicAuthenticationEntryPoint implements AuthenticationEntryPoint { @Override public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException { response.sendError(HttpServletResponse.SC_UNAUTHORIZED, authException.getMessage()); } } ","keywords":""},{"title":"Disable SELinux","type":0,"sectionRef":"#","url":"/blog/post/tags/cent-os","content":"SELinux(Security Enhanced Linux)는 관리자와 사용자가 액세스 제어에 대한 제어력을 높일 수 있는 Linux 커널 보안 모듈이다. SELinux 정책 규칙에 따라 접속할 수 있다. SELinux 정책 규칙은 프로세스와 사용자가 파일과 상호 작용하는 방법뿐만 아니라 프로세스와 사용자가 서로 상호작용하는 방법을 지정한다. 파일을 여는 프로세스처럼 액세스를 특별히 허용하는 SELinux 정책 규칙이 없는 경우, 액세스가 거부된다. Disable SELinux SELinux mode 변경 sudo setenforce 0 /etc/selinux/config 변경 SELINUX 항목을 disabled로 변경 # This file controls the state of SELinux on the system. # SELINUX= can take one of these three values: # enforcing - SELinux security policy is enforced. # permissive - SELinux prints warnings instead of enforcing. # disabled - No SELinux policy is loaded. SELINUX=disabled # SELINUXTYPE= can take one of these two values: # targeted - Targeted processes are protected, # mls - Multi Level Security protection. SELINUXTYPE=targeted Server reboot","keywords":""},{"title":"원인","type":0,"sectionRef":"#","url":"/blog/post/tags/centos","content":"Centos SELINUX 설정을 비활성화 후에 재부팅시 부팅화면에서 멈추는 현상 원인 /etc/selinux/config 파일에 SELINUXTYPE=disabled 설정되어 있음 해결방안 grub 화면에서 부팅 운영체제를 선택후 e 키를 눌러서 kernel 부팅 옵션으로 들어가서 linux16 / vmlinu 가 있는 부분에 selinux = 0 추가할것 linux16 / vmlinu - 생략 - selinux = 0 완료후에 Ctrl + x 키로 리부트","keywords":""},{"title":"원인","type":0,"sectionRef":"#","url":"/blog/post/tags/eclipse","content":"이클립스를 elementary OS 에서 실행하고자 하면 이클립스 실행중으로 나오고 작동이 안된다. 원인 elementary OS 에서 쓰이는 GTK3 와 이클립스에 사용중인 GTK2이 충돌나서 그런것 같다 해결 eclipse.ini 파일에 다음을 추가한다 --launcher.GTK_version ","keywords":""},{"title":"원인","type":0,"sectionRef":"#","url":"/blog/post/tags/elementary-os","content":"이클립스를 elementary OS 에서 실행하고자 하면 이클립스 실행중으로 나오고 작동이 안된다. 원인 elementary OS 에서 쓰이는 GTK3 와 이클립스에 사용중인 GTK2이 충돌나서 그런것 같다 해결 eclipse.ini 파일에 다음을 추가한다 --launcher.GTK_version ","keywords":""},{"title":"yarn cache 저장위치 확인하기","type":0,"sectionRef":"#","url":"/blog/post/tags/hadoop-yarn","content":"가끔 맵리듀스 작업을 하다보면, yarn 에 캐쉬가 많이 남아 있어서 충돌이 발생하는 경우가 발생한다. 초기화을 하자 yarn cache 저장위치 확인하기 yarn-site.xml 파일에 yarn.nodemanager.local-dirs 위치 확인하기 &lt;property&gt; &lt;name&gt;yarn.nodemanager.local-dirs&lt;/name&gt; &lt;value&gt;/hadoop/yarn/local&lt;/value&gt; &lt;/property&gt; 해당 폴더의 내용 지우기 [yarn@node2 ~]$ cd /hadoop/yarn/local/ [yarn@node2 local]$ ls filecache nmPrivate spark_shuffle usercache [yarn@node2 local]$ rm -rf filecache/ usercache/ yarn 재시작","keywords":""},{"title":"influxDB 설치","type":0,"sectionRef":"#","url":"/blog/post/tags/influx-db","content":"spring boot : 1.5.10.RELEASE 이상jdk : 1.8 이상influxDB : 2.7 influxDB 설치 docker 에서 설치 docker pull influxdb docker run --name influxdb-test -p8086:8086 -d influxdb 샘플 데이터 생성하기 influxDB 접속 docker exec -it influxdb-test /bin/bash influx -precision rfc3339 Connected to http://localhost:8086 version 1.4.x InfluxDB shell 1.4.x 데이터베이스 생성 CREATE DATABASE NOAA_water_database exit 샘플 데이터 다운받기 curl https://s3.amazonaws.com/noaa.water-database/NOAA_data.txt -o NOAA_data.txt 데이터를 influxDB 에 import 하기 influx -import -path=NOAA_data.txt -precision=s -database=NOAA_water_database 테스트 하기 influx -precision rfc3339 use NOAA_water_database SELECT * FROM h2o_feet LIMIT 5 spring boot 에 연동하기 spring boot 프로젝트 생성pom.xml 설정 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;influxDB-Test&lt;/artifactId&gt; &lt;version&gt;0.1.0&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.5.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.influxdb&lt;/groupId&gt; &lt;artifactId&gt;influxdb-java&lt;/artifactId&gt; &lt;version&gt;2.14&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.miwurster&lt;/groupId&gt; &lt;artifactId&gt;spring-data-influxdb&lt;/artifactId&gt; &lt;version&gt;1.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;/project&gt; spring configure 설정 (InfluxDBConfiguration.java) @Configuration @EnableConfigurationProperties(InfluxDBProperties.class) public class InfluxDBConfiguration { @Bean public InfluxDBConnectionFactory connectionFactory(final InfluxDBProperties properties) { return new InfluxDBConnectionFactory(properties); } @Bean public InfluxDBTemplate&lt;Point&gt; influxDBTemplate(final InfluxDBConnectionFactory connectionFactory) { /* * You can use your own 'PointCollectionConverter' implementation, e.g. in case * you want to use your own custom measurement object. */ return new InfluxDBTemplate&lt;&gt;(connectionFactory, new PointConverter()); } @Bean public DefaultInfluxDBTemplate defaultTemplate(final InfluxDBConnectionFactory connectionFactory) { /* * If you are just dealing with Point objects from 'influxdb-java' you could * also use an instance of class DefaultInfluxDBTemplate. */ return new DefaultInfluxDBTemplate(connectionFactory); } } application.properties 설정 spring.influxdb.url=http://localhost:8086 spring.influxdb.database=NOAA_water_database spring.influxdb.username=~ spring.influxdb.retentionPolicy=autogen DTO 생성(H2oFeet.java) @Measurement(name = &quot;h2o_feet&quot;) public class H2oFeet { @Column(name = &quot;water_level&quot;) private Double water_level; @Column(name = &quot;level description&quot;) private String level_description; @Column(name = &quot;location&quot;) private String location; @Column(name = &quot;time&quot;) private Instant time; public Double getWater_level() { return water_level; } public void setWater_level(Double water_level) { this.water_level = water_level; } public String getLevel_description() { return level_description; } public void setLevel_description(String level_description) { this.level_description = level_description; } public String getLocation() { return location; } public void setLocation(String location) { this.location = location; } public Instant getTime() { return time; } public void setTime(Instant time) { this.time = time; } } controller 생성 (MainController.java) @Controller @RequestMapping(path=&quot;/api/v1/NOAAWater&quot;) public class MainController { @Autowired private MainService mainService; @GetMapping(path=&quot;/h2os&quot;) public @ResponseBody List&lt;H2oFeet&gt; h2o_list() { return mainService.h2o_list(); } } service 생성 (MainService.java) @Service public class MainService { @Autowired private InfluxDBTemplate&lt;Point&gt; influxDBTemplate; public List&lt;H2oFeet&gt; h2o_list() { Query query = QueryBuilder.newQuery(&quot;SELECT * FROM h2o_feet LIMIT 1000&quot;) .forDatabase(&quot;NOAA_water_database&quot;) .create(); QueryResult queryResult = influxDBTemplate.query(query); InfluxDBResultMapper resultMapper = new InfluxDBResultMapper(); // thread-safe - can be reused return resultMapper.toPOJO(queryResult, H2oFeet.class); } } Test curl $curl -X GET http://localhost:8080/api/v1/NOAAWater/h2os github : https://github.com/gadian88/influxDB-Test","keywords":""},{"title":"원인","type":0,"sectionRef":"#","url":"/blog/post/tags/java-script","content":"npm run build 후 다음과 같은 에러 메세지 발생 FATAL ERROR: CALL_AND_RETRY_LAST Allocation failed - JavaScript heap out of memory 원인 이는 기본 Node.js 가용 메모리가 빌드하기에 충분하지 않아 발생하는 오류 조치 package.json 내부의 build 항목을 다음과 같이 수정 &quot;scripts&quot;: { ... &quot;build&quot;: &quot;node --max_old_space_size=8096 scripts/build.js&quot;, }, ","keywords":""},{"title":"원인","type":0,"sectionRef":"#","url":"/blog/post/tags/linix","content":"Centos SELINUX 설정을 비활성화 후에 재부팅시 부팅화면에서 멈추는 현상 원인 /etc/selinux/config 파일에 SELINUXTYPE=disabled 설정되어 있음 해결방안 grub 화면에서 부팅 운영체제를 선택후 e 키를 눌러서 kernel 부팅 옵션으로 들어가서 linux16 / vmlinu 가 있는 부분에 selinux = 0 추가할것 linux16 / vmlinu - 생략 - selinux = 0 완료후에 Ctrl + x 키로 리부트","keywords":""},{"title":"해결방안","type":0,"sectionRef":"#","url":"/blog/post/tags/mybatis","content":"mybatis를 사용해서 쿼리를 실행할 때 주의할 점이 있다. parameterType=&quot;string&quot; 이면서 1개 입력값만 받을 때 if test 문법으로 null 처리를 할 때 오류가 날 수 있다. 오류는 아래와 같다. org.apache.ibatis.reflection.ReflectionException: There is no getter for property named 'name' in 'class java.lang.String' 해결방안 if test 부분에 parameter 이름을 value로 하면 된다. &lt;if test=&quot;value != null and value !=''&quot;&gt; AND a.name = #{value} &lt;/if&gt; parameterType=&quot;hashmap&quot; 을 사용하면 컬럼명 그대로 사용 가능하다. &lt;if test=&quot;name != null and name !=''&quot;&gt; AND a.name = #{name } &lt;/if&gt; ","keywords":""},{"title":"Disable SELinux","type":0,"sectionRef":"#","url":"/blog/post/tags/se-linux","content":"SELinux(Security Enhanced Linux)는 관리자와 사용자가 액세스 제어에 대한 제어력을 높일 수 있는 Linux 커널 보안 모듈이다. SELinux 정책 규칙에 따라 접속할 수 있다. SELinux 정책 규칙은 프로세스와 사용자가 파일과 상호 작용하는 방법뿐만 아니라 프로세스와 사용자가 서로 상호작용하는 방법을 지정한다. 파일을 여는 프로세스처럼 액세스를 특별히 허용하는 SELinux 정책 규칙이 없는 경우, 액세스가 거부된다. Disable SELinux SELinux mode 변경 sudo setenforce 0 /etc/selinux/config 변경 SELINUX 항목을 disabled로 변경 # This file controls the state of SELinux on the system. # SELINUX= can take one of these three values: # enforcing - SELinux security policy is enforced. # permissive - SELinux prints warnings instead of enforcing. # disabled - No SELinux policy is loaded. SELINUX=disabled # SELINUXTYPE= can take one of these two values: # targeted - Targeted processes are protected, # mls - Multi Level Security protection. SELINUXTYPE=targeted Server reboot","keywords":""},{"title":"설치","type":0,"sectionRef":"#","url":"/blog/post/tags/server/page/2","content":"참고: 아치리눅스 한국사용자 모임 - 한컴뷰어2014 부탁 좀 드려요..최근에 기존에 설치되었던 우분투를 지우고 만자로 리눅스를 설치했다. apt 패키지 매니저 대신 pacman 패키지를 사용하는거 제외하고는 우분투쓰는 느낌이고 업데이트 나오는 시기가 빠르다고 하는데 아직은 모르겠다. 하지만 한컴뷰어를 설치하고자 했지만 유감스럽게도 Fedora 와 Ubuntu 만 제공하고 있어 아치리눅스 기반이 만자로에서는 설치가 제한이 된다. 그러면 한컴뷰어 설치를 포기햐야 하는가? 정답은 그렇지 않다 이다. 다행히 deb 패키지를 arch linux 패키지로 변환이 가능하다. 설치 한컴 뷰어 다운로드deb -&gt; pkg.tar.xz 파일로 변환 debtap hancomoffice-hwpviewer-Ubuntu-amd64.deb 한컴뷰어 설치 sudo pacman -U ./hancomoffice-hwpviewer-9.20.0.1573-1-x86_64.pkg.tar.xz 그런데 webkitgtk 의존성 문제가 발생했다. webkitgtk 을 설치하는데 확인해보니 AUR 로 설치해야 해서 yaourt 로 진행한다. webkitgtk 설치 yaourt -S webkitgtk 설치는 되는거 같은데 .. 소스코드가 많아서 그런지 반나절이 지나도 빌드가 끝나지 않는다. 설치파일을 받아서 진행을 한다. wget https://cdn.repo.archlinuxcn.org/x86_64/webkitgtk-3%3A2.4.11-16-x86_64.pkg.tar.xz sudo pacman -U ./webkitgtk-3_2.4.11-16-x86_64.pkg.tar.xz 다시 3번을 진행하니 설치가 진행이 된다. 그런데 이제는 실행이 안되고 콘솔에서 hwpviewer 을 실행하니 다음에러가 발생했다. hwpviewer: error while loading shared libraries: libicui18n.so.63: cannot open shared object file: No such file or directory 확인해보니 내컴퓨터에서 설치된 icu 패키지 버젼은 64 이고 한컴뷰어에서 요구하는 icu 패키지 버젼이 63인거 같다. 하지만 pacman 에서는 icu 64 로만 설치가된다. AUR 로 설치하자 icu63 설치 yaourt -S icu63 다행히 빌드하는데 오래걸리지는 않았다. 한컴뷰어 실행 hwpviewer 이제야 실행이 된다 {% asset_img &quot;hwpviewer.png&quot; &quot;spaced title&quot; %} 후기 설치하면서 기존의 pacman 도 좋지만 대부분 AUR 을 이용해야만 설치가 진행이 되었다.","keywords":""},{"title":"2. 새로운 호스트에 METRICS_COLLECTOR 설치","type":0,"sectionRef":"#","url":"/blog/post/tags/server/page/3","content":"curl -u admin:admin -H &quot;X-Requested-By:ambari&quot; - i -X DELETE http://192.168.1.191:8080/api/v1/clusters/supercom_test/hosts/node04/host_components/METRICS_COLLECTOR 2. 새로운 호스트에 METRICS_COLLECTOR 설치 curl -u admin:admin -H &quot;X-Requested-By:ambari&quot; -i -X POST http://192.168.1.191:8080/api/v1/clusters/supercom_test/hosts/node02/host_components/METRICS_COLLECTOR ","keywords":""},{"title":"설치","type":0,"sectionRef":"#","url":"/blog/post/tags/server/page/4","content":"","keywords":""},{"title":"설치환경​","type":1,"pageTitle":"설치","url":"/blog/post/tags/server/page/4#설치환경","content":"virtualbox 설치 - 추가 virtualbox 확장설치  Hyper-V 설정 "},{"title":"설치절차​","type":1,"pageTitle":"설치","url":"/blog/post/tags/server/page/4#설치절차","content":"우분투 sudo apt install virtualbox 윈도우즈 Download https://releases.hashicorp.com/vagrant/2.2.2/vagrant_2.2.2_x86_64.msiinstall package 맥 https://releases.hashicorp.com/vagrant/2.2.2/vagrant_2.2.2_x86_64.dmginstall package Vagrantfile Vagrantfile 내용 # -*- mode: ruby -*- # vi: set ft=ruby : # vagrant 버쟌 설정 Vagrant.configure(&quot;2&quot;) do |config| # box 이름 지정 # https://app.vagrantup.com/boxes/search 에서 검색가능 config.vm.box = &quot;CentosBox/Centos7-v7.3-Minimal&quot; # vagrant 가상머신 이름지정 config.vm.define :node01 do |node01| # 호스트이름 지정 node01.vm.hostname = &quot;node01&quot; # 네트워크 설정 (브릿지 네트워크) node01.vm.network :&quot;public_network&quot;, ip: &quot;192.168.1.195&quot;, bridge: &quot;enp6s0&quot; # virtualbox 설정 node01.vm.provider &quot;virtualbox&quot; do |vb| # 메모리 설정 vb.customize [&quot;modifyvm&quot;, :id, &quot;--memory&quot;, 1024*2] vb.customize [&quot;modifyvm&quot;, :id, &quot;--name&quot;, &quot;node01&quot;] # 디스크 설정 # 만약에 파일이 존재하지 않을경우 디스크 파일 생성 if !File.exist?(&quot;mst01.vdi&quot;) vb.customize [&quot;createhd&quot;, &quot;--filename&quot;, &quot;mst01.vdi&quot;, &quot;--size&quot;, 1024*10, &quot;--variant&quot;, &quot;Fixed&quot;] vb.customize [&quot;modifyhd&quot;, &quot;mst01.vdi&quot;, &quot;--type&quot;, &quot;shareable&quot;] end # 해당 파일 병으로 디스크 추가 vb.customize [&quot;storageattach&quot;, :id, &quot;--storagectl&quot;, &quot;SATA&quot;, &quot;--port&quot;, 1, &quot;--device&quot;, 0, &quot;--type&quot;, &quot;hdd&quot;, &quot;--medium&quot;, &quot;mst01.vdi&quot;] if !File.exist?(&quot;mst02.vdi&quot;) vb.customize [&quot;createhd&quot;, &quot;--filename&quot;, &quot;mst02.vdi&quot;, &quot;--size&quot;, 1024*4, &quot;--variant&quot;, &quot;Fixed&quot;] vb.customize [&quot;modifyhd&quot;, &quot;mst02.vdi&quot;, &quot;--type&quot;, &quot;shareable&quot;] end vb.customize [&quot;storageattach&quot;, :id, &quot;--storagectl&quot;, &quot;SATA&quot;, &quot;--port&quot;, 2, &quot;--device&quot;, 0, &quot;--type&quot;, &quot;hdd&quot;, &quot;--medium&quot;, &quot;mst02.vdi&quot;] if !File.exist?(&quot;mst03.vdi&quot;) vb.customize [&quot;createhd&quot;, &quot;--filename&quot;, &quot;mst03.vdi&quot;, &quot;--size&quot;, 1024*4, &quot;--variant&quot;, &quot;Fixed&quot;] vb.customize [&quot;modifyhd&quot;, &quot;mst03.vdi&quot;, &quot;--type&quot;, &quot;shareable&quot;] end vb.customize [&quot;storageattach&quot;, :id, &quot;--storagectl&quot;, &quot;SATA&quot;, &quot;--port&quot;, 3, &quot;--device&quot;, 0, &quot;--type&quot;, &quot;hdd&quot;, &quot;--medium&quot;, &quot;mst03.vdi&quot;] end end config.vm.define :node02 do |node02| node02.vm.hostname = &quot;node02&quot; node02.vm.network :&quot;public_network&quot;, ip: &quot;192.168.1.196&quot;, bridge: &quot;enp6s0&quot; node02.vm.provider &quot;virtualbox&quot; do |vb| vb.customize [&quot;modifyvm&quot;, :id, &quot;--memory&quot;, 1024*2] vb.customize [&quot;modifyvm&quot;, :id, &quot;--name&quot;, &quot;node02&quot;] if !File.exist?(&quot;ost1.vdi&quot;) vb.customize [&quot;createhd&quot;, &quot;--filename&quot;, &quot;ost1.vdi&quot;, &quot;--size&quot;, 1024*10, &quot;--variant&quot;, &quot;Fixed&quot;] vb.customize [&quot;modifyhd&quot;, &quot;ost1.vdi&quot;, &quot;--type&quot;, &quot;shareable&quot;] end vb.customize [&quot;storageattach&quot;, :id, &quot;--storagectl&quot;, &quot;SATA&quot;, &quot;--port&quot;, 1, &quot;--device&quot;, 0, &quot;--type&quot;, &quot;hdd&quot;, &quot;--medium&quot;, &quot;ost1.vdi&quot;] if !File.exist?(&quot;ost2.vdi&quot;) vb.customize [&quot;createhd&quot;, &quot;--filename&quot;, &quot;ost2.vdi&quot;, &quot;--size&quot;, 1024*4, &quot;--variant&quot;, &quot;Fixed&quot;] vb.customize [&quot;modifyhd&quot;, &quot;ost2.vdi&quot;, &quot;--type&quot;, &quot;shareable&quot;] end vb.customize [&quot;storageattach&quot;, :id, &quot;--storagectl&quot;, &quot;SATA&quot;, &quot;--port&quot;, 2, &quot;--device&quot;, 0, &quot;--type&quot;, &quot;hdd&quot;, &quot;--medium&quot;, &quot;ost2.vdi&quot;] if !File.exist?(&quot;ost3.vdi&quot;) vb.customize [&quot;createhd&quot;, &quot;--filename&quot;, &quot;ost3.vdi&quot;, &quot;--size&quot;, 1024*4, &quot;--variant&quot;, &quot;Fixed&quot;] vb.customize [&quot;modifyhd&quot;, &quot;ost3.vdi&quot;, &quot;--type&quot;, &quot;shareable&quot;] end vb.customize [&quot;storageattach&quot;, :id, &quot;--storagectl&quot;, &quot;SATA&quot;, &quot;--port&quot;, 3, &quot;--device&quot;, 0, &quot;--type&quot;, &quot;hdd&quot;, &quot;--medium&quot;, &quot;ost3.vdi&quot;] end end end  기본명령어 "},{"title":"vagrant snapshot list​","type":1,"pageTitle":"설치","url":"/blog/post/tags/server/page/4#vagrant-snapshot-list","content":"현재 스냅샷 목록을 불려온다 "},{"title":"vagrant snapshot save [name]​","type":1,"pageTitle":"설치","url":"/blog/post/tags/server/page/4#vagrant-snapshot-save-name","content":"해당 스냅샷 이름으로 저장한다 "},{"title":"vagrant snapshot resotere [name]​","type":1,"pageTitle":"설치","url":"/blog/post/tags/server/page/4#vagrant-snapshot-resotere-name","content":"해당 스냅샷 이름으로 복구한다 "},{"title":"vagrant init [name [url]]​","type":1,"pageTitle":"설치","url":"/blog/post/tags/server/page/4#vagrant-init-name-url","content":"현재 디렉터리룰 Vagrant 환경으로 초기화한다.  vagrant init ubuntu/trusty64 vagrant up  "},{"title":"vagrant up [name|id]​","type":1,"pageTitle":"설치","url":"/blog/post/tags/server/page/4#vagrant-up-nameid","content":"이 명령은 Vagrant 파일에 따라 가상머신을 생성 및 구성한다 "},{"title":"vagrant reload [name|id]​","type":1,"pageTitle":"설치","url":"/blog/post/tags/server/page/4#vagrant-reload-nameid","content":"해당 가상머신을 종료하고 다시 실행한다 "},{"title":"vagrant halt [name|id]​","type":1,"pageTitle":"설치","url":"/blog/post/tags/server/page/4#vagrant-halt-nameid","content":"해당 가상머신을 종료한다 "},{"title":"vagrant suspend [name|id]​","type":1,"pageTitle":"설치","url":"/blog/post/tags/server/page/4#vagrant-suspend-nameid","content":"해당 가상머신을 일시중지 한다 "},{"title":"vagrant status [name|id]​","type":1,"pageTitle":"설치","url":"/blog/post/tags/server/page/4#vagrant-status-nameid","content":"현재 가상머신들의 상태를 표시한다 "},{"title":"vagrant ssh [name|id][-- extra_ssh_args]​","type":1,"pageTitle":"설치","url":"/blog/post/tags/server/page/4#vagrant-ssh-nameid","content":"해당 가상머신으로 ssh 접속을 한다. "},{"title":"vagrant destroy [name|id]​","type":1,"pageTitle":"설치","url":"/blog/post/tags/server/page/4#vagrant-destroy-nameid","content":"해당 가상머신을 삭제한다. "},{"title":"원인","type":0,"sectionRef":"#","url":"/blog/post/tags/ssh","content":"[user@hostname ~]$ ssh root@pong @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be eavesdropping on you right now (man-in-the-middle attack)! It is also possible that a host key has just been changed. The fingerprint for the RSA key sent by the remote host is 6e:45:f9:a8:af:38:3d:a1:a5:c7:76:1d:02:f8:77:00. Please contact your system administrator. Add correct host key in /home/hostname /.ssh/known_hosts to get rid of this message. Offending RSA key in /var/lib/sss/pubconf/known_hosts:4 RSA host key for pong has changed and you have requested strict checking. Host key verification failed. 원인 known_hosts 파일에 저장되어 있는 정보하고 접속하려는 호스트와의 fingerprint 불일치 조치 다음 명령어를 실행 ssh-keygen -R &lt;host&gt; ","keywords":""},{"title":"원인","type":0,"sectionRef":"#","url":"/blog/post/tags/troubleshooting","content":"Centos SELINUX 설정을 비활성화 후에 재부팅시 부팅화면에서 멈추는 현상 원인 /etc/selinux/config 파일에 SELINUXTYPE=disabled 설정되어 있음 해결방안 grub 화면에서 부팅 운영체제를 선택후 e 키를 눌러서 kernel 부팅 옵션으로 들어가서 linux16 / vmlinu 가 있는 부분에 selinux = 0 추가할것 linux16 / vmlinu - 생략 - selinux = 0 완료후에 Ctrl + x 키로 리부트","keywords":""},{"title":"ubuntu jupyter-notekook 설치","type":0,"sectionRef":"#","url":"/blog/post/ubuntu-jupyter-notekook-설치","content":"","keywords":""},{"title":"1. python3 install​","type":1,"pageTitle":"ubuntu jupyter-notekook 설치","url":"/blog/post/ubuntu-jupyter-notekook-설치#1-python3-install","content":"$sudo apt install python3  "},{"title":"2. pip3 install​","type":1,"pageTitle":"ubuntu jupyter-notekook 설치","url":"/blog/post/ubuntu-jupyter-notekook-설치#2-pip3-install","content":"$sudo apt install python3-pip  "},{"title":"3. ipython3 install​","type":1,"pageTitle":"ubuntu jupyter-notekook 설치","url":"/blog/post/ubuntu-jupyter-notekook-설치#3-ipython3-install","content":"sudo apt install ipython3  "},{"title":"4. jupyter-notebook install​","type":1,"pageTitle":"ubuntu jupyter-notekook 설치","url":"/blog/post/ubuntu-jupyter-notekook-설치#4-jupyter-notebook-install","content":"sudo apt install jupyter-notebook  "},{"title":"5. start jupyter-notebook​","type":1,"pageTitle":"ubuntu jupyter-notekook 설치","url":"/blog/post/ubuntu-jupyter-notekook-설치#5-start-jupyter-notebook","content":"jupyter-notebook  "},{"title":"ubuntu 에서 Netflix 시청하기","type":0,"sectionRef":"#","url":"/blog/post/ubuntu-에서-Netflix-시청하기","content":"","keywords":""},{"title":"1. Firefox 에서 DRM 설정하기​","type":1,"pageTitle":"ubuntu 에서 Netflix 시청하기","url":"/blog/post/ubuntu-에서-Netflix-시청하기#1-firefox-에서-drm-설정하기","content":"Firefox 에서 DRM 제어 콘텐츠 재생 체크하기  "},{"title":"2. extra codecs 설치하기​","type":1,"pageTitle":"ubuntu 에서 Netflix 시청하기","url":"/blog/post/ubuntu-에서-Netflix-시청하기#2-extra-codecs-설치하기","content":"$ sudo apt install libavcodec-extra  "},{"title":"pip cannot import name main 에러날때","type":0,"sectionRef":"#","url":"/blog/post/ubuntu-에서-pip3-가-pip-cannot-import-name-main-에러날때","content":"","keywords":""},{"title":"원인​","type":1,"pageTitle":"pip cannot import name main 에러날때","url":"/blog/post/ubuntu-에서-pip3-가-pip-cannot-import-name-main-에러날때#원인","content":"ubuntu 에서 apt install python-pip 인스톨후에 sudo pip install pip --upgrade 함 "},{"title":"증상​","type":1,"pageTitle":"pip cannot import name main 에러날때","url":"/blog/post/ubuntu-에서-pip3-가-pip-cannot-import-name-main-에러날때#증상","content":"pip 실행간 다음과 같은 에러발생 guru@guru-notebook:~$ pip3 install numpy Traceback (most recent call last): File &quot;/usr/bin/pip3&quot;, line 9, in &lt;module&gt; from pip import main ImportError: cannot import name 'main'  "},{"title":"해결​","type":1,"pageTitle":"pip cannot import name main 에러날때","url":"/blog/post/ubuntu-에서-pip3-가-pip-cannot-import-name-main-에러날때#해결","content":"다음 명령어를 실행 (참고 : Error after upgrading pip: cannot import name 'main') sudo python3 -m pip uninstall pip &amp;&amp; sudo apt install python3-pip --reinstall  "},{"title":"Udemy 사이트 강좌 자막 번역 방법","type":0,"sectionRef":"#","url":"/blog/post/Udemy-사이트-강좌-자막-번역-방법","content":"","keywords":""},{"title":"1. 플레이어 설정​","type":1,"pageTitle":"Udemy 사이트 강좌 자막 번역 방법","url":"/blog/post/Udemy-사이트-강좌-자막-번역-방법#1-플레이어-설정","content":"Udemy 플레이어 부분에 CC 버튼을 클릭후 자막 설정 클릭자막 설정에서 동영살 아래에 표시 토글 활성화대본 활성화 "},{"title":"2. 스크립트 입력​","type":1,"pageTitle":"Udemy 사이트 강좌 자막 번역 방법","url":"/blog/post/Udemy-사이트-강좌-자막-번역-방법#2-스크립트-입력","content":"F12 키를 입력 후에 콘솔창에서 다음과 같은 스크립트를 입력 if (void 0 !== window.is) clearInterval(window.is); else { let e = &quot;&quot;; function check() { let t = $(&quot;.well--container--2edq4 span&quot;), n = $('p[data-purpose=&quot;transcript-cue-active&quot;] span font font'), i = n.html(); e !== i &amp;&amp; t.html(i), (e = n.html()); } window.is = setInterval(check, 200); }  "},{"title":"3. 번역​","type":1,"pageTitle":"Udemy 사이트 강좌 자막 번역 방법","url":"/blog/post/Udemy-사이트-강좌-자막-번역-방법#3-번역","content":"마우스 우클릭후에 헌국어(으)로 번역 클릭 즐공 "},{"title":"vagrant box 저장위치 설정","type":0,"sectionRef":"#","url":"/blog/post/vagrant-box-저장위치-설정","content":".bashrc 파일에 다음과 같이 설정 export VAGRANT_HOME=/media/master/vagrant ","keywords":""},{"title":"Vagrant Disk Change","type":0,"sectionRef":"#","url":"/blog/post/Vagrant-Disk-Change","content":"Vagrant 은 기본적으로 가상머신을 할당할때 디스크 사이즈가 10G 로 할당되어 있어서 추가로 용량을 잡을때 별도의 디스크를 잡아야 하는 문제가 생긴다. 이를 해결하기 위해서는 직접 virtualbox 을 통해서 디스크 사이즈를 조정해줘야 한다. 디스크 사이즈 변경법 Virtual box VMs 폴더로 이동 cd ~/VirtualBox\\ VMs/&lt;virtualbox folder&gt; vmdk 파일 형식을 vdi 형식으로 변경 (디스크 수정이 가능한 포맷) VBoxManage clonehd &quot;ubuntu-xenial-16.04-cloudimg.vmdk&quot; &quot;ubuntu-xenial-16.04-cloudimg.vdi&quot; --format vdi 디스크 사이즈 변경 VBoxManage modifyhd &quot;ubuntu-xenial-16.04-cloudimg.vdi&quot; --resize 40960 가상머신에서 수정한 디스크로 변경 결과","keywords":""},{"title":"Vagrant 에서 메모리 CPU 코어수 조정","type":0,"sectionRef":"#","url":"/blog/post/Vagrant-에서-메모리-CPU-코어수-조정","content":"메모리 할당을 설정시 Vagrantfile 에서 다음 항목을 추가한다. config.vm.customize [&quot;modifyvm&quot;, :id, &quot;--memory&quot;, 2048] 아니면 CPU 설정시 다음 항목을 수정한다. config.vm.customize [&quot;modifyvm&quot;, :id, &quot;--cpus&quot;, 2] Vagrantfile 예시 # -*- mode: ruby -*- # vi: set ft=ruby : hosts = { &quot;n1&quot; =&gt; &quot;192.168.77.10&quot;, &quot;n2&quot; =&gt; &quot;192.168.77.11&quot;, &quot;n3&quot; =&gt; &quot;192.168.77.12&quot;, &quot;n4&quot; =&gt; &quot;192.168.77.13&quot;, } Vagrant.configure(&quot;2&quot;) do |config| config.ssh.insert_key = false config.ssh.forward_agent = true check_guest_additions = false functional_vboxsf = false config.vm.box = &quot;bento/ubuntu-16.04&quot; hosts.each do |name, ip| config.vm.define name do |machine| machine.vm.network :private_network, ip: ip machine.vm.provider &quot;virtualbox&quot; do |v| v.customize [&quot;modifyvm&quot;, :id, &quot;--cpus&quot;, 2] v.name = name end end end end ","keywords":""},{"title":"Vagrant 사용법","type":0,"sectionRef":"#","url":"/blog/post/Vagrant-사용법","content":"","keywords":""},{"title":"설치환경​","type":1,"pageTitle":"Vagrant 사용법","url":"/blog/post/Vagrant-사용법#설치환경","content":"virtualbox 설치 - 추가 virtualbox 확장설치  Hyper-V 설정 "},{"title":"설치절차​","type":1,"pageTitle":"Vagrant 사용법","url":"/blog/post/Vagrant-사용법#설치절차","content":"우분투 sudo apt install virtualbox 윈도우즈 Download https://releases.hashicorp.com/vagrant/2.2.2/vagrant_2.2.2_x86_64.msiinstall package 맥 https://releases.hashicorp.com/vagrant/2.2.2/vagrant_2.2.2_x86_64.dmginstall package Vagrantfile Vagrantfile 내용 # -*- mode: ruby -*- # vi: set ft=ruby : # vagrant 버쟌 설정 Vagrant.configure(&quot;2&quot;) do |config| # box 이름 지정 # https://app.vagrantup.com/boxes/search 에서 검색가능 config.vm.box = &quot;CentosBox/Centos7-v7.3-Minimal&quot; # vagrant 가상머신 이름지정 config.vm.define :node01 do |node01| # 호스트이름 지정 node01.vm.hostname = &quot;node01&quot; # 네트워크 설정 (브릿지 네트워크) node01.vm.network :&quot;public_network&quot;, ip: &quot;192.168.1.195&quot;, bridge: &quot;enp6s0&quot; # virtualbox 설정 node01.vm.provider &quot;virtualbox&quot; do |vb| # 메모리 설정 vb.customize [&quot;modifyvm&quot;, :id, &quot;--memory&quot;, 1024*2] vb.customize [&quot;modifyvm&quot;, :id, &quot;--name&quot;, &quot;node01&quot;] # 디스크 설정 # 만약에 파일이 존재하지 않을경우 디스크 파일 생성 if !File.exist?(&quot;mst01.vdi&quot;) vb.customize [&quot;createhd&quot;, &quot;--filename&quot;, &quot;mst01.vdi&quot;, &quot;--size&quot;, 1024*10, &quot;--variant&quot;, &quot;Fixed&quot;] vb.customize [&quot;modifyhd&quot;, &quot;mst01.vdi&quot;, &quot;--type&quot;, &quot;shareable&quot;] end # 해당 파일 병으로 디스크 추가 vb.customize [&quot;storageattach&quot;, :id, &quot;--storagectl&quot;, &quot;SATA&quot;, &quot;--port&quot;, 1, &quot;--device&quot;, 0, &quot;--type&quot;, &quot;hdd&quot;, &quot;--medium&quot;, &quot;mst01.vdi&quot;] if !File.exist?(&quot;mst02.vdi&quot;) vb.customize [&quot;createhd&quot;, &quot;--filename&quot;, &quot;mst02.vdi&quot;, &quot;--size&quot;, 1024*4, &quot;--variant&quot;, &quot;Fixed&quot;] vb.customize [&quot;modifyhd&quot;, &quot;mst02.vdi&quot;, &quot;--type&quot;, &quot;shareable&quot;] end vb.customize [&quot;storageattach&quot;, :id, &quot;--storagectl&quot;, &quot;SATA&quot;, &quot;--port&quot;, 2, &quot;--device&quot;, 0, &quot;--type&quot;, &quot;hdd&quot;, &quot;--medium&quot;, &quot;mst02.vdi&quot;] if !File.exist?(&quot;mst03.vdi&quot;) vb.customize [&quot;createhd&quot;, &quot;--filename&quot;, &quot;mst03.vdi&quot;, &quot;--size&quot;, 1024*4, &quot;--variant&quot;, &quot;Fixed&quot;] vb.customize [&quot;modifyhd&quot;, &quot;mst03.vdi&quot;, &quot;--type&quot;, &quot;shareable&quot;] end vb.customize [&quot;storageattach&quot;, :id, &quot;--storagectl&quot;, &quot;SATA&quot;, &quot;--port&quot;, 3, &quot;--device&quot;, 0, &quot;--type&quot;, &quot;hdd&quot;, &quot;--medium&quot;, &quot;mst03.vdi&quot;] end end config.vm.define :node02 do |node02| node02.vm.hostname = &quot;node02&quot; node02.vm.network :&quot;public_network&quot;, ip: &quot;192.168.1.196&quot;, bridge: &quot;enp6s0&quot; node02.vm.provider &quot;virtualbox&quot; do |vb| vb.customize [&quot;modifyvm&quot;, :id, &quot;--memory&quot;, 1024*2] vb.customize [&quot;modifyvm&quot;, :id, &quot;--name&quot;, &quot;node02&quot;] if !File.exist?(&quot;ost1.vdi&quot;) vb.customize [&quot;createhd&quot;, &quot;--filename&quot;, &quot;ost1.vdi&quot;, &quot;--size&quot;, 1024*10, &quot;--variant&quot;, &quot;Fixed&quot;] vb.customize [&quot;modifyhd&quot;, &quot;ost1.vdi&quot;, &quot;--type&quot;, &quot;shareable&quot;] end vb.customize [&quot;storageattach&quot;, :id, &quot;--storagectl&quot;, &quot;SATA&quot;, &quot;--port&quot;, 1, &quot;--device&quot;, 0, &quot;--type&quot;, &quot;hdd&quot;, &quot;--medium&quot;, &quot;ost1.vdi&quot;] if !File.exist?(&quot;ost2.vdi&quot;) vb.customize [&quot;createhd&quot;, &quot;--filename&quot;, &quot;ost2.vdi&quot;, &quot;--size&quot;, 1024*4, &quot;--variant&quot;, &quot;Fixed&quot;] vb.customize [&quot;modifyhd&quot;, &quot;ost2.vdi&quot;, &quot;--type&quot;, &quot;shareable&quot;] end vb.customize [&quot;storageattach&quot;, :id, &quot;--storagectl&quot;, &quot;SATA&quot;, &quot;--port&quot;, 2, &quot;--device&quot;, 0, &quot;--type&quot;, &quot;hdd&quot;, &quot;--medium&quot;, &quot;ost2.vdi&quot;] if !File.exist?(&quot;ost3.vdi&quot;) vb.customize [&quot;createhd&quot;, &quot;--filename&quot;, &quot;ost3.vdi&quot;, &quot;--size&quot;, 1024*4, &quot;--variant&quot;, &quot;Fixed&quot;] vb.customize [&quot;modifyhd&quot;, &quot;ost3.vdi&quot;, &quot;--type&quot;, &quot;shareable&quot;] end vb.customize [&quot;storageattach&quot;, :id, &quot;--storagectl&quot;, &quot;SATA&quot;, &quot;--port&quot;, 3, &quot;--device&quot;, 0, &quot;--type&quot;, &quot;hdd&quot;, &quot;--medium&quot;, &quot;ost3.vdi&quot;] end end end  기본명령어 "},{"title":"vagrant snapshot list​","type":1,"pageTitle":"Vagrant 사용법","url":"/blog/post/Vagrant-사용법#vagrant-snapshot-list","content":"현재 스냅샷 목록을 불려온다 "},{"title":"vagrant snapshot save [name]​","type":1,"pageTitle":"Vagrant 사용법","url":"/blog/post/Vagrant-사용법#vagrant-snapshot-save-name","content":"해당 스냅샷 이름으로 저장한다 "},{"title":"vagrant snapshot resotere [name]​","type":1,"pageTitle":"Vagrant 사용법","url":"/blog/post/Vagrant-사용법#vagrant-snapshot-resotere-name","content":"해당 스냅샷 이름으로 복구한다 "},{"title":"vagrant init [name [url]]​","type":1,"pageTitle":"Vagrant 사용법","url":"/blog/post/Vagrant-사용법#vagrant-init-name-url","content":"현재 디렉터리룰 Vagrant 환경으로 초기화한다.  vagrant init ubuntu/trusty64 vagrant up  "},{"title":"vagrant up [name|id]​","type":1,"pageTitle":"Vagrant 사용법","url":"/blog/post/Vagrant-사용법#vagrant-up-nameid","content":"이 명령은 Vagrant 파일에 따라 가상머신을 생성 및 구성한다 "},{"title":"vagrant reload [name|id]​","type":1,"pageTitle":"Vagrant 사용법","url":"/blog/post/Vagrant-사용법#vagrant-reload-nameid","content":"해당 가상머신을 종료하고 다시 실행한다 "},{"title":"vagrant halt [name|id]​","type":1,"pageTitle":"Vagrant 사용법","url":"/blog/post/Vagrant-사용법#vagrant-halt-nameid","content":"해당 가상머신을 종료한다 "},{"title":"vagrant suspend [name|id]​","type":1,"pageTitle":"Vagrant 사용법","url":"/blog/post/Vagrant-사용법#vagrant-suspend-nameid","content":"해당 가상머신을 일시중지 한다 "},{"title":"vagrant status [name|id]​","type":1,"pageTitle":"Vagrant 사용법","url":"/blog/post/Vagrant-사용법#vagrant-status-nameid","content":"현재 가상머신들의 상태를 표시한다 "},{"title":"vagrant ssh [name|id][-- extra_ssh_args]​","type":1,"pageTitle":"Vagrant 사용법","url":"/blog/post/Vagrant-사용법#vagrant-ssh-nameid","content":"해당 가상머신으로 ssh 접속을 한다. "},{"title":"vagrant destroy [name|id]​","type":1,"pageTitle":"Vagrant 사용법","url":"/blog/post/Vagrant-사용법#vagrant-destroy-nameid","content":"해당 가상머신을 삭제한다. "},{"title":"vscode 특정폴더 숨기기","type":0,"sectionRef":"#","url":"/blog/post/vscode-특정폴더-숨기기","content":"","keywords":""},{"title":"설정​","type":1,"pageTitle":"vscode 특정폴더 숨기기","url":"/blog/post/vscode-특정폴더-숨기기#설정","content":"vscode 설정창으로 이동 {% asset_img &quot;img1.png&quot; &quot;spaced title&quot; %}사용자 설정에서 검색창에 exclude 을 입력후에 Files.Execlude 항목에서 숨길 폴더 추가 {% asset_img &quot;img2.png&quot; &quot;spaced title&quot; %} "},{"title":"WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! 해결하기","type":0,"sectionRef":"#","url":"/blog/post/WARNING-REMOTE-HOST-IDENTIFICATION-HAS-CHANGED-해결하기","content":"[user@hostname ~]$ ssh root@pong @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be eavesdropping on you right now (man-in-the-middle attack)! It is also possible that a host key has just been changed. The fingerprint for the RSA key sent by the remote host is 6e:45:f9:a8:af:38:3d:a1:a5:c7:76:1d:02:f8:77:00. Please contact your system administrator. Add correct host key in /home/hostname /.ssh/known_hosts to get rid of this message. Offending RSA key in /var/lib/sss/pubconf/known_hosts:4 RSA host key for pong has changed and you have requested strict checking. Host key verification failed. 원인 known_hosts 파일에 저장되어 있는 정보하고 접속하려는 호스트와의 fingerprint 불일치 조치 다음 명령어를 실행 ssh-keygen -R &lt;host&gt; ","keywords":""},{"title":"webpack devserver proxy 설정법","type":0,"sectionRef":"#","url":"/blog/post/webpack-devserver-proxy-설정법","content":"package.json 파일에서 &quot;proxy&quot;: &quot;http://localhost:&lt;PORT-GOES-HERE&gt;&quot; 설정한다 package.json 예시 { &quot;name&quot;: &quot;client&quot;, &quot;version&quot;: &quot;0.1.0&quot;, &quot;private&quot;: true, &quot;dependencies&quot;: { &quot;react&quot;: &quot;^16.3.2&quot;, &quot;react-dom&quot;: &quot;^16.3.2&quot;, &quot;react-scripts&quot;: &quot;1.1.4&quot; }, &quot;scripts&quot;: { &quot;start&quot;: &quot;react-scripts start&quot;, &quot;build&quot;: &quot;react-scripts build&quot;, &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;, &quot;eject&quot;: &quot;react-scripts eject&quot; }, &quot;proxy&quot;: &quot;http://localhost:&lt;PORT-GOES-HERE&gt;&quot; } ","keywords":""},{"title":"Welcome","type":0,"sectionRef":"#","url":"/blog/post/welcome","content":"Docusaurus blogging features are powered by the blog plugin. Simply add Markdown files (or folders) to the blog directory. Regular blog authors can be added to authors.yml. The blog post date can be extracted from filenames, such as: 2019-05-30-welcome.md2019-05-30-welcome/index.md A blog post folder can be convenient to co-locate blog post images: The blog supports tags as well! And if you don't want a blog: just delete this directory, and use blog: false in your Docusaurus config.","keywords":""},{"title":"yarn 캐쉬 지우기","type":0,"sectionRef":"#","url":"/blog/post/yarn-캐쉬-지우기","content":"가끔 맵리듀스 작업을 하다보면, yarn 에 캐쉬가 많이 남아 있어서 충돌이 발생하는 경우가 발생한다. 초기화을 하자 yarn cache 저장위치 확인하기 yarn-site.xml 파일에 yarn.nodemanager.local-dirs 위치 확인하기 &lt;property&gt; &lt;name&gt;yarn.nodemanager.local-dirs&lt;/name&gt; &lt;value&gt;/hadoop/yarn/local&lt;/value&gt; &lt;/property&gt; 해당 폴더의 내용 지우기 [yarn@node2 ~]$ cd /hadoop/yarn/local/ [yarn@node2 local]$ ls filecache nmPrivate spark_shuffle usercache [yarn@node2 local]$ rm -rf filecache/ usercache/ yarn 재시작","keywords":""},{"title":"맥에서 sshpass 이용하기","type":0,"sectionRef":"#","url":"/blog/post/맥에서-sshpass-이용하기","content":"맥에서 sshpass 을 설치하기 위해서는 콘솔창에서 다음 명령어로 설치한다. $ brew install https://raw.githubusercontent.com/kadwanev/bigboybrew/master/Library/Formula/sshpass.rb ","keywords":""},{"title":"우분투 18.04 최대절전모드 활성화","type":0,"sectionRef":"#","url":"/blog/post/우분투-18-04-최대절전모드-활성화","content":"터미널 창에서 다음 명령어로 최대절전모드가 작동이 되는지 확인 sudo systemctl hibernate 그놈메뉴에 최대절전모드 활성화 하기 터미널창에 다음 명령어를 입력하여 환경설정 파일 열기 sudo gedit /etc/polkit-1/localauthority/50-local.d/com.ubuntu.enable-hibernate.pkla 파일에 다음과 같은 내용을 입력 [Re-enable hibernate by default in upower] Identity=unix-user:* Action=org.freedesktop.upower.hibernate ResultActive=yes [Re-enable hibernate by default in logind] Identity=unix-user:* Action=org.freedesktop.login1.hibernate;org.freedesktop.login1.handle-hibernate-key;org.freedesktop.login1;org.freedesktop.login1.hibernate-multiple-sessions;org.freedesktop.login1.hibernate-ignore-inhibit ResultActive=yes 시스템 재시작 및 그놈 확장 설치 : Hibernate Status Button.","keywords":""},{"title":"지뢰찾기 구현","type":0,"sectionRef":"#","url":"/blog/post/지뢰찾기-구현","content":"","keywords":""},{"title":"실행 방법​","type":1,"pageTitle":"지뢰찾기 구현","url":"/blog/post/지뢰찾기-구현#실행-방법","content":"node.js , npm 을 설치 합니다.the-mine-sweeper 폴더로 이동후에 다음 명령어를 실행합니다. $ npm install node module 을 설치 하고 나서 다음 명령어를 입력하여 dev server 을 실행합니다. $ npm start  "},{"title":"권장 사항​","type":1,"pageTitle":"지뢰찾기 구현","url":"/blog/post/지뢰찾기-구현#권장-사항","content":"최신 버젼의 Chrome, Firefox, Safari, Edge 에서 실행을 권장합니다. "},{"title":"빌드방법​","type":1,"pageTitle":"지뢰찾기 구현","url":"/blog/post/지뢰찾기-구현#빌드방법","content":"the-mine-sweeper 폴더로 이동후에 다음 명령어를 실행합니다. $ npm run build the-mine-sweeper/build 폴더내의 파일들을 웹서버에 업로드 합니다. 만약 직접 실행할경우 다음 명령어를 입력합니다. $ npm install -g serve $ serve -s build  "},{"title":"Example​","type":1,"pageTitle":"지뢰찾기 구현","url":"/blog/post/지뢰찾기-구현#example","content":"다음 홈페이지에 접속하면 실제 페이지를 볼수 있습니다. https://hardwooooooork.github.io/the-mine-sweeper/ "},{"title":"DataBase CAP 이론이란","type":0,"sectionRef":"#","url":"/blog/second/2023/02/13/cap-이론","content":"","keywords":""},{"title":"Consistency, Availability, Partition tolerance​","type":1,"pageTitle":"DataBase CAP 이론이란","url":"/blog/second/2023/02/13/cap-이론#consistency-availability-partition-tolerance","content":"C, A, P 중 2개를 선택해야 한다. (3가지 모두 만족할 순 없음)  일관성(Consistency) 모든 노드들은 같은 시간에 동일한 항목에 대하여 같은 내용의 데이터를 사용자에게 보여준다. 가용성(Availability) 모든 사용자들이 읽기 및 쓰기가 가능해야 하며, 몇몇 노드의 장애 시에도 다른 노드에 영향을 미치면 안된다. 분할내성(Partition tolerance) 메시지 전달이 실패하거나 시스템 일부가 망가져도 시스템이 계속 동작할 수 있어야 한다. "},{"title":"CAP 선택 유형​","type":1,"pageTitle":"DataBase CAP 이론이란","url":"/blog/second/2023/02/13/cap-이론#cap-선택-유형","content":"분류\t설명\t예시C+A\t메시지 손실을 방지하는 강한 신뢰형\t일반적 RDBMS 오라클 등 C+P\t데이터 보다는 성능이 중요한 퍼포먼스형\tBig Table MongoDB A+P\t일관성을 크게 요하지 않는 서비스에 적합\tCouchDB Cassandra "},{"title":"DataBase 개요 1","type":0,"sectionRef":"#","url":"/blog/second/2023/02/14/DB개요1","content":"","keywords":""},{"title":"데이터 / 정보 / 지식 / 지혜​","type":1,"pageTitle":"DataBase 개요 1","url":"/blog/second/2023/02/14/DB개요1#데이터--정보--지식--지혜","content":" 구분\t특징\t비교\t관련 시스템Data\t- 그자체로는 의미를 갖지않고 존재하는것 - 식별 및 기록이 가능한 단순한 사실\t- 영수증 내 기록데이터\t데이터베이스, OLTP, CDC, ETL, 데이터 레이크 Information\t- 관계에 따라 의미가 부여된 Data - 의미있게 구조화된 Data 의 집합\t- 어제매출 : 70만원 - 오늘매출 : 40만원 -&gt; 평균 60만원\t데이터 웨어하우스, OLAP Knowledge\t- 의사 결정에 이용되는 정보 - 부가 가치 창출 - 정보의 추상화 , 일반화\t- 매출증가의 원인분석 눈이 오면 가까운 곳에서 시켜먹으려는 경향\t지식 관리 시스템(KMS), 전사적 지식 포탈(EKP) Wisdom\t- 올바른 결정이나 판단을 위한 지식과 경험이 축적된 상태 / 능력\t- 창의적인 아이디어 응용 (눈예보시 배달 10% 할인 판촉행사 -&gt; 매출 100만원 증가)\t비즈니스 인텔리전스(BI)  "},{"title":"데이터 베이스의 정의​","type":1,"pageTitle":"DataBase 개요 1","url":"/blog/second/2023/02/14/DB개요1#데이터-베이스의-정의","content":"한 조직의 여러 응용 시스템이 공용 하기 위해 최소의 중복으로 통합, 저장된 운영된 데이터의 집합 통합 데이터 : 최소의 중복 / 통제된 중복저장 데이터 : 컴퓨터가 접근 가능한 매체에 저장운영 데이터 : 조직의 운영에 꼭 필요한 필수적인 데이터베이스공유 데이터 : 여러 응용 프로그램이 공통으로 허용 하나 이상의 서로 관련이 되는 조직체들의 활동을 기술하는 데이터 들의 모임 특징\t내용실시간 접근\t저장되는 데이터는 실시간 접근성이 보장된 계속적인 변화\t갱신 삽입 삭제등의 연산에 의해 내용이 동적으로 변경됨 동시 공유\t저장된 데이터는 자수의 사용자에 의해 동시에 공유할수 있음 내용에 의한 참조\t사용자는 참조하기를 원하는 데이터의 내용을 이용하여 데이터의 저장 위차나 수에 상관없이 데이터에 논리적으로 접근할수 있음  "},{"title":"데이터베이스 시스템의 정의​","type":1,"pageTitle":"DataBase 개요 1","url":"/blog/second/2023/02/14/DB개요1#데이터베이스-시스템의-정의","content":"데이터를 저장 유지 관리하여 정보를 생성하는 시스템데이터베이스를 포함하여 이를 구축, 관리하고 사용하기 위한 총체적인 시스템   "},{"title":"데이터베이스 시스템의 기본 구조​","type":1,"pageTitle":"DataBase 개요 1","url":"/blog/second/2023/02/14/DB개요1#데이터베이스-시스템의-기본-구조","content":" 단계\t설명외부단계\t- 사용자에서 데이터를 바라보는 관점을 모델링한것 - 여러개의 외부 스키마를 가질수 있음 ex)자동차에 대한 사용자의 관점 : 이동수단(운전자), 수리대상(정비사) 개념단계\t- DB 관리자가 데이터를 바라보는 관점을 모델링한것 - 데이터베이스의 구조와 데이터간의 관계를 논리적으로 표현 - 데이터 베이스 관리자에 의하여 사용되며, 하나의 개념스크마를 가지고 있음 내부단계\t- 물리적은 저장구조를 표현, 데이터를 실제로 어떻게 저장할지에 대하여 데이터베이스 관리자가 기술 - 시스템 설계자나 시스템 프로그래머가 데이터를 바라보는 관점 - 라나의 내부스키마를 가짐 "},{"title":"DataBase 개요 2","type":0,"sectionRef":"#","url":"/blog/second/2023/02/14/DB개요2","content":"","keywords":""},{"title":"데이터 베이스 3단계 아키텍쳐 ANSI/SPARC 모델​","type":1,"pageTitle":"DataBase 개요 2","url":"/blog/second/2023/02/14/DB개요2#데이터-베이스-3단계-아키텍쳐-ansisparc-모델","content":"ANSI/SPARC (American National Standards Institute / System Planning And Requirements Commitree) 모델사용자 관점, 통합 모델 관점, 저장장치의 세가지 관점에서 Architecture 정의 및 이들 간에 상호 연관관계를 정의함미국 표준협회(ANSI) 산하의 X3 위원회 (컴퓨터 및 정보처리)의 특별 연구분과 위원회에서 DBMS 와 그 인터페이스를 위해 제안한 Three-Schema Architeture (1978년) 단계\t설명\t비고외부 스키마\t- 사용자나 응용 프로그래머가 접근한수 있는 데이터베이를 정의 - 전체 데이터베이스의 한 논리적인 부분으로 볼수 있으므로 서브 스키마라고 함\tView 개념 스키마\t- 범 기관적 입장에서 본 데이터베이스의 정의를 기술 - 모든응용에 대한 전체적으로 통합된 데이터 구조로서 단순히 스키마라고 함 (스키마라고 하면 일반적으로 개념스키마를 의미함) - 접근권한, 보안정채그 무결성 규칙을 명세\t통합 ERD 내부 스키마\t- 물리적 저장 장치의 관점에서 본 전체 데이터베이스의 명세의미 - 개념스키마의 물리적 저장구조에 대한 정의를 기술\t물리DB  "},{"title":"ANSI/SPARC 아키텍쳐 스키마와 인스턴스​","type":1,"pageTitle":"DataBase 개요 2","url":"/blog/second/2023/02/14/DB개요2#ansisparc-아키텍쳐-스키마와-인스턴스","content":"구분\t스키마\t인스턴스정의\t- 데이터베이스에 저장되는 데이터 구조및 유형을 정의한것 - 데이터베이스의 전체적인 정의를 나타내며 일반적으로 개념(논리) 스키마를 지정함\t- 데이터베이스에 실제 저장되어 있는 값들을 나타냄 특징\t- 한번 정의되면 잘 변경되지 않음\t- 계속적으로 변화하는 데이터베이스 특성으로 인래 자주 변경됨 언어\t- DDL(Data Definition Language)\t- DML(Data Multiplation Language) 사례   "},{"title":"3단계 Student 데이터베이스 예​","type":1,"pageTitle":"DataBase 개요 2","url":"/blog/second/2023/02/14/DB개요2#3단계-student-데이터베이스-예","content":"  "},{"title":"데이터 독립성​","type":1,"pageTitle":"DataBase 개요 2","url":"/blog/second/2023/02/14/DB개요2#데이터-독립성","content":""},{"title":"데이터 독립성의 정의​","type":1,"pageTitle":"DataBase 개요 2","url":"/blog/second/2023/02/14/DB개요2#데이터-독립성의-정의","content":"상위 단계의 스키마 정의에 영향을 주지 않으면서 어떤 단계의 스키마를 변경할수 있는것 "},{"title":"데이터 독립성의 목적​","type":1,"pageTitle":"DataBase 개요 2","url":"/blog/second/2023/02/14/DB개요2#데이터-독립성의-목적","content":"DB 에 대한 사용자의 View 와 DB 가 실제 표현되는 View를 분리하여 변경 간섭 최소화각 View 의 독립성 유지, 계층별 View 에 영향을 주지 않고 변경이 가능 구분\t내용논리적 독립성\t- 외부 스키마나 응용 프로그램을 변경하지 않으면서 개념 스키마를 변경할수 있는 능력(성질) - 개념 스키마 구조의 변경이나 속성의 삭제 등도 이것을 실제로 이용하지 않는 외부 스키마는 영향을 주지않음 물리적 독립성\t- 개념 스키마를 변경하지 않으면서 내부 스키마를 변경할수 있는 능력(성질) - 개념 스키마가 디스크 내의 내부 필드와 어떻게 대응하는가를 정의 - 다른 디스크로의 데이터 이동이나 파일 구조의 변경과 같은 물리적인 변경 필요시 내부스키마를 변경해주면 개념스키마에 영향을 주지 않음  "},{"title":"3단계 스키마 간의 사상​","type":1,"pageTitle":"DataBase 개요 2","url":"/blog/second/2023/02/14/DB개요2#3단계-스키마-간의-사상","content":" "},{"title":"DataBase 개요 3","type":0,"sectionRef":"#","url":"/blog/second/2023/02/14/DB개요3","content":"","keywords":""},{"title":"DBMS 의 정의​","type":1,"pageTitle":"DataBase 개요 3","url":"/blog/second/2023/02/14/DB개요3#dbms-의-정의","content":"다수의 사용자들이 데이터 베이스 내의 데이터를 접근할 수 있도록 해 주는 관리 소프트웨어 도구들의 집합 "},{"title":"DBMS 의 기능​","type":1,"pageTitle":"DataBase 개요 3","url":"/blog/second/2023/02/14/DB개요3#dbms-의-기능","content":"데이터 저장과 개발 및 유지보구 측면에서 중복성의 통제많은 사용자 간의 데이터 공유권한없는 사용자의 데이터 접근을 통제다양한 사용자에게 다양한 형태의 인터페이스를 제공데이터 사양에 존재하는 복잡한 관련성을 표현데이터베이스의 무결성을 보장백업과 복구 기능을 제공  "},{"title":"DataBase 개요 4","type":0,"sectionRef":"#","url":"/blog/second/2023/02/15/DB개요4","content":"","keywords":""},{"title":"관계형(RDB), 겍체지향형(OODBMS)​","type":1,"pageTitle":"DataBase 개요 4","url":"/blog/second/2023/02/15/DB개요4#관계형rdb-겍체지향형oodbms","content":"구분\tRDBMS\tOODBMS\tORDBMS저장파일\t문자열 데이터 위주\t데이터와 연관 프로그램 (메소드) 저장\t데이터와 연관 프로그램 (메소드) 저장 자료모델\t테이블 구조 관계 기본키 (Primary Key)\t엔티티간 포인팅 방식 겍체지향(OID)\tRDBMS, OODBMS 자원 자료형\t미리 정의된 일반정보 타입만 지원\t비정형 겍체타입 지원\t사용자 정의 및 비정형 겍체타입 지원 DB 엑세스 방식\tSQL 질의어 사용\tOQL(Object Query Lang)\tSQL 확장 질의어 사용(SQL3) 장점\t시스템 안정성과 대규모 트랜젝션 처리\t복잡 비정형 모델 적용\t관계형의 안정성과 겍체지향모델의 복합적 요소 모델적용 단점\t복잡한 정보수용을 위한 모델적용이 제한적임\t데이터 베이스 기본기능이 미약하여 안정성, 성능 미흡\t표준화가 되어있지 않음  "},{"title":"시스템 카탈로그 / 데이터 사전의 개념​","type":1,"pageTitle":"DataBase 개요 4","url":"/blog/second/2023/02/15/DB개요4#시스템-카탈로그--데이터-사전의-개념","content":"데이터 베이스에 포함되어 있는 모든 데이터 겍체에 대한 정의나 명세에 관한 정보를 저장하는 자료 저장소, 자료 사전광의적 의미로는 메타정보의 성격을 지니며, 협의적 의미로는 데이터베이스 시스템 카탈로그정보자원관리나 시스템 H/W, S/W, 문서, 사용자들에 대한 정보관리 등을 위해 설계자, 사용자, 관리자가 주로 사용함범용 DBMS의 핵심인 메타데이터로서 데이터베이스의 스키마 정보, 스키마들간의 사상정보, DBMS의 특정 모듈 (질의 최적화기, 권한관리 모델등)들이 필요로 하는 정보를 저장 "},{"title":"시스템 카탈로그의 특징​","type":1,"pageTitle":"DataBase 개요 4","url":"/blog/second/2023/02/15/DB개요4#시스템-카탈로그의-특징","content":"카탈로그 자체도 시스템 테이블로 구성되어 있어 일반 이용자들도 권한에 따라 SQL 을 이용하여 내용 검색 가능Insert, Update, Delete 문으로 갱신하는 것은 허용되지 않음DBMS가 스스로 생성하고 유지함  "},{"title":"시스템 카탈로그 / 데이터 사정의 필요 이유 및 주요 구성요소​","type":1,"pageTitle":"DataBase 개요 4","url":"/blog/second/2023/02/15/DB개요4#시스템-카탈로그--데이터-사정의-필요-이유-및-주요-구성요소","content":"구성요소\t내용스키마 구조\t- 스키마의 테이블명, 인텍스명, 칼럼명, 뷰, 참조관계에 대한 내용 감사 추적\t- 데이터베이스에서 작업을 수행한 이력, 트랜잭션 정보 세션정보 등 사용자 권한\t- 데이터베이스 오브젝트에 대해 접근하기 위한 접근, 입력, 수정, 삭제 등에 대한 권한정보 질의 최적화하기\t- Optimizer 가 최적화된 경로를 찾기 위한 통계정보를 생성하여 저장 컴파일러\t- 고수준의 질의와 데이터 조작어 영향들을 저수준의 파일접근 명령으로 변환   "},{"title":"데이터베이스의 언어의 정의​","type":1,"pageTitle":"DataBase 개요 4","url":"/blog/second/2023/02/15/DB개요4#데이터베이스의-언어의-정의","content":"데이터베이스를 정의하고 접근하기 위한 방법으로 사용자가 DBMS를 활용하기 위한 대화도구임 종류\t설명\t비교DML\t- Data Manipluation Language - 데이터베이스의 원하는 데이터를 조작(검색하고, 수정하고, 삽입하고, 삭제 ) 하는 언어 - 사용자와 데이터베이스 사이의 인터베이스 제공 - 절차적 DML(응용프로그램), 비절차적 DML (질의어)\t- SELECT - INSERT - UPDATE - DELETE DDL\t- Data Definition Language - 데이터베이스의 스키마를 정의하는 언어로 DBA가 사용 - 메타 데이터 형태로 데이터 사전(Data Dictionary) 이라는 특별한 파일에 기록\t- CREATE - ALTER - DROP DCL\t- Data Control Language - 데이터베이스의 규정이나 기법을 정의하고 제어하는 언어 - 권한 부여/회수, 세션 킬 등\t- GRANT - REVOLKE   "},{"title":"데이터품질관리 프레임워크​","type":1,"pageTitle":"DataBase 개요 4","url":"/blog/second/2023/02/15/DB개요4#데이터품질관리-프레임워크","content":"조직(1) \\ 대상\t데이터 값 (2)\t데이터 구조 (3)\t데이터 관리 프로세스 (4)CIO/EDA (개괄적 관점)\t데이터 관리 정책\t데이터 관리 정책\t데이터 관리 정책 DA (개념적 관점)\t표준 데이터\t개념 데이터 모델 데이터 참조 모델\t데이터 표준 관리 요구사항 관리 Modeler (논리적 관점)\t모델 데이터\t논리 데이터 모델\t데이터 모델 관리 데이터 흐름 관리 DBA (물리적 관점)\t관리 데이터\t물리 데이터 모델 데이터베이스\tDB 관리 DB 보안 관리 User (운용적 관점)\t업무 데이터\t사용자 View\t데이터 활용 관리 CIO: 최고정보책임자(最高情報責任者, Chief Information Officer)는 정보나 정보기술에 관한 최고의 임원을 말한다. CIO 등으로 부른다.EDA : EDA(Enterprise data architecture)는 IT 프로그램 및 정보 자산을 비즈니스 전략에 맞추도록 설계된 마스터 청사진 모음을 말합니다. EDA는 통합, 품질 향상 및 성공적인 데이터 전달을 안내하는 데 사용됩니다.DA : 데이터 분석 설계자, 오라클, DB2, MySQL ..등등과 같이 특정 DB만을 추구하지 않으며 데이터 아키텍쳐를 활용하여 데이터를 분석하고 설계를 하는 역할, 어떤 컬럼이 인덱스로 적합한지 확인하는 역할 "},{"title":"(1) 조직​","type":1,"pageTitle":"DataBase 개요 4","url":"/blog/second/2023/02/15/DB개요4#1-조직","content":"데이터 품질관리 및 유지를 위한 조직의 역활과 책임 정의 조직 및 R&amp;R 수립방향​ 데이터, 데이터 구조의 품질관리 및 데이터 보안을 위한 관리조직의 명확한 역활과 책임 관리데이터 관리 이슈 조정 및 해결을 위한 데이터 관리위원회 구성전사적 데이터 통합 관리를 위한 전담인역 배정 "},{"title":"(2) 데이터​","type":1,"pageTitle":"DataBase 개요 4","url":"/blog/second/2023/02/15/DB개요4#2-데이터","content":"기관 및 기업의 비젼 및 목표달성 위한 전산화된 또는 전산화가 필요한 데이터 "},{"title":"(3) 데이터 구조​","type":1,"pageTitle":"DataBase 개요 4","url":"/blog/second/2023/02/15/DB개요4#3-데이터-구조","content":"데이터가 담겨진 모양 / 틀데이터를 취급하는 관점 (View)에 따라 구조가 다름 "},{"title":"(4) 데이터 관리 프로세스​","type":1,"pageTitle":"DataBase 개요 4","url":"/blog/second/2023/02/15/DB개요4#4-데이터-관리-프로세스","content":"데이터 및 데이터 구조의 품질을 안정적으로 유지 개선하기 위한 활용으로 데이터 관점 절차와 조직의 역활을 포함함 관리프로세스 수립방향​ 데이터 및 데이터 구조를 일관성 있게 관리하고 업무생산성을 높일 수 있도록 프로세스 설계정보 요구사항의 추적관리를 위해 요구사항 발생 부터 DB 반영 및 데이터 검증 프로세스까지 고려하여 설계안정적 시스템 운영을 위한 데이터 및 데이터 구조변경에 따른 영향도 분석을 반드시 수행하도록 프로세스 설계  "},{"title":"품질관리 관점의 사용자 별 R&R​","type":1,"pageTitle":"DataBase 개요 4","url":"/blog/second/2023/02/15/DB개요4#품질관리-관점의-사용자-별-rr","content":"역활\t책임CIO/EDA\t- 데이터 관리 총괄 - 데이터 관리 정책 수립 - 데이터 관리자간 이슈사항 조정 DA\t- 전사 데이터 변경처리 총괄 - 전사 데이터 통합 모덜 관리 - 데이터 표준 개발 및 조정 Modeler\t- 해당기능 영역의 데이터 요구사랑 및 이슈사항 조정과 통합 - 해당 기능 영역의 비지니스 요건을 토대로 데이터 모델링 수행 - 표준 확인 및 적용 DBA\t- DB 디자인 - DB 와 데이터의 형상 관리 수행 - DB의 데이터 모델링 및 튜링, 보안 관리 User\t- 서비스되는 데이터 및 운영,분석 데이터에 대한 활용 - 데이터에 대한 추가 요건 요청 "},{"title":"DataBase 개요 5","type":0,"sectionRef":"#","url":"/blog/second/2023/02/16/DB개요5","content":"","keywords":""},{"title":"키 (Key)​","type":1,"pageTitle":"DataBase 개요 5","url":"/blog/second/2023/02/16/DB개요5#키-key","content":"키의 정의 릴레이션의 튜플을 유일하게 식별할수 있는 속성들의 집합유일하게 키를 꺼낼수 있어야 한다. 키의 특성 유일성: 릴레이션 내에서 유일최소성: 키가 둘 이상의 속성으로 구성 되었을 경우 하나의 속성을 제거하면 유일성 파괴 -&gt; 키는 모든 튜플을 유일하게 식별할 수 있는 최소의 속성들로 구성 키의 유형 (식별자) 유형\t개념\t예시슈퍼키\t유일성은 있으나 최소성은 없음\t[학번,이름,학과] 후보키\t유일성과 최소성 만족\t[학번], [이름, 학과] 기본키\t여러 후보키 중 하나 선점\t[학번],[이름, 학과] 준 선택 대체키\t후보키의 기본키 이외에 남은 키 기본키 대체 가눙\t기본키 - [학번] 대체기 - [이름, 학과] 외래키\t어느 한 릴레이션 속성의 집학이 다른 릴레이션의 기본키로 사용\t[학과코드], [이름, 확가코도, 학년]에서 학과코드 DB 설계시 최초는 키를 설계하는 것이다  "},{"title":"스키마에 대한 Key 결정 및 도출 과정​","type":1,"pageTitle":"DataBase 개요 5","url":"/blog/second/2023/02/16/DB개요5#스키마에-대한-key-결정-및-도출-과정","content":"loading...  "},{"title":"데이터 무결성​","type":1,"pageTitle":"DataBase 개요 5","url":"/blog/second/2023/02/16/DB개요5#데이터-무결성","content":""},{"title":"데이터 무결성의 정의​","type":1,"pageTitle":"DataBase 개요 5","url":"/blog/second/2023/02/16/DB개요5#데이터-무결성의-정의","content":"무효 갱신으로 부터 데이터를 보호 하여정확성,유효성, 일관성, 안정성을 유지하여는 성질 : 정유일안  "},{"title":"데이터베이스 무결성의 종류​","type":1,"pageTitle":"DataBase 개요 5","url":"/blog/second/2023/02/16/DB개요5#데이터베이스-무결성의-종류","content":"종류\t관련키\t설명게체 무결성\t기본키\t- 모든 게체는 식별자를 정의하고 그실별자 값은 NULL 값이 없이 게체 내에서 유일한 값이어야 함 참조 무결성\t외래키\t- 외래키 값은 키본키로 사용된 Relation 의 기본키 값이거나 널(NULL) 값일 것 속성 무결성\t컬럼\t- 지정된 데이터 형식 만족, CHAR, DATE 사용자 정의\t데이터\t- 사용자 업무 규칙(Business Rule) 정의 - CHECK, DEFAULT, 데이터베이스 트리거 등  "},{"title":"데이터 무결성 보장 방법​","type":1,"pageTitle":"DataBase 개요 5","url":"/blog/second/2023/02/16/DB개요5#데이터-무결성-보장-방법","content":"분류\t설명응용 프로그램\t데이터를 저작하는 프로그램 내에 무결성 저건을 검증하는 코드를 추가 트리거\t트리거(Trigger) 이벤트시 Procedure 를 실행하여 무결성 조건 실행 제약조건\t데이터 베이스 제약 조건 기능을 선언하고 무결성을 유지  "},{"title":"데이터 무결성 보장 방법간의 장단점 비교​","type":1,"pageTitle":"DataBase 개요 5","url":"/blog/second/2023/02/16/DB개요5#데이터-무결성-보장-방법간의-장단점-비교","content":"분류\t장점\t단점응용 프로그램 코드\t- 사용자 정의 같은 복잡한 무결성 조건의 구현 가능\t- 소스 코드에 분산되어 관리가 어려움 - 개별적 관리로 적정성 검토가 어려움 데이터베이스 트리거\t- 통합 관리가 가능함 - 복잡한 요건 구현 가능\t운영 중 변경이 어려움 제약조건\t- 통합관리가 가능함 - 간단한 선언으로 구현 가능 - 변경이 용이함 - 원칙적으로 오류 데이터 발생 억제\t- 복잡한 제약 조건 구현이 불가능함 - 예외적인 처리가 불가능 "},{"title":"DataBase 개요 6","type":0,"sectionRef":"#","url":"/blog/second/2023/02/16/DB개요6","content":"","keywords":""},{"title":"데이터 모델링의 정의​","type":1,"pageTitle":"DataBase 개요 6","url":"/blog/second/2023/02/16/DB개요6#데이터-모델링의-정의","content":"현실세계의 업무적인 프로세스를 추상화하여 물리적으로 데이터베이스화 하기위한 과정으로 실체와 관계를 중심으로 체계적으로 표현하고 문서화하는 기법정보 시스템의 중심을 데이터의 관점에서 접근하는 데이터 중심의 분석기법  "},{"title":"데이터 모델링의 주요 특성​","type":1,"pageTitle":"DataBase 개요 6","url":"/blog/second/2023/02/16/DB개요6#데이터-모델링의-주요-특성","content":"가명문추통이 구분\t내용가시화\t시스템을 현재 또는 TO-BE 모습으로 시각적으로 표현 명세화\t시스템의 구조화 행동을 명세화 할수 있음 문서화\t정보 시스템 요구 사항에 필요한 데이터를 문서화 함 추상화\t복잡한 현실 세계를 단순화 하여 이해가 가능하도록 함 통합성\t어플리케이션과 데이터의 통합이 가능함 이해성\t개발자들의 시스템에 대한 이해를 높이며 의사소통을 원활히 함.  "},{"title":"데이터 모델링의 단계​","type":1,"pageTitle":"DataBase 개요 6","url":"/blog/second/2023/02/16/DB개요6#데이터-모델링의-단계","content":"모델링\t설명요개논스물응보loading...\t단계\t설명개념적 설계\t- 데이터베이스에 저장될 데이터와 이 데이터가 준수해야 하는 제약조건들을 고 수준으로 기술하기 위해 사용 - 개념적 스키마란 DBMS 클래스나 특정 DBMS와 독립적인, 데이터베이스 구조에 대한 상의 수준에서의 기술을 의미함 - 개념적 모델이란 개념적으로 스키마를 기술하는데 사용하는 언어 - 이 단계는 주로 ER 모델을 이용하여 수행됨 논리적 설계\t- 데이터베이스 설계를 구현하기 위해 선정된 DBMS 클래스의 데이터 모델에 떠ㅏ른 논리적 스키마 생성. 예로 RDBMS는 ER 개념 스키마를 관계 데이터베이스 스키마로 변환 - 특정 DBMS에 종속되지 않음(예:RDBMS는 모두 관계형 모델 사용함) - 논리적 모델은 논리 스키마를 기술하기 위해 사용되는 언어 스키마 정제\t관계 데이터베이스 스키마에 있는 릴레이션을 분석하여 잠재적인 문제점을 파알하고 정제(정규화 이론 적용) 물리적 설계\t- 데이터를 효과적으로 접근하기 위해 사용하는 저장구조와 접근방법을 기술, 원하는 성능 기준에 맞도록 더 정제 - 즉정 DBMS 에 종속적이며, 보다 향상된 효과룰 위해 물리적 설계 시 선택한 결정이 논리적 스키마 구조에 영행을 미칠수 있음 응용 및 보안설계\t응용에 관계되는 게체들(사용자, 사용자 그룹등)의 접근 권한 정의  "},{"title":"개념적 데이터 모델링의 정의​","type":1,"pageTitle":"DataBase 개요 6","url":"/blog/second/2023/02/16/DB개요6#개념적-데이터-모델링의-정의","content":"해당 조직의 업무 요건을 충족하기 위해서 주제영역과 핵심 데이터 집합, 핵심 데이터 집합간의 관계를 정의하는 상위 수준의 개략적 데이터 설계 작업특정 DBMS나 하드웨어 증에 독립적인 개념적 스키마를 기술하는 과정 "},{"title":"개념적 데이터 모델링의 특징​","type":1,"pageTitle":"DataBase 개요 6","url":"/blog/second/2023/02/16/DB개요6#개념적-데이터-모델링의-특징","content":"사용자 업무적인 요건 중심 사용자 중심의 용어 사용 특정 DBMS 나 하드웨어 등에 독립적 ER(Entity-Relationship) Diagram, EER(Extended-ER) Diagram 으로 표현됨 EER : 컴퓨터 과학에서 향상된 개체 관계 ( EER ) 모델(또는 확장된 개체 관계 모델)은 데이터베이스 설계에 사용되는 원래 개체 관계 (ER) 모델에 대한 확장을 통합하는 상위 수준 또는 개념적 데이터 모델입니다 . 엔지니어링 설계 및 제조( CAD / CAM ), 통신 , 복잡한 소프트웨어 시스템 및 지리 정보 시스템 (GIS) 과 같은 보다 복잡한 데이터베이스에서 발견되는 속성 및 제약 조건을 보다 정확하게 반영하도록 개발되었습니다 .  "},{"title":"개념적 데이터 모델링 절차​","type":1,"pageTitle":"DataBase 개요 6","url":"/blog/second/2023/02/16/DB개요6#개념적-데이터-모델링-절차","content":"  "},{"title":"개념적 모델링 요소​","type":1,"pageTitle":"DataBase 개요 6","url":"/blog/second/2023/02/16/DB개요6#개념적-모델링-요소","content":"loading... "},{"title":"DataBase 개요 7","type":0,"sectionRef":"#","url":"/blog/second/2023/02/16/DB개요7","content":"","keywords":""},{"title":"E-R(Entity-Relation) 모델의 정의​","type":1,"pageTitle":"DataBase 개요 7","url":"/blog/second/2023/02/16/DB개요7#e-rentity-relation-모델의-정의","content":"데이터 베이스의 개념적 설계를 위해 가장 널리 사용되며, 실 세계의 데이터를 게체들과 그들간의 관계에 의하여 묘사하는 기법1976년 Peter Chan 에 의해 소개된 후로 더욱 일반화 되었음게체(entity), 관계(relationship), 속성(attributes)의 개념을 도입하여 현실세계를 개념적으로 표현하는 모델 "},{"title":"E-R 모델의 특징​","type":1,"pageTitle":"DataBase 개요 7","url":"/blog/second/2023/02/16/DB개요7#e-r-모델의-특징","content":"특정 DB 구조 독립적분석가, 개발자, 사용자에게 공통된 시각 제시의사소통 도구 활용  "},{"title":"E-R 모델의 구성요소​","type":1,"pageTitle":"DataBase 개요 7","url":"/blog/second/2023/02/16/DB개요7#e-r-모델의-구성요소","content":"구성요소\t표현\t설명게체 현실 세계 클래스 표현, 실 세계 존재 실체 관계 게체와 게체간 연관성 속성 게체 또는 관계의 기본적 성질 링크 게체타입과 속성을 연결 레이블 관게와 사상, 원소 수를 표현 일대일, 일대다, 다대다   "},{"title":"E-R 모델의 표기법​","type":1,"pageTitle":"DataBase 개요 7","url":"/blog/second/2023/02/16/DB개요7#e-r-모델의-표기법","content":"IE(Information Engineering): ERWin loading... Rechard Baker(Case Method) : DA#, Oracle Designer 출처 : https://cafe.naver.com/dbian    "},{"title":"E-R 모델링 단계​","type":1,"pageTitle":"DataBase 개요 7","url":"/blog/second/2023/02/16/DB개요7#e-r-모델링-단계","content":"loading... "},{"title":"E-R 모델의 한계성​","type":1,"pageTitle":"DataBase 개요 7","url":"/blog/second/2023/02/16/DB개요7#e-r-모델의-한계성","content":"단순하고 일반적 모델에 적합GIS, Mutimedia, 겍체지향 같은 응용 분야에서는 표현에 한계가 존재재사용, 상속 , 확장성의 개념이 없음 "},{"title":"E-R 모델의 한계 극복과 발전​","type":1,"pageTitle":"DataBase 개요 7","url":"/blog/second/2023/02/16/DB개요7#e-r-모델의-한계-극복과-발전","content":"한계점 극복을 위해 EER 사용 Super와 Sub type의 관계를 통한 일반화, 집단화, 특수화, 상속의 개념 등장 겍체지향 모델링 기법 도입 및 ERD 개념의 확장 활용이 필요멀티미디어 DB, OODB 등은 필수 불가결한 DB 추세OO(Object Oriented) Data 모델의 본격화 예상RDB 에서 처리하기 힘든 CAD/CAM, 멀티미디어 분야를 발판으로 성장 예상 "},{"title":"EER(Enhanced ER) 정의​","type":1,"pageTitle":"DataBase 개요 7","url":"/blog/second/2023/02/16/DB개요7#eerenhanced-er-정의","content":"복잡한 현실 세계를 표현하는데 있어서 E-R 모델의 한계를 극복하기 위해 특수화, 일반화, 집단화 등의 개념을 추가한 모델 EER 의 핵심 개념 구성요소\t주요 내용특수화 (Specialization)\t- 하나의 게체(Super type)를 몇 개의 Sub type 으로 분리 - 상위에서 하위 클래스를 분류하는 하향식(Top-down) 개념 - 상위 개체의 속성을 상속함(IS-A 관계) 일반화 (Generalization)\t- 몇 개의 개체집합을 합해서 상위의 한개체로 통합 - 하위에서 상위 클래스로 일반화라는 상향식(Bottom-up) 개념 - 특수화의 역방향(IS-A 관계) 집단화 (Aggregation)\t- 특수화(Specialzation)시 상위 개체의 개념을 하위 개체가 상속 - 단일상속/다중상속 상속 (Inhertance)\t- 단위 개체들을 하나로 묶어 상위 레벨의 복합 개체를 구성 - 집단화 개념을 이용할 경우, 중복되는 관계를 단순한 관계로 표현가능(IS-PART-OF 관계) "},{"title":"EER 모델링 사례​","type":1,"pageTitle":"DataBase 개요 7","url":"/blog/second/2023/02/16/DB개요7#eer-모델링-사례","content":"loading... "},{"title":"논리적 모델링의 정의​","type":1,"pageTitle":"DataBase 개요 7","url":"/blog/second/2023/02/16/DB개요7#논리적-모델링의-정의","content":"개념적 모델링 단계에서 정의된 개체, 속성, 관계를 목표 DBMS 에 맞게 논리적 데이터 구조로 변환하는 것 "},{"title":"논리적 모델링의 목적​","type":1,"pageTitle":"DataBase 개요 7","url":"/blog/second/2023/02/16/DB개요7#논리적-모델링의-목적","content":"논리적 모델에서 사용가능한 데이터의 구조와의 제약사항 모델화를 위한 기능들을 효과적으로 표현해당 비지니스에 대한 데이터 관점에서의 명확안 이해하고 사용자와의 명확한 의사소통을 위한 수단으로 활용전사 데이터에 대한 구조를 체계화하고 이를 통해 통합 데이터 Architecture 수립데이터의 일관성 및 정확성 유지를 위한 규칙 도출 "},{"title":"논리적 모델링 성공 요건​","type":1,"pageTitle":"DataBase 개요 7","url":"/blog/second/2023/02/16/DB개요7#논리적-모델링-성공-요건","content":"업무에 능통한 현업 상요자와 함꼐 데이터 모델링 진행데이터에 초점을 두고 모델링을 진행데이터의 구조와 무결성(Intergrity)을 필수 고려 필요정규화(Nomalization) 기법을 이용한 이상현상 방지 필요데이터 모델링을 지원하는 데이터 사전의 구축 "},{"title":"논리적 모델링 주요 활동​","type":1,"pageTitle":"DataBase 개요 7","url":"/blog/second/2023/02/16/DB개요7#논리적-모델링-주요-활동","content":"주요 활동\t내용속성 상세화 개념 데이터 모델링에서 추출된 Entity 속성의 검증 및 확정속성이 가질수 있는 동안 값에 대한 나열 개체 상세화\t식별자 확정 Entity에 대해 유일성을 식별할수 있는 주 식별 확장(Primary Key)부 식별(Alternate identifer), 외부 식별(Foreign identifer) 등 확장 정규화\t데이터 구조상의 있어 삽입, 삭제, 갱신의 이상현상 문제점 해결을 위해 정규화를 수행(1~5차 정규화 BCNF) M:M 관계\tM:M 관계인 Entity 의 관계를 1:M 관계로 해소 게체 무결성 규칙 정의 개체 무결성: 어떤 기본키 값이 NULL 값이 될수 없음참조 무결성: 관계 테이블의 외부 식별자(FK)는 관계테이블의 주 식별자 이어야 함 "},{"title":"논리적 모델링의 전환과정​","type":1,"pageTitle":"DataBase 개요 7","url":"/blog/second/2023/02/16/DB개요7#논리적-모델링의-전환과정","content":"단계\t내용Entity(테이블) 전환\t개념 모델링에서 Entity를 유일성으로 보장하는 기본 키를 지정하여 실제 데이터가 저장될 논리적 Relation 으로 전환 Relation(관계)\tEntity 간에 연결고리를 1:1 또는 1:M 형태로 전환 정규화 수행\t데이터 중복 저장, 이상현상 방지를 위해 1NF ~ BCNF 정규형까지 모두 만족하는지를 검사하고, 오류 발생시 이전 단계를 재검토 사용자 트랜잭션 검증\t도출된 논리적 데이터 모델이 사용자가 원하는 트랜잭션을 모두 만족시키는지를 확인함 ERD 검증\t수정 및 보완 해야 할 사항에 대하여 ERD 에 재반영 무결성 제약 정의\t관계형 DB 에서 무결성을 만족하기 위한 제약 조건을 설정 "},{"title":"E-R 모델의 관계형 모델로의 변환(사례)​","type":1,"pageTitle":"DataBase 개요 7","url":"/blog/second/2023/02/16/DB개요7#e-r-모델의-관계형-모델로의-변환사례","content":"loading... "},{"title":"관계형 데이터 모델​","type":1,"pageTitle":"DataBase 개요 7","url":"/blog/second/2023/02/16/DB개요7#관계형-데이터-모델","content":"모델의 기본구성요소가 릴레이션(relation) 인 모델로 1970년 IBM의 Codd 에 의해 처음제안됨릴레이션의 옅은 속성들을 나타내며 튜플(tuple)이라 불리는 릴레이션의 행들을 각 속성이 가지는 값들의 모임임데이터 중복의 최소화와 무결성(Data Intergrity) 보장  "},{"title":"속성과 도메인​","type":1,"pageTitle":"DataBase 개요 7","url":"/blog/second/2023/02/16/DB개요7#속성과-도메인","content":"구분\t내용\t예속성 (atturibute)\t- 데이터의 가장 작은 논리적 단위 - 더 분해되지 않는 원자 값 (Atomic Value) 만 허용\t- 학번 (SNO) - 이름(SNAME) 도메인 (Domain)\t- 속성이 취한수 있는 같은 타입의 모든 원자값의 집합 - 정의된 속성은 반드시 그 해당 도메인으로부터만 값을 취 할수 있음\t- 학번(SNO): 3자리 수 정수 - 이름(SNAME): 10자리 문자열 "},{"title":"릴레이션(Relation)의 구성​","type":1,"pageTitle":"DataBase 개요 7","url":"/blog/second/2023/02/16/DB개요7#릴레이션relation의-구성","content":"구분\t내용\t비고릴레이션 스킴 (Relation Scheme)\t- 릴레이션의 논리적 구조\t- 릴레이션 내포(Relation intension) 릴레이션 인스턴스 (Relation Instance)\t- 어느 한 시점의 릴레이션의 내용(상태) - 어느 한 시점에 릴레이션 R에 포함되어 있는 투플의 집합\t- 릴레이션 외면 (Relation Entension) "},{"title":"E-R 모델의 관계형 모델로의 변환 규칙​","type":1,"pageTitle":"DataBase 개요 7","url":"/blog/second/2023/02/16/DB개요7#e-r-모델의-관계형-모델로의-변환-규칙","content":"E-R 모델\t관계형 모델개체\t릴레이션 속성\t단일 속성\t속성 복합 속성\t복합 속성의 모든 성분들을 개 개의 속성으로 고려 또는 전채 복합 속성을 단일 속성으로 고려하는 방법 키 속성\t기본키 또는 보조키 관계\t1:1 양방향 완전관계\t두 릴레이션을 하나의 릴레이션으로 통합 1:1 한방향 완전관계\t부분관계 릴레이션의 PK를 완전관계 릴레이션의 FK로 적용 1:1 양방향 부분관계\t두 릴레이션의 PK만으로 수성된 릴레이션을 생성 1:N N측 완전관계\t1측 릴레이션의 PK를 N측 릴레이션의 FK 로 적용 M:N 관계\t두 릴레이션의 PK로 구성된 릴레이션을 생성, 새로운 릴레이션의 PK는 두 릴레이션의 PK를 결합하여 사용 "},{"title":"DataBase 개요 8","type":0,"sectionRef":"#","url":"/blog/second/2023/02/17/DB개요8","content":"","keywords":""},{"title":"물리적 데이터 모델링의 정의​","type":1,"pageTitle":"DataBase 개요 8","url":"/blog/second/2023/02/17/DB개요8#물리적-데이터-모델링의-정의","content":"논리 데이터 모델을 틀정 데이터베이스로 설계함으로써 생성된 데이터를 저장할수 있는 물리적인 스키마를 만드는 일련의 과정 "},{"title":"물리 데이터 모델링의 목적 및 효과​","type":1,"pageTitle":"DataBase 개요 8","url":"/blog/second/2023/02/17/DB개요8#물리-데이터-모델링의-목적-및-효과","content":"사전적으로 작성된 논리 데이터 모델을 각각의 관계형 DBMS 의 특성, 기능 , 성능 등을 고려함데이터의 저장공간 , 데이터의 분산, 데이터의 저장 방법등을 고려함잘 작성된 물리 데이터 모델은 데이터 베이스 운용 성능을 크게 향상 시킬수 있음 "},{"title":"물리적 모델링의 주요 Activity​","type":1,"pageTitle":"DataBase 개요 8","url":"/blog/second/2023/02/17/DB개요8#물리적-모델링의-주요-activity","content":"주요 Task\t설명1. 물리요소 조사 및 분석\tDBMS의 종류 및 버전, 운영체제에 대한 분석 2. 반 졍규화\t정규화된 Entity type, 속성, 관계를 시스템의 성능 향상, 개발과 운용을 단순화하기 위래 데이터 모델을 통합하는 프로세스 3.논리-물리 모델 변환\t논리 영영과 물리 영역을 보는 시각이 다르므로 논리 모델을 물리 모델로 변환해야함 "},{"title":"논리적 모델링과의 용어 비교​","type":1,"pageTitle":"DataBase 개요 8","url":"/blog/second/2023/02/17/DB개요8#논리적-모델링과의-용어-비교","content":"분석\t설계논리 데이터 모델링 (ER Model)\t물리 데이터 모델링(Physical Model) Entity\tTable Attribute\tColumn Primary UID\tPrimary Key Identifer\tKey Relationship\tForeign Key Table space, Index space "},{"title":"이상현상(Anomaly) 의 정의 ⭐️⭐️⭐️​","type":1,"pageTitle":"DataBase 개요 8","url":"/blog/second/2023/02/17/DB개요8#이상현상anomaly-의-정의-️️️","content":"이상현상(Anomaly) 의 정의 릴레이션의 데이터 중복 관리로 인해 데이터를 조작할때 발생하는 예기치 못한 결과를 초래하는 비 합리적 현상 이상현상(Anomaly)의 종류 종류\t설명\tAnomaly삽입 이상\t릴레이션내에 하나의 튜플을 삽입하려고 할때 불필요하고 원하지 않는 데이터까지 삽입해야 하는 현상\tInsertion 삭제 이상\t릴레이션내의 하나의 튜플을 삭제하려고 할때 유지되어야 할 정보까지 삭제되는 연쇄 삭제(Triggered Deletion) 현상\tDeletion 갱신 이상\t중복된 튜블 중에서 일부 튜플의 속성을 변경시키려고 할 때 정보의 모순성이 발생하는 현상\tUpdate "},{"title":"이상현상의 사례​","type":1,"pageTitle":"DataBase 개요 8","url":"/blog/second/2023/02/17/DB개요8#이상현상의-사례","content":"학번\t지도 교수\t학과\t과목번호\t성적100\t김경아\t컴퓨터\tDB\tA 100\t김경아\t컴퓨터\tOS\tB 101\t권현정\t전자\tCA\tA 102\t김경아\t컴퓨터\tDB\tC 102\t김경아\t컴퓨터\tOS\tA 102\t김경아\t컴퓨터\tSA\tA 103\t정동영\t컴퓨터\tDB\tC 103\t정동영\t컴퓨터\tOS\tA 103\t정동영\t컴퓨터\tSA\tA 103\t정동영\t컴퓨터\tIT\tB 삽입이상 : 특정 과목이 개설되었음에도 불구하고, 지도교수가 없어서 등록을 못하는 경우삭제이상: 학번이 101번은 과목 등록을 취소하면 학과, 지도교수 정보도 삭제갱신이상: 학번이 103인 삭생의 지도교수가 변경되면 4개의 튜플 변경 "},{"title":"이상 현상의 원인 및 해결​","type":1,"pageTitle":"DataBase 개요 8","url":"/blog/second/2023/02/17/DB개요8#이상-현상의-원인-및-해결","content":"속성들 간에 종속성(Dependency) 분석을 통해 기본적으로 하나의 종속성이 하나의 릴레이션으로 표현되도록 무손실 분해(Decomposition) 하면 됨 "},{"title":"함수적 종속성(Functional Dependency)의 개념​","type":1,"pageTitle":"DataBase 개요 8","url":"/blog/second/2023/02/17/DB개요8#함수적-종속성functional-dependency의-개념","content":"데이터 들이 어떤 기준 값에 의해 향상 종속되는 현상릴레이션의 한 속성 X 가 다른 속성 Y를 결정지을때 Y는 X에 함수적으로 종속되었다고 하며 R.X → R.Y 와 같이 표현X → Y 일경우 , X는 결정자(Determination) Y는 종속자(Dependent)로 망명 loading... "},{"title":"함수적 종속성의 종류​","type":1,"pageTitle":"DataBase 개요 8","url":"/blog/second/2023/02/17/DB개요8#함수적-종속성의-종류","content":"유형\t예시- 완전 함수적 종속성 [학번,과목번호] → 성적 (학번, 과목번호를 알아야 성적 확인가능) - 부분 함수적 종속성 학번 → 학과 (학번 혹은 과목번호 만 알아도 학과 확인가능)\tloading... 이행 함수적 종속성: 학번 → 지도교수 지도교수 → 학과 학번 → 학과 (학번이 지도교수를 결정지을수 있고 지도교수가 학과를 결정지을수 있으면 학번이 학과를 결정 지을수 있음)\tloading... - 결정자 함수적 종속성: 교수 → 과목 (교수가 키가 아님에도 불구하고 과목의 결정자 역활을 함)\tloading... "},{"title":"함수적 종속성 추론 규칙 (암스트롱의 공리(Axiom))​","type":1,"pageTitle":"DataBase 개요 8","url":"/blog/second/2023/02/17/DB개요8#함수적-종속성-추론-규칙-암스트롱의-공리axiom","content":"추론규칙\t내용재귀 규칙\t- Reflexivify Rule - Y⊆XY \\subseteq XY⊆X 이면 X→YX \\rightarrow YX→Y 이다 : Y 가 X에 포함 되어 있으면 X 는 Y의 결정자 이다. 증가 규칙\t- Augmentation Rule - X→YX \\rightarrow YX→Y 이면 XZ→YZXZ \\rightarrow YZXZ→YZ 이다 : X 가 Y를 결정 지을때 X 가 증가 되어도 동일하다. 이행 규칙\t- Transitive Rule - X→YX \\rightarrow YX→Y 이고 Y→ZY \\rightarrow ZY→Z 이면 X→ZX \\rightarrow ZX→Z 이다 : X 가 Y를 결정 지을수 있고 Y 가 Z를 결정 지을수 있을때 X 는 Z를 결정 지을수 있다. 연합 규칙\t- Union Rule - X→YX \\rightarrow YX→Y 이고 X→ZX \\rightarrow ZX→Z 이면 X→YZX \\rightarrow YZX→YZ 이다 : X 가 Y를 결정 지을수 있고 X 가 Z를 결정 지을수 있을때 X 는 연합된 Y와Z를 결정 짓는다. 분해 규칙\t- Decomposition Rule - X→YZX \\rightarrow YZX→YZ 이면 X→YX \\rightarrow YX→Y 이고 X→ZX \\rightarrow ZX→Z 이다 : X 는 연합된 Y와Z를 결정 지을때 X 가 Y를 결정 지을수 있고 X 가 Z를 결정 지을수 있다. 가이행 규칙\t- Pseuco Transitive Rule - X→YX \\rightarrow YX→Y 이고 WY→ZWY \\rightarrow ZWY→Z 이면 WX→ZWX \\rightarrow ZWX→Z 이다 : X 가 Y를 결정 지을수 있고 연합된 W 와 Y 가 Z를 결정 지을수 있을때 연합된 W 와 X 는 Z를 결정 지을수 있다. 재귀 규칙, 증가 규칙, 이행 규칙 : 기본 규칙연합 규칙, 분해 규칙, 가이행 규칙 : 확장 규칙 "},{"title":"DataBase 문제풀이","type":0,"sectionRef":"#","url":"/blog/second/2023/02/17/DB문제","content":"","keywords":""},{"title":"1번​","type":1,"pageTitle":"DataBase 문제풀이","url":"/blog/second/2023/02/17/DB문제#1번","content":"회복기법에 대한 설명으로 가장 거리가 먼것은? 지연 갱신 회복 기법은 트랜잭션이 부분 완료될때 까지 데이터베이스의 실제적인 갱신을 지연시킨다. 지연 갱신 회복 기법은 undo/redo 회복 알고리즘을 이용하여 회복한다. 즉시갱신(immediate update) 회복 기법은 트랜잭션이 갱신 명령을 내리면 트랜잭션이 완료되기 전에 데이터를 즉시 갱신한다. 그림자 페이지(shadow page) 회복기법은 redo 연산이 필요없기 때문에 장애로 부터 회복작업이 신속하다. 주어진 설명 중 회복 기법에 대한 설명이 아닌 항목은 2번입니다. 지연 갱신 회복 기법은 undo/redo 회복 알고리즘을 이용하여 회복하지만, 2번 항목은 undo/redo 회복 알고리즘에 대한 설명으로 문제와 관련이 없습니다. 따라서 2번이 가장 거리가 먼 항목입니다.  "},{"title":"2번​","type":1,"pageTitle":"DataBase 문제풀이","url":"/blog/second/2023/02/17/DB문제#2번","content":"2단계 로킹 규약(2phase locking protocol)의 로크 전환 (혹은 로크 변환)에 대한 설명중 옳은것은? 항목 X에 read_lock(X) 를 수행하여 공유 로크를 획득 한후 나중에 write_lock(X)를 수행하여 베타적 로크로 로크를 상승(upgrade)시킬수 있다. 항목 X에 write_lock(X) 를 수행하여 베타적 로크를 획득한후 나중에 read_lock(X)를 수행하여 공유 로크로 로크를 상승시킬수 있다. 항목 X에 read_lock(X) 를 수행하여 공유 로크를 획득한 후 나중에 write_lock(X) 를 수행하여 베타젃 로크로 로크를 하강시킬수 있다. 항목 X에 read_lock(X) 를 수행하여 베타적 로크를 획득한 후 나중에 wrrite_lock(X)를 수행하여 공유 로크로 로크를 하강시킬수 있다. 2단계 로킹 규약(2-phase locking protocol)의 로크 전환(혹은 로크 변환)에 대한 설명 중 옳은 것은 1번입니다. 2단계 로킹 규약에서는 트랜잭션이 얻은 로크(잠금)을 해제하기 전에 모든 로크를 획득한 후 반드시 모든 로크를 한 번에 해제해야 합니다. 따라서 1단계에서는 read_lock(X)를 수행하여 공유 로크를 획득하고, 나중에 2단계에서 write_lock(X)를 수행하여 베타적 로크로 로크를 상승시킬 수 있습니다. 2번, 3번, 4번은 모두 옳지 않은 설명입니다. 2번은 이미 베타적 로크를 획득한 후에 공유 로크로 변환하는 것은 불가능합니다. 3번은 이미 공유 로크를 획득한 후에 베타적 로크로 변환하는 것도 불가능합니다. 4번은 read_lock(X)를 획득한 후에 write_lock(X)로 로크를 상승시키는 것은 가능하지만, 그 다음에 공유 로크로 하강시키는 것은 불가능합니다.  "},{"title":"3번​","type":1,"pageTitle":"DataBase 문제풀이","url":"/blog/second/2023/02/17/DB문제#3번","content":"데이터베이스 시스템의 데이터 독립성에 대한 설명중 옳지 않는 것은? ANSI 3단계 스키마 아키텍쳐는 내부단계(내부스키마), 개념단계(개념스키마), 외부단계(외부스키마)로 나눈다. 3단계 스키마의 목적은 물리적 데이터베이스 로부터 사용자의 응용을 분리시키는 것이다. 외부스키마는 데이터베이스의 물리적 저장구조를, 개념스키마는 특정 사용자 그룹이 관심을 갖는 데이터베이스 부분을, 내부스키마는 모든 사용자를 위한 전체 데이터베이스 구조를 기술한다. 물지적 데이터 독립성은 개념스키마를 변경하지 않으면서 내부스키마를 변경할수 있음을 말한다. 내부 스키마의 접근 구조 변경이나, 파일 재구성이 개념 스키마에 가능한 한 영향을 주지 않도록 한다. 논리적 데이터 독립성은 외부스키마를 변경하지 않으면서 개념스키마를 변경하는 것을 말한다. 개념스키마의 데이터베이스 확장, 제약조건 갱신 등 변경이 외부스키마에 가능한 한 영향을 주지 않도록 한다. 1번 설명이 옳지 않습니다. ANSI 3단계 스키마 아키텍쳐의 목적은 논리적 데이터 독립성을 제공하기 위한 것입니다. 논리적 데이터 독립성은 개념스키마를 변경하지 않으면서 외부스키마를 변경할수 있음을 말합니다.  "},{"title":"4번​","type":1,"pageTitle":"DataBase 문제풀이","url":"/blog/second/2023/02/17/DB문제#4번","content":"버클리 대학의 Eric Brewer 교수가 발표한 CAP 이론은 분산 컴퓨팅 환경의 세 가지 특징을 정의 하고 있는데, NoSQL은 이중 한 두 가지 특징을 포기하는 대신 고성능, 확장성 등의 지원에 초점을 맞추고 있다. 여기서 CAP 이론의 세 가지 특징을 바르게 기술한 것은? C-Consistency, A-Atomicity, P-PersistencyC-Consistency, A-Atomicity, P-Partition ToleranceC-Consistency, A-Availability, P-Partition ToleranceC-Consistency, A-Availability, P-Persistency C-Consistency, A-Availability, P-Partition Tolerance  "},{"title":"5번​","type":1,"pageTitle":"DataBase 문제풀이","url":"/blog/second/2023/02/17/DB문제#5번","content":"데이터 품질에 관한 다음 설명 중 옳지 않은 것은? 데이터 품질은 조직의 목적 달성을 위하여 관리되는 데이터가 이용자의 만족을 총족시킬 수 있는 수준을 말한다.데이터 품질 관리는 조직이 운영하는 정보시스템을 활용하는 이용자의 기대를 만족시키기 위하여 수행하는 데이터 관리 활동이다.데이터 품질 진단의 종류 중 데이터 구조 진단은 데이터 관리 프로세스를 분석하여 문제점을 도출하고 이를 개선할 수 있는 핵심 업무 프로세스를 최적화한다.데이터 품질 진단을 위한 데이터 프로파일링은 데이터의 중요 정보와 통계 값을 수집하는 정보 분석 기법이다. 3번이 옳지 않은 설명입니다. 데이터 품질에 관한 설명은 다음과 같습니다. 데이터 품질은 조직의 목적 달성을 위하여 관리되는 데이터가 이용자의 만족을 총족시킬 수 있는 수준을 말합니다.데이터 품질 관리는 조직이 운영하는 정보시스템을 활용하는 이용자의 기대를 만족시키기 위하여 수행하는 데이터 관리 활동입니다.데이터 품질 진단의 종류 중 데이터 구조 진단은 데이터 구조 자체에 대한 진단으로, 데이터 구조가 정확하고 일관성이 있는지 등을 분석합니다.데이터 품질 진단을 위한 데이터 프로파일링은 데이터의 특성을 분석하여 중복값, 결측값, 이상치 등의 문제점을 파악하고 개선할 수 있는 방안을 도출하는 정보 분석 기법입니다. 따라서, 3번의 설명은 데이터 구조 진단과 데이터 관리 프로세스 최적화를 혼동한 것으로 옳지 않습니다.  "},{"title":"6번​","type":1,"pageTitle":"DataBase 문제풀이","url":"/blog/second/2023/02/17/DB문제#6번","content":"다음은 데이터베이스 시스템의 3-층 구조(3-tier architecture)에 대한 설명이다. 가 와 나에 들어갈 용어로 가장 적합한것은? 3-층구조는 2-층 구조(2-tier architecture)를 구성하는 클라이언트와 데이터베이스 서버 사이에 중간 단계를 하나 더 추가한 것이다. 중간 단계는 일반적으로 (가)라 부르며 (나)을 처리한다. 가: 응용 (프로그램) 서버 , 나 : 함수형 프로그램가: 응용 (프로그램) 서버 , 나 : 비지니스 로직가: 클라우드 (프로그램) 서버, 나: 함수형 프로그램가: 클라우드 (프로그램) 서버, 나: 비지니스 로직 3-층 구조는 2-층 구조를 구성하는 클라이언트와 데이터베이스 서버 사이에 중간 단계를 하나 더 추가한 것이며, 일반적으로 가: 응용 (프로그램) 서버, 나: 비지니스 로직을 처리합니다. 따라서 정답은 &quot;2. 가: 응용 (프로그램) 서버, 나: 비지니스 로직&quot;입니다.  "},{"title":"7번​","type":1,"pageTitle":"DataBase 문제풀이","url":"/blog/second/2023/02/17/DB문제#7번","content":"낙관적 동시적 제어 (optimistic concurrency control) 에서 각 트랜젝션은 세 가지 단계로 실행되는데, 그 단 계를 순서대로 바르게 나열한 것은? 읽기 단계(read phase) - 검증 단계(validation phase) - 쓰기 단계(write phase)갱신 단계(update phase) - 검증 단계 (validation phase) - 종료 단계(commit phase)갱신 단계(update phase) - 종료 단계(commit phase) - 검증 단계 (validation phase)읽기 단계(read phase) - 쓰기 단계(write phase) - 검증 단계(validation phase) 낙관적 동시성 제어(Optimistic Concurrency Control)에서 각 트랜잭션은 세 가지 단계로 실행됩니다. 첫 번째는 읽기 단계(read phase)이며, 각 트랜잭션은 데이터를 읽고 로컬 복사본을 만듭니다. 두 번째는 갱신 단계(update phase)이며, 각 트랜잭션은 로컬 복사본을 사용하여 작업을 수행합니다. 세 번째는 검증 단계(validation phase)이며, 각 트랜잭션은 작업이 다른 트랜잭션에 의해 변경되지 않았는지 확인합니다. 따라서 정답은 1. 읽기 단계(read phase) - 검증 단계(validation phase) - 쓰기 단계(write phase)입니다.  "},{"title":"8번​","type":1,"pageTitle":"DataBase 문제풀이","url":"/blog/second/2023/02/17/DB문제#8번","content":"데이터 모델링의 4단계에 대하여 설명하시오. 데이터 모델링은 현실 세계의 개체(Entity)와 개체 간의 관계(Relationship)를 데이터베이스 구조로 표현하는 과정입니다. 데이터 모델링의 주요 단계는 다음과 같습니다. 요구사항 수집과 분석 (Requirements Gathering and Analysis) 단계: 시스템이나 애플리케이션에서 필요로 하는 데이터 요구사항을 수집하고 분석하여 명확하고 완전한 요구사항을 도출합니다. 개념적 모델링 (Conceptual Modeling) 단계: 요구사항 수집 단계에서 얻은 개체(Entity)와 관계(Relationship)를 이용하여 개념적 모델을 설계합니다. 이 단계에서는 엔티티(Entity)와 엔티티 간의 관계를 ER(Entity Relationship) 다이어그램으로 표현합니다. 논리적 모델링 (Logical Modeling) 단계: 개념적 모델링 단계에서 만든 ER 다이어그램을 바탕으로 테이블(Table)과 관계를 설계합니다. 이 단계에서는 테이블 정의서 및 관계 정의서 등의 문서를 작성하고, ER 다이어그램을 논리적 모델로 변환하여 ERD(Entity Relationship Diagram)를 만듭니다. 물리적 모델링 (Physical Modeling) 단계: 논리적 모델링 단계에서 만든 ERD를 바탕으로 실제 데이터베이스 시스템에서 사용할 수 있는 물리적 스키마를 설계합니다. 이 단계에서는 테이블 생성 스크립트, 인덱스 생성 스크립트, 제약조건 생성 스크립트 등을 작성합니다. 또한, 성능과 보안 등을 고려하여 물리적 모델을 최적화합니다.  "},{"title":"9번​","type":1,"pageTitle":"DataBase 문제풀이","url":"/blog/second/2023/02/17/DB문제#9번","content":"DB이상현상(Anomaly) 에 대하여 설명 하시오 DB이상현상(Anomaly)이란, 데이터베이스 설계가 비정규화(normalization)되어 있지 않거나, 테이블 구조나 관계 설정 등이 잘못된 경우 발생할 수 있는 문제입니다. 이상현상은 데이터베이스의 일관성, 정확성, 무결성 등을 해치기 때문에 데이터베이스의 효율성과 안전성에 영향을 미칠 수 있습니다. 주요한 이상현상으로는 다음과 같은 것이 있습니다. 삽입 이상 (Insertion Anomaly) : 새로운 데이터를 삽입할 때, 반드시 다른 속성들과 함께 삽입해야 하는 경우가 있어, 삽입 시 불필요한 데이터가 중복될 수 있고, 이로 인해 공간 낭비와 데이터 불일치 문제가 발생합니다.삭제 이상 (Deletion Anomaly) : 특정 데이터를 삭제할 때, 그 데이터와 관련된 다른 데이터도 함께 삭제되는 문제가 발생합니다.갱신 이상 (Update Anomaly) : 데이터 중 일부를 수정하려 할 때, 일부 데이터만 수정되어 데이터 불일치 문제가 발생합니다. 이러한 이상현상을 방지하기 위해서는 데이터베이스 설계 단계에서 정규화(normalization) 과정을 거쳐야 합니다. 정규화는 중복을 최소화하고, 데이터의 일관성과 무결성을 보장하기 위한 과정으로, 데이터를 적절한 논리적 구조로 분해하는 작업입니다.  "},{"title":"10번​","type":1,"pageTitle":"DataBase 문제풀이","url":"/blog/second/2023/02/17/DB문제#10번","content":"DB 옵티마이저 (DB Optimizer: DB 질의 최적화기) DB 옵티마이저는 데이터베이스 시스템에서 사용자가 입력한 SQL 쿼리를 가장 빠르고 효율적인 방식으로 처리하기 위해 실행 계획을 최적화하는 역할을 합니다. 즉, 사용자가 요청한 데이터에 대해 가장 효율적으로 접근할 수 있는 방법을 찾아내는 것입니다. DB 옵티마이저는 데이터베이스 시스템의 내부 데이터 구조, 인덱스, 통계 정보, 하드웨어 자원 등을 고려하여 여러 실행 계획을 생성하고, 그 중에서 가장 효율적인 실행 계획을 선택합니다. 이를 위해 DB 옵티마이저는 SQL 쿼리의 조인, 필터링, 정렬 등의 연산 비용을 계산하고, 인덱스를 사용할 수 있는 경우와 전체 테이블 스캔을 수행해야 하는 경우를 판단하여 적절한 실행 계획을 선택합니다. DB 옵티마이저는 데이터베이스 시스템의 성능에 큰 영향을 미치기 때문에, 최신 기술과 알고리즘을 적용하여 실행 계획을 최적화하는 것이 중요합니다. 또한, DB 옵티마이저는 데이터베이스 시스템의 성능을 최적화하기 위해 정기적으로 수행되는 통계 정보 수집 작업과 같은 관리 작업도 수행합니다. "},{"title":"정보보안 기초 1","type":0,"sectionRef":"#","url":"/blog/second/2023/02/18/정보보안기초1","content":"","keywords":""},{"title":"정보​","type":1,"pageTitle":"정보보안 기초 1","url":"/blog/second/2023/02/18/정보보안기초1#정보","content":"교시형 : 13 문제 서술형 : 6문제 실무 사례도 제시됨, 왜 필요한지, 세부사항, 증빙에 문제점 -&gt; 해결책을 제시 하는 문제 법률 : 데이터 상법, 개인정보 보호법, 정보통신망법, 신용정보 관리법 규제 , 근거 가되는 기준이 법에 의존하기 때문에 알아야함표준이 됨 : ISO 27001 , ISMS-P ISMS-P 인증기준 안내서 정독 1페이지에 7분정도 시간이 소요됨 장기적인 싸움이 됨 (마라톤) 집에 가서 할일 5년치 기출문제를 분석해야 해야됨 방향성을 잡고 선택과 집중을 할수 있도록 한다. 1교시 문제일때 출제자가 기술사인지, 교수인인지 파악을 한다. 2,3,4 교시에 같은 패턴으로 출제 가능성이 있음 출근 때마다 토픽을 연습해야 한다. 답안 제출시 오답 수정시 탈락이 가능성이 있음 "},{"title":"정보보안의 개념​","type":1,"pageTitle":"정보보안 기초 1","url":"/blog/second/2023/02/18/정보보안기초1#정보보안의-개념","content":"외부의 악의적인 해킹이나 내부의 불법적 정보 유출시도로 부터 조직과 고객의 정보자산을 보호하기 위한 관리적, 물리적, 기술적 대응 체계 정의 연습 5W 1H : ~ 목적 ~ 기술을 이용 ~ 종결명사 (PK)X ~ 하는 것 문장은 쓰면안된다 : 점수 안줌 위험을 수용 가능한 수준으로 감소시키는 일련의 조치 Risk = (Asset) XXX (vulnerability) XXX (Threat) 위험 = 영향도 * 확룰 * 취약 리스크는 자산이라고도 한다. 영향도는 취약점 구분\t설명\t핵심요소기밀성 (Confidentiality)\t내외로 부터 불법적 정보 유츨의 방지 해당 정보에 대한 권한이 부여된 자들만이 접근가능하도록 보장\t암호화, 접근 통제 무결성 (Integrity)\t정보의 위변조 및 파괴를 예방하고 방지 원천 데이터나 사용자가 원하는 정보나 시스템에 적시에 접근 보장 서버에 로그를 적재시 위변조 방지를 위하여 별도의 저장소 또는 헤시값을 부여하여 무결성을 보장한다.\t보안관제, 이중화 가용성 (Availability)\t해킹으로 안한 시스템 동작 불능 예방 인가된 사용자가 원하는 정보나 시스템이 적시에 접근 보장\t보안관제, 이중화 인증 (Authentication)\t정보나 시스템에 접근하는 사용자가 정당함을 확인 알고 있는 것, 가지고 있는것 , 신체의 일부(지문)\tPKI, 생체인증 부인방지 (Non-Repudiation)\t행위를 부인하는 것을 봉쇄\t전자 서명 사례를 적시하면 좋음 "},{"title":"OWASP 10 대 취약점​","type":1,"pageTitle":"정보보안 기초 1","url":"/blog/second/2023/02/18/정보보안기초1#owasp-10-대-취약점","content":"OWASP 개인과 기업이 Application 을 신뢰성 있게 개발, 구매, 유지가능하도록 보장하기 위한 개방적 커뮤니티주기적으로 웹 취약점을 발표하고 있으며 2010 년에 이어 최근 2012 Top 10 취약점을 발표 OWASP 의 위협 평가 방법 위협원\t공격경로\t공격이 전파된 정도\t취약점 탐지 용이도\t기술적 결함\t비지니스적 영향\t쉬움\t널리 전파됨\t쉬움\t심각 현업 업무 분석 Biz Impact Analysis 보통\t보통\t보통\t보통 여러움\t드물게 전파됨\t어려움\t적음 각각의 환경과 비지니스적 틍성은 관련당사자들만 알수 있으므로, 위협 평가는 각자의 몫임 "},{"title":"OWASP Top 10 취약점 (2013 -> 2017)​","type":1,"pageTitle":"정보보안 기초 1","url":"/blog/second/2023/02/18/정보보안기초1#owasp-top-10-취약점-2013---2017","content":"OWASP 2013\t➡️\tOWASP 2017\tOWASP 20211. 인젝션\t➡️\t1. 인젝션\t접근 제어 문제 2. 취약점 인증과 세션 관리 취약한 인증\t암호 문제 3. 크로스 사이트 스크립팅 민감한 데이터 노출\t인젝션 4. 안전하지 않은 직접 겍체 참조 XML 외부게체 (XXE)\t비보호 설계 5. 잘못된 보안 구성 취약한 접근통제\t보안 구성오류 6.민감한 데이터 유츌 잘못된 보안 구성\t알려진 취약점이 있는 구성요소 사용 7. 기능 수준의 접근 통제 누락 크로스 사이트 스크립팅\t신원파악 및 인증 문제 8.크로스 사이트 요청 변조 안전하지 않은 역 직렬화\t소프트웨어 및 데이터 무결성 문제 9.알려진 취약점이 있는 구성요소 사용 알려진 취약점이 있는 구성요소 사용\t보안 로깅 및 모니터링 문제 10.검증되지 않은 리다이렉트 및 포워드 불충분한 로깅 및 모니터링\t서버측 요청 위조(SSRF) "},{"title":"정보 보호 대상 (자산)​","type":1,"pageTitle":"정보보안 기초 1","url":"/blog/second/2023/02/18/정보보안기초1#정보-보호-대상-자산","content":"정보보안대상\t데이터 저장장치\t호스트 컴퓨터 응용프로그램\t유선망 무선망 위성통신망\t교환기 라우터\t전화기, Fax, Pc, W/S\t카드  "},{"title":"정보 보안 위협​","type":1,"pageTitle":"정보보안 기초 1","url":"/blog/second/2023/02/18/정보보안기초1#정보-보안-위협","content":"정보보안 위협은 전략적이고, 지능화 되어 가고 있음 전략적 민첩하게 공격 : Zero Day Attack다양한 수단 활용 : 악성코드, 피싱, 파밍, 스팸 (사회공학)선의의 공격자 / 피해자 : Ddos 지능화 "},{"title":"정보보호 통제 활용​","type":1,"pageTitle":"정보보안 기초 1","url":"/blog/second/2023/02/18/정보보안기초1#정보보호-통제-활용","content":"정보보호 통제 정의 위험을 감소시키기 위한 정책, 절차, 기술, 조직 구성 등 일련의 활동 정보보호 통제 유형 유형\t설명\t예시예방통제 (4가지중 비용이 적은 부분)\t-문제가 발생하기 전에 탐지 - 오류, 누락 혹은 악의적 행위 발생 예방\t- 자격을 갖춘 직원만 고용 및 직무 분리 적발통제\t발생한 오류, 누락,또는 악의적 행위 참자하고 보고\t모니터링 (모니터링 시나리오가 필요) 교정/복원통제\t-문제 원인을 파악하여 문제로 부터 발생되는 오류 고정\t- BCP, 백업 저지 통제\t-위험을 단냠하도록 하는 시스템 도구 절차\t-법/제도 , 모의훈련 -IPX, 필터링, DLP 전체적인 통제 비용을 최소화 하기 위한 전략 수립 중용 "},{"title":"CC 인증​","type":1,"pageTitle":"정보보안 기초 1","url":"/blog/second/2023/02/18/정보보안기초1#cc-인증","content":"ISO 15408 CC인증의 개념 국가마다 서로 다른 정보보호시스템 평가 기준을 연동하고 평가결과를 상호 인증하기 위해 제정된 평가기준국제표준으로 1999년 6월 승인됨 목적 정보보호 시스템 보안등급 평가에 신뢰성 부여현존하는 쳥가기준과 조화를 통해 평가결과의 상호 인정정보보호 시스템의 수출입에 소요되는 인증 비용 절감으로 국제 유통 추진 CC의 구조 1부. 소개및 일반모델\t- IT 보안성 평가의 원칙과 개념 정의2부. 보안 기능 요구사항 3부. 보증 요구사항 CC 인증의 핵심 PR 와 ST 구분\tPP\tST개념 목적 독립성 적용성 관계성 완전성 예시  PP,ST, TOE 에 대한 단어가 꼭 들어 가야 한다. CC인증 과정 단계\t명칭\t예시EAL1\t- 기능적 시험\t- 기능 명세서, 설계서 EAL2\t- 구조적 시험\t- 기본설계서, 기능시험서, 취약점분석서 EAL3\t- 방법론적 시험, 점검\t- 생명주기 지원, 개발 보안 , 오용 분석서 EAL4\t- 방법론적 설계, 시험, 점검\t- 상세설게서, 보안정책서, 일부 소스코드, 상세시험서 EAL5\t- 준정형적 설계, 시험\t- 보안 기능 / 전체 소스코드. 구조 명세서, 은닉채널 분석서 EAL6\t- 준정형적 검증된 설계, 시험\t- 보안 기능 / 전체 소스코드. 구조 명세서, 은닉채널 분석서 EAL7\t- 정형적 검증\t- 보안 기능 / 전체 소스코드. 구조 명세서, 은닉채널 분석서 "},{"title":"ISO 27001​","type":1,"pageTitle":"정보보안 기초 1","url":"/blog/second/2023/02/18/정보보안기초1#iso-27001","content":"ISO/IEC 27001 정의 국제표준화 기구에서 정보보호관리를 위해 제장한 표준화된 실무규약 정보보호관리체계(ISMS-P) 국제표준의 필요성 정보보호대책 강화 : 크고 복잡한 조직에 대한 쳬계적인 접근방법 미비 "},{"title":"sso​","type":1,"pageTitle":"정보보안 기초 1","url":"/blog/second/2023/02/18/정보보안기초1#sso","content":"sso 인증 모델 인증대행인증 정보 전달 sso 의 한계정 보안측면 한번의 해킹으로 모든 애플리케이션 접근가능 접근제어 측면 인증된 사용자가 할당된 기느만 사용할수 있도록 관리 측면 사용자 관리기능, 권한 위임 및 변경에 대한 처리 불가 "},{"title":"SAML​","type":1,"pageTitle":"정보보안 기초 1","url":"/blog/second/2023/02/18/정보보안기초1#saml","content":"SAML 클라이언트의 인증정보 속성정보 인가정보를 기술하여 웹 브라우저에서 SSO 를 구현하는 XML 기반의 언어 SAML 구성 "},{"title":"AAA​","type":1,"pageTitle":"정보보안 기초 1","url":"/blog/second/2023/02/18/정보보안기초1#aaa","content":"AAA 의 프로토콜의 개념 유무선 환경에서 인증. 권장 "},{"title":"정보보안 문제","type":0,"sectionRef":"#","url":"/blog/second/2023/02/19/정보보안문제","content":"","keywords":""},{"title":"1​","type":1,"pageTitle":"정보보안 문제","url":"/blog/second/2023/02/19/정보보안문제#1","content":"SSL 에관한 설명중 틀린것은 SSL 레코드 프로토콜은 기밀성과 메세지 무결성, 부인 방지 서비스를 제공한다.SSL 레코드 프로토콜은 단편화, 압축 , 메세지 인증 코드 계산, 암호화의 순서로 수행된다.SSL은 TCP를 이용하여 신뢰할수 있는 종단-대종단 보안 서비스를 제공하기 위해 설계되었다.경고(Alert) 프로토콜은 SSL 관련 경고를 전달하기 위해 사용된다. 답 2번이 틀린 설명입니다. SSL 레코드 프로토콜은 압축, 단편화, 메시지 인증 코드(MAC) 계산, 암호화 순서로 수행됩니다. MAC 계산 단계는 인증과 무결성 보호를 위해 필요한 단계입니다. 단편화는 SSL 레코드 프로토콜에서 수행하는 것이 아니라 TCP에서 수행됩니다.   "},{"title":"2​","type":1,"pageTitle":"정보보안 문제","url":"/blog/second/2023/02/19/정보보안문제#2","content":"포렌식을 통해 획득한 증거는 법적인 효력을 가져야할 필요가 있다. 포렌식의 기본원칙에 대한 설명중 가장 거리가 먼것은 재현의 원칙: 증거를 복구하는 과정에서 똑같은 환경에서 같은 결과가 나오도록 재현할수 있어야함.신속성의 원칙: 시스템안의 디스크 또는 메모리 정보가 휘발되기 전에 빠르게 획득하여야 함.정당성의 원칙: 모든증거는 적법한 절차를 거쳐서 획득하여야 함.무결성의 원칙: 증거의 이송/분석/보관/법정 제출 이라는 일련의 과정에 대한 추적이 가능해야함 답 설명중 가장 거리가 먼 것은 4번인 &quot;무결성의 원칙: 증거의 이송/분석/보관/법정 제출 이라는 일련의 과정에 대한 추적이 가능해야함&quot;입니다. 포렌식의 기본 원칙 중 무결성의 원칙은 증거가 손상되지 않도록, 증거의 변조 및 파손을 막는 것을 의미합니다. 따라서 4번 설명은 맞습니다. 다른 원칙에 대한 설명은 다음과 같습니다. 1. 재현의 원칙: 증거를 복구하는 과정에서 똑같은 환경에서 같은 결과가 나오도록 재현할 수 있어야 함. 2. 신속성의 원칙: 시스템 안의 디스크 또는 메모리 정보가 휘발되기 전에 빠르게 획득하여야 함. 3. 정당성의 원칙: 모든 증거는 적법한 절차를 거쳐서 획득하여야 함.   "},{"title":"3​","type":1,"pageTitle":"정보보안 문제","url":"/blog/second/2023/02/19/정보보안문제#3","content":"다음 생체인식의 정확도를 측정하는 매게변수 중 인식되어서는 안될사람이 얼마나 자주 시스템에 의해서 인식되는지를 나타내는 것은 정상 거부율부정 거부율정상 허용율부정 허용율 답 다음 생체인식의 정확도를 측정하는 매개변수 중 인식되어서는 안될 사람이 얼마나 자주 시스템에 의해서 인식되는지를 나타내는 것은 &quot;부정 허용율(False Acceptance Rate, FAR)&quot;입니다.  "},{"title":"4​","type":1,"pageTitle":"정보보안 문제","url":"/blog/second/2023/02/19/정보보안문제#4","content":"다음 설명과 가장 관련이 있는 것은 기업에 물리적 설비, 전력, 난방, 통풍 및 온도 조절기 등을 제공하는 백업설비로 조작이 이를 이용할 경우 다른 백업 설비보다 비용이 적게 드는 장점을 가진다. 콜드 사이트IDC핫 사이트기업간 사이트 공유 답 콜드 사이트(Cold Site)와 관련이 있습니다. 콜드 사이트는 재해 발생시 신속하게 업무를 복구하기 위해 물리적인 시설, 전력, 난방, 통풍 및 온도 조절기 등이 설치되어 있지만 실제 운용중인 시스템은 없는 상태를 말합니다. 이를 이용하면 다른 백업 설비보다는 비용이 적게 들지만, 업무를 복구하기 위해 시스템을 구축해야 하므로 기간이 걸리는 단점이 있습니다. IDC(데이터 센터)는 기업이나 단체에서 보유하고 있는 서버와 스토리지 등 IT자원을 안정적으로 보관·운영할 수 있는 시설이며, 핫 사이트는 실제로 업무를 운영 중인 시스템을 대체하기 위한 백업 시스템으로, 공간, 시설, 시스템 등 모든 것이 준비되어 있어 대략 24시간 내에 업무를 복구할 수 있는 시스템입니다. 기업간 사이트 공유는 여러 기업이나 단체들이 공동으로 IT 자원을 운영하는 방식을 말합니다.   "},{"title":"5​","type":1,"pageTitle":"정보보안 문제","url":"/blog/second/2023/02/19/정보보안문제#5","content":"다음중 TCP 프로토콜의 3-way handshake 취약점을 이용하는 공격은 어느것인가 FraggleSession JijackingARP SpoofingDNS Spofing 답 TCP 프로토콜의 3-way handshake 취약점을 이용하는 공격은 '2. Session Hijacking'입니다. 이 공격은 공격자가 통신 중인 두 호스트 사이의 연결을 가로채어, 연결을 이어가는 것으로 가장하고 데이터를 변경하거나 도용할 수 있는 공격입니다.   "},{"title":"6​","type":1,"pageTitle":"정보보안 문제","url":"/blog/second/2023/02/19/정보보안문제#6","content":"sql injection 공격에 대한 설명으로 가장 거리가 먼것은 웹 어플리케이션이 사용자 입력값에 대한 검증을 하지 않는 취약점을 이용한 공격이다.게시판에 악성스크립트를 삽입한다.웹 브라우저를 통해 임의의 sql 문장을 삽입하여 에러를 노출하거나 인가되지 않은 데이터베이스의 데이터를 조회할수 있다.ids에 사용자 정의 패턴을 삽입하여 sql injection을 탐지할수 있다. 답 4 번 ids에 사용자 정의 패턴을 삽입하여 sql injection을 탐지할수 있다는 것이 가장 거리가 먼 것입니다. SQL Injection 공격을 탐지하기 위해서는 특정 패턴이 아닌, 웹 어플리케이션에서 발생하는 쿼리문 자체의 구조적인 문제를 탐지하는 방법이 일반적으로 사용됩니다. 패턴 기반의 탐지는 취약점이 발견된 경우, 이미 공격이 성공한 후에 탐지할 수 있기 때문에 적극적인 대응이 어렵습니다.  "},{"title":"7​","type":1,"pageTitle":"정보보안 문제","url":"/blog/second/2023/02/19/정보보안문제#7","content":"악성스크립트 파일을 업로드하여 공격하는 것을 예방하기 위한 java 상에서 안전한 코딩기법과 거리가 먼것을 모두 고르시오 (2개선택) 업로드 하는 파일 타입과 크기를 제한하고 업로드 디렉토리를 웹 서버 도큐먼트 내부에 설정preparedStatement 클래스를 사용하여 파일이 실행가능한 명령어로 변경되는것을 방지화이트리스트방식으로 허용된 확장자만 업로드를 허용하고 확장자는 대소문자 구분없이 처리공격자의 웹을 통한 직접 접근을 차단하고 파일 실행여부를 설정할수 있는 경우에 실행 속성을 제거 답 1번과 4번이 거리가 먼 답안입니다. 1번은 파일 타입과 크기를 제한하는 것은 보안상 좋은 방법이지만, 업로드 디렉토리를 웹 서버 도큐먼트 내부에 설정하는 것은 위험할 수 있습니다. 업로드된 파일이 웹 서버에서 실행 가능한 스크립트일 경우, 업로드된 파일이 실행되어 보안상 문제가 발생할 수 있기 때문입니다. 4번은 공격자의 직접 접근 차단과 실행 속성 제거는 파일에 대한 보안을 강화하는 좋은 방법입니다. 그러나, 이 방법만으로는 악성스크립트 파일을 업로드하여 공격하는 것을 예방할 수 없습니다.   "},{"title":"8​","type":1,"pageTitle":"정보보안 문제","url":"/blog/second/2023/02/19/정보보안문제#8","content":"다음 설명에 가장 적절한 접근 통제 방법은 기존에 접근통제에서는 모든 사용자 개개인의 접근통제 규칙을 보유하였지만 이것이 효율적이지 못할 뿐만 아니라 때로 보안 사고의 원인이 되었다 따라서 보안 관리자는 시스템에 접근하는 사용자들을 직책 및 보직을 기반으로 통제 하고자 한다. 임의적 접근통제강제적 접근통제역활기반 접근통제다계층 접근통제 답 역할기반 접근통제 (Role-based Access Control, RBAC)  "},{"title":"9​","type":1,"pageTitle":"정보보안 문제","url":"/blog/second/2023/02/19/정보보안문제#9","content":"크로스 사이트 스크립트(XSS) 에대하여 설명하시요 답 크로스 사이트 스크립트(XSS)는 웹 어플리케이션 취약점 중 하나로, 공격자가 악성 스크립트를 삽입하여 웹사이트 측에서 이를 실행하도록 유도함으로써 공격자가 의도한 대로 동작하게 만드는 공격 기법입니다. 일반적으로, XSS는 웹사이트에 입력된 값을 검증하지 않거나, 검증을 하되 적절한 에스케이프 처리를 하지 않는 경우 발생합니다. 이를 통해 공격자는 해커가 작성한 스크립트를 이용해, 다른 사용자들의 쿠키 정보, 세션ID, 또는 다른 민감한 정보를 탈취할 수 있습니다. XSS 공격은 Reflected XSS, Stored XSS, DOM-based XSS 등으로 나뉩니다. Reflected XSS는 사용자의 입력값을 서버에서 처리한 결과를 돌려줄 때 발생하는 공격이며, Stored XSS는 서버에 악성 스크립트를 저장해 사용자가 접근할 때 실행되는 공격입니다. DOM-based XSS는 HTML 문서 객체 모델(DOM)을 조작하여 공격을 수행합니다. XSS 공격을 방지하기 위해서는 입력값 검증과 적절한 에스케이프 처리가 필요합니다. 또한, 쿠키를 HttpOnly 속성으로 설정하고, 보안 취약점 스캐너와 웹 방화벽 등의 보안장치를 이용하여 방어할 수 있습니다.   "},{"title":"10​","type":1,"pageTitle":"정보보안 문제","url":"/blog/second/2023/02/19/정보보안문제#10","content":"디지털 포렌식 설명 답 디지털 포렌식은 컴퓨터 시스템, 디지털 저장 매체, 네트워크 등에서 발생한 범죄나 사건의 증거를 수집, 분석하고 복원하는 과정을 말합니다. 디지털 포렌식 전문가는 범죄나 사건에 대한 증거를 수집하고, 이를 보존하고 분석하여 범인이나 사건의 진실을 파악하는 역할을 수행합니다. 이를 위해 디지털 저장 매체나 기기에서 삭제된 파일, 사용자의 활동 내역, 네트워크 패킷 등 다양한 정보를 추출하고 분석하는 기술을 사용합니다. 디지털 포렌식은 컴퓨터 범죄나 인터넷 범죄, 기업 내부 유출, 지식재산권 침해, 사생활 침해, 악성코드 및 사이버 공격과 같은 다양한 범죄나 사건에 적용됩니다. 이를 통해 범인의 도난한 데이터나 삭제된 정보, 악성코드가 침투한 경로 등을 파악하고, 범죄나 사건의 가해자나 원인을 찾아내는 데 도움을 줍니다.   "},{"title":"11​","type":1,"pageTitle":"정보보안 문제","url":"/blog/second/2023/02/19/정보보안문제#11","content":"생체인식기법의 개념 및 구현 기법들의 특징에 대하여 설명하시오 답 생체인식 기술이란 생체 특징을 측정하고 인식하는 기술로, 패스워드나 카드키와 같은 기존의 인증 방식보다 높은 보안성과 편의성을 제공합니다. 다양한 생체 특징을 이용한 인식 기술이 개발되어 왔으며, 대표적인 구현 기법들은 다음과 같습니다. 1. 지문 인식 - 사용자의 손가락에 있는 지문의 무늬, 선명도, 질감 등의 고유한 특성을 이용해 인증하는 기술 - 고유성이 높아 편리하게 사용할 수 있으나, 신뢰성이 다소 떨어질 수 있음 2. 홍채 인식 - 사용자의 눈동자 내부의 홍채 패턴을 이용해 인증하는 기술 - 높은 신뢰성을 제공하지만, 복잡한 인식과정과 인식 시간이 오래 걸린다는 단점이 있음 3. 얼굴 인식 - 사용자의 얼굴 모양, 크기, 윤곽 등을 이용해 인증하는 기술 - 빠른 인식속도와 사용자의 인식과 관련된 편의성이 높으나, 조명이나 환경 변화 등에 따라 성능이 크게 변동될 수 있음 4. 음성 인식 - 사용자의 음성 톤, 발음, 억양 등을 이용해 인증하는 기술 - 언어나 발음에 따라 인식률이 변할 수 있으며, 특정 환경에서는 인식이 제대로 이루어지지 않을 수 있음 5. 정맥 인식 - 사용자의 손가락이나 팔의 정맥 무늬를 이용해 인증하는 기술 - 생체 인식 기술 중에서 가장 높은 신뢰성을 제공하나, 대상 부위를 직접 센서에 대야 하기 때문에 사용자의 편의성이 다소 떨어질 수 있음 6. 심장 박동 인식 - 사용자의 심장 박동을 측정하여 인증하는 기술 - 매우 높은 신뢰성을 제공하지만, 센서의 정확도와 사용자의 건강상태 등에 따라 인식률이 크게 변동될 - 수 있음 생체 인식 기술은 다양한 특성을 이용하여 구현됩니다.  "}]