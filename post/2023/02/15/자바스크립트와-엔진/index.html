<!doctype html>
<html lang="ko" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-first-blog">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.3.1">
<title data-rh="true">1. 자바스크립트와 엔진의 특성 | One hundred million gold Blog</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://100milliongold.github.io/blog/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://100milliongold.github.io/blog/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://100milliongold.github.io/blog/post/2023/02/15/자바스크립트와-엔진"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="1. 자바스크립트와 엔진의 특성 | One hundred million gold Blog"><meta data-rh="true" name="description" content="자바스크립트의 특성과 자바스크립트로 작성된 코드의 실행을 담당하는 엔진의 특성에 대해 알아보자."><meta data-rh="true" property="og:description" content="자바스크립트의 특성과 자바스크립트로 작성된 코드의 실행을 담당하는 엔진의 특성에 대해 알아보자."><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2023-02-15T00:00:00.000Z"><link data-rh="true" rel="icon" href="/blog/img/h3jbaZKM.ico"><link data-rh="true" rel="canonical" href="https://100milliongold.github.io/blog/post/2023/02/15/자바스크립트와-엔진"><link data-rh="true" rel="alternate" href="https://100milliongold.github.io/blog/post/2023/02/15/자바스크립트와-엔진" hreflang="ko"><link data-rh="true" rel="alternate" href="https://100milliongold.github.io/blog/post/2023/02/15/자바스크립트와-엔진" hreflang="x-default"><script src="https://cdn.jsdelivr.net/npm/docusaurus-plugin-drawio/viewer.min.js"></script>


<link rel="alternate" type="application/rss+xml" href="/blog/post/rss.xml" title="One hundred million gold Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/post/atom.xml" title="One hundred million gold Blog Atom Feed">
<link rel="alternate" type="application/json" href="/blog/post/feed.json" title="One hundred million gold Blog JSON Feed">
<link rel="alternate" type="application/rss+xml" href="/blog/second/rss.xml" title="One hundred million gold Blog RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/second/atom.xml" title="One hundred million gold Blog Atom Feed">
<link rel="alternate" type="application/json" href="/blog/second/feed.json" title="One hundred million gold Blog JSON Feed">
<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1H9D7W76DL"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-1H9D7W76DL",{anonymize_ip:!0})</script>


<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" crossorigin="anonymous"><link rel="stylesheet" href="/blog/assets/css/styles.96b880c5.css">
<link rel="preload" href="/blog/assets/js/runtime~main.c55e048d.js" as="script">
<link rel="preload" href="/blog/assets/js/main.96f9ffb8.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="본문으로 건너뛰기"><a class="skipToContent_fXgn" href="#docusaurus_skipToContent_fallback">본문으로 건너뛰기</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/blog/"><div class="navbar__logo"><img src="/blog/img/logo.png" alt="My Site Logo" class="themedImage_ToTc themedImage--light_HNdA"><img src="/blog/img/logo.png" alt="My Site Logo" class="themedImage_ToTc themedImage--dark_i4oU"></div><b class="navbar__title text--truncate">100milliongold Blog</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/blog/post">Blog</a><a class="navbar__item navbar__link color-white" href="/blog/second">Note</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/100milliongold" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="searchBox_ZlJk"><div class="navbar__search"><span aria-label="expand searchbar" role="button" class="search-icon" tabindex="0"></span><input type="search" id="search_input_react" placeholder="Loading..." aria-label="Search" class="navbar__search-input search-bar" disabled=""></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_re4s thin-scrollbar" aria-label="최근 블로그 문서 둘러보기"><div class="sidebarItemTitle_pO2u margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Yudw clean-list"><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/post/2023/02/21/Bun-으로-React-시작하기">Bun-으로-React-시작하기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/post/2023/02/21/useMemo-정의">useMemo-정의</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/post/2023/03/06/yup %2B react-hook-form 연동">yup + react-hoot-form 으로 연동하기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/post/2023/02/20/Linux-Large-File-Copy-Linux-대량-파일-복사">Linux Large File Copy(Linux 대량 파일 복사) | by jelly | Medium</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/post/2023/02/20/pyscript-란">PyScript 란? - HTML에서 파이썬 코드 작성</a></li><li class="sidebarItem__DBe"><a aria-current="page" class="sidebarItemLink_mo7H sidebarItemLinkActive_I1ZP" href="/blog/post/2023/02/15/자바스크립트와-엔진">1. 자바스크립트와 엔진의 특성</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/post/2023/02/12/이사중/inde">다시 깃헙페이지로 이사갑니다.</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/post/NestJS-오류-TypeError-0-cookieparser1.default-is-not-a-function">NestJS 오류 TypeError 0 , cookie_parser_1.default is not a function</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/post/2022/05/02/Lombok을-이용해-Builder-패턴을-만들어보자">Lombok을 이용해 Builder 패턴을 만들어보자.</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/post/DTO를-이너-클래스로-관리하기">DTO를 이너 클래스로 관리하기</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/post/Lombok을-이용해-Builder-패턴을-만들어보자">Lombok을 이용해 Builder 패턴을 만들어보자.</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/post/2022/04/04/RequiredArgsConstructor">@RequiredArgsConstructor</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/post/2022/04/25/Ingress-와-egress-차이">Ingress 와 egress 차이</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/post/2022/04/25/networkpolicy-생성">networkpolicy 생성</a></li><li class="sidebarItem__DBe"><a class="sidebarItemLink_mo7H" href="/blog/post/Udemy-사이트-강좌-자막-번역-방법">Udemy 사이트 강좌 자막 번역 방법</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_f1Hy" itemprop="headline">1. 자바스크립트와 엔진의 특성</h1><div class="container_mt6G margin-vert--md"><time datetime="2023-02-15T00:00:00.000Z" itemprop="datePublished">2023년 2월 15일</time> · <!-- -->약 27분</div></header><div id="post-content" class="markdown" itemprop="articleBody"><p>자바스크립트의 특성과 자바스크립트로 작성된 코드의 실행을 담당하는 엔진의 특성에 대해 알아보자.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="11-자바스크립트의-특성">1.1. 자바스크립트의 특성<a href="#11-자바스크립트의-특성" class="hash-link" aria-label="1.1. 자바스크립트의 특성에 대한 직접 링크" title="1.1. 자바스크립트의 특성에 대한 직접 링크">​</a></h2><p>javascript는 웹을 구성하는 3대장 중 하나다. HTML 그리고 CSS와 함께 웹 페이지를 구성하는데 사용된다. HTML이 웹페이지의 UI 구성을 만드는데 사용되고 CSS가 스타일링을 입힌 다면, 그 둘을 유저와의 상호작용을 구현하는데 javascript를 사용한다.
초보자들이 배우기 쉽고 매우 자유로운 언어라고 한다.
자유롭다는 말은 문법이 간단하고 멀티-패러다임 언어로 명령형, 함수형, 객체지향형 언어등 다양하게 활용이 가능해서 그런것 같다.
또한 객체 기반의 언어지만 하지만 상속과 클래스라는 개념은 없다.
(이 부분은 추가 리서치 필요)</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="12-크롬-v8엔진">1.2. 크롬 V8엔진<a href="#12-크롬-v8엔진" class="hash-link" aria-label="1.2. 크롬 V8엔진에 대한 직접 링크" title="1.2. 크롬 V8엔진에 대한 직접 링크">​</a></h2><p>자바스크립트는 실행되는 환경에 따라 사용되는 엔진이 상이하기도 하다.
일반적으로 chrome에 내장된 chrome V8 엔진이 대표적이다.
V8엔진에 의해 실행되는 javascript는 compile(번역)과 interpreter(통역) 두개의 일련의 과정을 거쳐야한다.
여담으로 V8엔진에는 원래 interpreter가 없었지만 2017년 5.9버전이 나오면서 추가 되었다.</p><p>어쨋든 compile도 하고 interpret도 거쳐야 하는 자바스크립트는 컴파일언어라고 하기도,
인터프리터 언어라고 하기도 애매하다.</p><p>아무튼 compile과 interpreter 두 개의 과정을 거치는 것이 특징인 자바스크립트는 이 과정들을 머신코드로 해석되고 통역되어 브라우저에서 인식할 수 있게 된다.
또 다른 특징은 JIT(just-in-time)이라고 불리는 방식으로 위의 과정을 거치는데
말 그대로 브라우저가(대표적인 javascript가 실행되는 환경) javascript를 읽어 들이는 순간부터 compiler과 interpreter가 실행된다는 것이다.</p><p>그래도 가장 대표적인 특징은 V8엔진은 자바스크립트 코드를 단일 스레드, call stack에서 동기적으로 실행 한다.
이는 아마 V8엔진이 JIT 방식으로 compile과 interprete를 거쳐 머신 코드로 변환시키기 때문에 안정화 때문이지 않을까 하는 추측을 해본다.</p><h1>2. 자바스크립트 엔진의 실행 방식</h1><p>자바스크립트 엔진, 대표적으로 V8은 자바스크립트 코드를 <strong>동기적</strong>으로 실행 한다고 했다.
그럼 동기적으로 실행한다는 것이 무슨 뜻일까? 엔진 내부를 살짝 들여다보면서 살펴보자.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="21-동기적인-실행-방식">2.1. 동기적인 실행 방식<a href="#21-동기적인-실행-방식" class="hash-link" aria-label="2.1. 동기적인 실행 방식에 대한 직접 링크" title="2.1. 동기적인 실행 방식에 대한 직접 링크">​</a></h2><p>동기적으로 어떤 작업들을 한다는 말은 작업들을 한 작업 한 작업씩 처리한다는 뜻이다.
조금 더 자세히 살펴보자.
V8엔진은 싱글 스레드인 하나의 <strong>call stack</strong>을 가지고 있다.
작업을 처리하는 공간인 call stack은 하나 밖에 없기 때문에 실행이 필요한 javascript 코드들은 이 하나의 call stack에 차곡 차곡 쌓인다.
만약 5개의 코드가 실행이 필요해 call stack에 차곡 차곡 쌓였다.
(실행 순서는 나중에 조금 더 자세히 살펴볼 것이다. 지금은 단지 동기적 처리 방식에 대해서만 설명)
이 5개의 작업들을 동기적으로 처리하면 다음과 같은 순서로 진행될 것이다.</p><ol><li>첫 번째 순서의 코드가 실행이 된다.</li><li>이 때 다음 순서인 두 번째 순서의 코드는 실행이 되지 않는다. 그 대신 첫 번째 순서의 코드의 실행이 완료될 때 까지 대기하게 된다.</li><li>일정 시간이 흐른 후 첫 번째 순서의 코드 실행이 완료되었다. 이제 두 번째 순서의 코드 실행이 시작된다.</li><li>똑같이 세 번째 순서의 코드는 실행이 되지 않고 자신 앞 순서의 코드 실행이 완료 될 때까지 대기한다.</li><li>쭉 반복</li></ol><p>이렇게 작동하는 것이 동기적인 작동 방식인데 실행의 <strong>요청</strong>에 의해 작업이 시작되고 <strong>응답</strong>이 오면 작업을 완료하고 종료시킨다. 그 후 다음 작업에 대해 실행을 시작한다.
자바스크립트 엔진의 call stack은 이 방식으로 javascript 코드를 실행한다.
하지만 그 순서가 조금은 특이한데 바로 first-in, last-out, 즉 선입후출 방식으로 진행된다.</p><p>말로 먼저 설명하자면 함수 호출의 코드를 엔진이 읽어 들이면 call stack에 쌓는다.
근데 방금 호출된 함수 안에는 또 다른 함수의 호출이 있다.
그럼 안에서 호출된 함수에 대응하여 그 함수의 실행을 call stack에 쌓는데 이때는 처음 쌓인 call stack 위에 쌓인다.
안에서 호출된 함수 내부에는 또 다른 함수 호출이 없다. 그래서 엔진은 call stack에 쌓인
함수들을 실행하려 하는데 이 때 늦게 들어온 순서대로 코드실행을 진행한다.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="22-예제">2.2. 예제<a href="#22-예제" class="hash-link" aria-label="2.2. 예제에 대한 직접 링크" title="2.2. 예제에 대한 직접 링크">​</a></h2><p>말로하니 역시나 어렵다. 다음 예제로 살펴보자.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">const funcOne =() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  2️⃣console.log(&quot;No.1&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  3️⃣funcTwo()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const funcTwo =() =&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  4️⃣console.log(&quot;No.2&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  5️⃣funcThree()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">const funcThree =()=&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  6️⃣console.log(&quot;No.3&quot;)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">1️⃣funcOne()</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 결과값</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&#x27;No.1&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&#x27;No.2&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">&#x27;No.3&#x27;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>위 코드는 중첩된 함수에 대한 예제이다. 실제로 호출이 되면 call stack에 쌓이는 모습을 살펴보자.</p><p>위의 움짤처럼 쌓이고 위의 쌓인 순서대로 실행되고 실행이 완료되면 사라진다.
함수가 호출되어 call stack에 쌓이면 내부 코드를 순서대로 call stack에 쌓는걸 볼 수 있다.
그 후 함수 내부에 다른 함수의 호출이 존재하면 그 함수를 call stack에 쌓는데
그 함수가 실행이 완료되어 call stack에서 사라지기전에 외부함수의 실행도 완료되지 않는점을 명심하자.</p><h1>3. 비동기 함수와 자바스크립트 엔진</h1><p>javascrit 엔진 V8이 자바스크립트 코드를 실행하는 과정을 보면 정말 똑똑하다.
(실제로 공식 문서를 보면 매번 업데이트에 성능 향상과 최적화에 엄청 공을 들인다.)
성능적으로도 똑똑하지만 (컴퓨터도, 인터넷도 성능이 뛰어난 요즘시대이기에 처음 자바스크립트를 실행시켰을 때
나는 동기적으로 한번에 실행된다고 느꼈다. 하지만 정말 미묘하게 아~주 미묘하게 순서대로 실행되는 것이였다.) 브라우저애서 실행 된다는 점에서 JIT방식으로 실행을 하기 때문에 코드을 읽어 들어와 연산하여 인식하는 과정은 조금 불안정할 수 도 있다.
그렇기 때문에 동기적인 방식으로 실행하는 것 같다는 느낌이 든다.
순차대로 적은 코드들에 대해 순서를 보장해 주는 것이다.
그래서 자바스크립트 엔진을 어느 정도 (아주 조금이지만) 파해쳐보니
조금 더 효율적이고 나은 코드 작성을 준수해야 되겠다는 생각이 크게 든다.
(hoisting, execution context, lexical closure 등과 함께 날잡고 정리해야겠다.)</p><p>하지만 자바스크립트 엔진이 아무리 최적화하여 똑똑하게 실행을 처리한다고 한들 순서가 보장되지 못하는 경우가 발생하기도 한다. 바로 비동기 함수다.
간단하게 비동기 함수는 자바스크립트의 원칙, 실행 순서를 보장 받는다,를 깨고 비동기로 처리된다. 즉 순서를 보장받지 못하고 뒤로 밀리게 된다.
그럼 비동기 함수는 무엇이며 자바스크립트 엔진은 왜 이런식으로 처리하는 것일까?</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="31-비동기-함수">3.1. 비동기 함수<a href="#31-비동기-함수" class="hash-link" aria-label="3.1. 비동기 함수에 대한 직접 링크" title="3.1. 비동기 함수에 대한 직접 링크">​</a></h2><p>대표적인 비동기 함수는 <strong>DOM 이벤트</strong> <strong>API요청</strong> <strong>setTimeout</strong>같은 내장 함수들이 있다.
setTimeout으로 대표되는 DOM API, fetch 등으로 대표되는 XMLHttpRequest 등의 AJAX 등이 바로 비동기로 처리되는 대표적인 함수들이다.
그런데 이들의 위치가 조금 생소하다. 이 형태를 javascript runtime의 모습으로 살펴보자.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="32-javascript-runtime">3.2. Javascript Runtime<a href="#32-javascript-runtime" class="hash-link" aria-label="3.2. Javascript Runtime에 대한 직접 링크" title="3.2. Javascript Runtime에 대한 직접 링크">​</a></h2><p>자바스크립트 엔진에는 memory heap이라는 공간도 존재한다.
설명상으로는 변수와 객체에 대한 모든 메모리 할당이 이루어 지는 곳이라고 하는데
조금 더 리서치가 필요한 부분이다.
하지만 이번 자바스크립트의 코드 실행 방식에는 큰 영향을 주는 것 같지 않다. (그래서 넘어가겠다는 소리)</p><p>어찌돼었던 이런 자바스크립트의 실행환경을 보면 엔진 밖에 <strong>Web API</strong>들이 모여있는 곳이 있다.
자바스크립트 엔진이 제공하는 것이 아닌 브라우저에서 제공해주는 것이다.
다시 말해 이들은 다른 누군가에 의해 정의되고 브라우저에 내장된 내장함수라고 생각해도 무관한데 이들은 <strong>비동기 함수</strong>이고 브라우저에 위치하고 있다.</p><p>다른말로는 자바스크립트 엔진이 콜스텍에 쌓고 실행을 처리하는 함수는<strong>우리가 자바스크립트라는 언어로 작성한 커스텀 함수다.</strong></p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="33-자바스크립트-엔진의-코드-처리-방식">3.3. 자바스크립트 엔진의 코드 처리 방식<a href="#33-자바스크립트-엔진의-코드-처리-방식" class="hash-link" aria-label="3.3. 자바스크립트 엔진의 코드 처리 방식에 대한 직접 링크" title="3.3. 자바스크립트 엔진의 코드 처리 방식에 대한 직접 링크">​</a></h2><p>자바스크립트 엔진은 자바스크립트로 작성된 코드들의 실행을 담당한다.
물론 실행을 하기 위해 머신코드로 변환하는 작업을 거치긴 하지만 지금은 논외로 해보자.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="331-일반적인-코드-처리">3.3.1. 일반적인 코드 처리<a href="#331-일반적인-코드-처리" class="hash-link" aria-label="3.3.1. 일반적인 코드 처리에 대한 직접 링크" title="3.3.1. 일반적인 코드 처리에 대한 직접 링크">​</a></h3><p>자바스크립트로 작성된 코드는 순차적으로 call stack에 쌓이게 된다.
call stack에 쌓이는 순간은 바로 코드가 해당 코드를 실행시키도록 작성되어있을 때 이다.
즉 자바스크립트 엔진은 call stack에 코드를 실행하라고 <strong>요청</strong>을 보내고 그 요청이 call stack에 쌓이는 것이다.
그러면 call stack에서는 해당 코드에 대한 작업을 하고 완료되면 <strong>응답</strong>을 보내 call stack에서 빼버린다.
명심해야 할 것은 코드 작업의 실행과정은 <strong>요청</strong>과 <strong>응답</strong> 이라는 것이다.
하나의 코드 실행은 <strong>요청</strong>에 의해 작업이 시작되고 완료되어 <strong>응답</strong>이 오면 비로소 <strong>완료</strong>되어 사라지는 것이다.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="332-비동기-함수-처리">3.3.2. 비동기 함수 처리<a href="#332-비동기-함수-처리" class="hash-link" aria-label="3.3.2. 비동기 함수 처리에 대한 직접 링크" title="3.3.2. 비동기 함수 처리에 대한 직접 링크">​</a></h3><p>만약 우리가 Web API 작업을 포함하는 함수를 자바스크립트로 작성하고 실행시킨다고 가정해보면
call stack에 쌓고 실행 요청을 보낸다.
함수 내부를 살펴보니 Web API를 실행해야하는데 자바스크립트 엔진내에 존재하는 함수가 아니다.
그러면 자바스크립트는 이 실행을 본인 내부에서 하지 않고 Web API가 있는곳에 그에 관련한 요청을 보낸다.
요청에 대한 <strong>응답</strong>으로 필요한 다른 <strong>응답</strong>에 대해 다른곳에 <strong>요청</strong>을 보내는 것이다.
그 요청을 비동기 함수의 callback함수와 같이 보낸다.
브라우저는 <strong>요청</strong>에 대한 <strong>응답</strong>으로 callback함수를 보내오는데 그 응답을 call stack에서 처리한다. 그러면 예제의 실행은 <strong>완료</strong>되는데 자바스크립트는 비동기 함수를 조금 특이하게 처리한다.</p><p>앞서 call stack에 요청된 Web API의 실행은 call stack에서 하지 않고 Web API에 위임한다고 했다.
이때 call stack에서는 해당 요청을 사라진다. 즉 해당 요청에 대한 응답을 본인이 처리하지 않기에 브라우저에 요청을 보내고 해당 작업에 대한 모든 정보를, 즉 callback을 call stack에서는 Web API쪽으로 함께 보내버리는 것이다.(위임)
그렇기 때문에 같이 보내진 콜백 함수는 순서를 보장 받기도 전에 다른 곳에 위임이 되어버린다.</p><p>하지만 브라우저는 Web API 실행 요청에 대한 응답으로 callback 함수를 보내고 그 함수를 다시 call stack에서 처리한다고 하지 않았는가?
브라우저의 응답으로 온 callback 함수를 실행하라고 call stack에 요청하고 쌓는다.
이때는 제대로 실행 순서를 보장받는다.</p><p>쉽게 말해 어린아이가 귤을 먹고 싶은데 (call stack에 요청) 껍질을 본인이 깔 수 없어 엄마한테 껍질을 까달라고 요청하고 (Web API 요청 with callback)
그 요청의 응답으로 알맹이가 돌아오고 (콜백) 그 알맹이를 먹을 수 있게 (call stack에서 실행) 되는 것이다.</p><p>그렇기 때문에 call stack은 본인이 수행할 수 있는 요청이 아니기에 브라우저에 껍대기를 까달라고 요청과 함께 비동기 함수안에 정의된 callback 함수도 함께 보낸다.
(API 함수에 대한 실행요청으로 실행하려 했지만 실행을 하지도 않고 다른곳으로 위임한다.
그리고 내부에 정의된 콜백함수는 순서를 배정받기도 전에 같이 보내지는 것이다.)
그 후 브라우저에서 껍대기를 까고 알맹이를 돌려주면 (callback 함수) 다시 call stack에서 실행을 요청하고 연산 후 응답으로 보내주면 실행을 완료하고 call stack에서 사라진다.</p><h3 class="anchor anchorWithStickyNavbar_LWe7" id="333-callback-queue와-event-loop">3.3.3. callback queue와 event loop<a href="#333-callback-queue와-event-loop" class="hash-link" aria-label="3.3.3. callback queue와 event loop에 대한 직접 링크" title="3.3.3. callback queue와 event loop에 대한 직접 링크">​</a></h3><p>하지만 그 callback 함수가 call stack으로 들어가기전에 규칙이 있다.
Web API가 요청으로 응답을 보내주기까지 call stack은 기다리지 않고 다른 일을 순차적으로 동기적으로 처리한다.
아직 100개의 일이 call stack에서 처리되어야 한다고 가정해보자.
callback함수는 그 중간에 끼어들어 순서를 바꿔버릴까?
그렇게 되면 코드 실행은 엉창진창이 되버릴 것이다.
그래서 대신 callback queue라는 곳에서 기다린다. 일종의 유명한 식당에서 줄을 서며 기다리는 것이다. 이 callback queue에서 기다리가닥 들어온 순서대로 call stack으로 옮겨지는데
event loop라는 친구가 항상 call stack과 callback queue를 지켜보고 있다가 call stack이 비워지게 되면 callback queue에서 대기중인 함수 실행을 call stack을 보내 callback 함수를 실행하게 된다.
결국 call stack과 callback queue는 동기적으로 작동하는데 비동기 함수는 그 순서가 밀리는 것이다.</p><p>말로하니 역시 어렵다. 예제 코드를 작성하고 어떤 이동이 일어나는지 살펴보자.</p><div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">let someVal = 1</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let API_EXAMPLE = ()=&gt; {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    setTimeout(function() {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        someVal + 10</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    },3000)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    return someVal</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">let someFinalVal = API_EXAMPLE() + 100</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">console.log(someFinalVal)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="클립보드에 코드 복사" title="복사" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>콘솔창에 어떤 결과값이 찍힐까? 111? 아니면 101? 진행과정을 보고 한번 살펴보자.</p><p><img loading="lazy" alt="image" src="/blog/assets/images/test-18ae8c4b0e5a404bca076669945c4b02.gif" width="480" height="360" class="img_ev3q"></p><p><code>setTimeout</code>이라는 Web API는 비동기 방식으로 처리되었기 때문에<code>someVal</code>1에 10을 더하지 못한채 <code>API_EXAMPLE</code>함수 실행은 완료되었다.
그래서 결국 콘솔에 찍힐 <code>someFinalVal</code>의 값은 1+100인 101이 되는 것이다.</p><p>이렇게 자바스크립트 엔진은 비동기 함수를 실행시킬 때 그 안에 작성된 콜백 함수를 Web API를 처리하는 곳으로 보내고 비동기 함수가 실행되는 동안 call stack에 보장된 순서대로 다음 함수들을 처리한다.
그 사이 비동기 함수가 연산을 마치면 같이 보내진 콜백 함수를 callback queue로 보내고
event loop가 지켜보고 있다가 call stack이 비워지면 콜백 함수를 call stack에 다시 밀어넣고 보장된 순서대로 실행 시키는 것이 바로 자바스크립트가 비동기 함수를 처리하는 방법이다.</p><p>비동기 함수가 어떻게 처리되는지 알아봤는데 왜 자바스크립트 엔진은 헷갈리게 브라우저 내장 함수들을 이렇게 처리하는지 이유에 대해서 알아보자.</p><h2 class="anchor anchorWithStickyNavbar_LWe7" id="34-비동기-처리-방식의-이유">3.4. 비동기 처리 방식의 이유<a href="#34-비동기-처리-방식의-이유" class="hash-link" aria-label="3.4. 비동기 처리 방식의 이유에 대한 직접 링크" title="3.4. 비동기 처리 방식의 이유에 대한 직접 링크">​</a></h2><p>이유는 간단하게 blocking script를 방지하기 위해서다.
위의 예제에서 setTimeout라는 Web API를 사용했는데
이 함수는 지정된 시간이 지난 후 실행 되는 대표적인 비동기 함수다.
예제에 이 함수를 사용한 이유는 <code>fetch</code>나 <code>axios</code> 등으로 대표되는
서버와의 통신으로 데이터를 받아오는데 사용되는 Web API를 구현하기 위해서다.
만약 통신으로 데이터를 받아오는데 위 예제처럼 3초가 아니라 10분이 걸린다고 가정해보자.
그리고 이런 함수를 비동기가 아닌 동기로 처리한다고 가정해보자.</p><p>그러면 10분동안 아무것도 화면에 나오지 않을 것이다.
만약 통신으로 뉴스의 사진을 받아온다고 가정한다면 통신 다음에 실행되어야 할 코드들이
실행을 계속 기다리게 된다.
이것이 바로 <strong>blocking script</strong>다.
자바스크립트는 동기로 코드를 실행시키는데 한 코드에 소요 되는 시간이 너무 길기 때문에
그 코드 이후에 실행으로 순서를 부여받은 코드들은 10분을 더 기다려야 실행이 된다.</p><p>하지만 만약 비동기로 처리한다면 어떨까?
화면에는 사진만 나오지 않고 글은 보일 것이다.
그리고 유저는 10분뒤 사진을 받아볼 수 있을 것이다.</p><p>AJAX 요청이, 대표적으로, 비동기로 처리되는 이유는 웹 페이지에 필요한 리소스들을 대부분 서버로부터 전송받아 viw에 보여주기 때문이다.
그런데 이런 리소스들 때문에 스크립트가 막힌다면 페이지 자체를 보여줄 수 없기 때문이다.</p><h1>4. 이슈: 결론은 Promise다.</h1><p>이로 인해 발생하는 이슈는 무엇일까?
바로 위 예제와 같다.
만약 서버와의 통신으로 데이터를 받아와서 그 값을 재연산해서 최종값으로 사용하려 한다면
위의 예제처럼 &quot;+10&quot;이라는 재연산을 하지 못한채 값을 사용하게 된다.
그러면 어떻게 해야할까?
바로 Promise를 사용하는 것이다.
Promise는 비동기 함수를 동기적으로 처리할 수 있게 해주는 아주 대단한 친구다.
Promise에 대한 정리는 다음에 하도록 하겠다.</p><h1>5. 추가: Job Queue</h1><p>인터넷에서 재밌는 글을 읽었는데 바로 Job Queue에 관한 것이다.
먼저 다시 비동기 함수 작동방식을 살펴보면,
비동기 함수는 본인의 함수를 실행하고 콜백으로 넘겨진 콜백함수를 callback queue로 보낸다.
그리고 event loop가 call stack을 지켜보고 있다가 다 비워지면 callback queue에서
first-in, first-out 방식으로 call stack에 밀어 넣는다.
즉 다른 일반 함수의 실행이 모두 끝나야 비동기 함수가 실행 순서를 배부받고 보장받는 것인데
비동기 함수는 call stack 맨 끝부분에 추가된다고 봐도 무방하다.
그런데 이 job queue라는 재밌는 녀석은 비동기 함수한테 조금 더 빠른 순서를 제공한다.
물론 조건이 필요한데 그 조건은 비동기 함수가 실행되는 현재 함수가 끝나기전에 비동기 함수의 실행이 완료되면 현재 함수의 실행이 완료된 후 바로 실행되는 순서를 제공받는다.
다시 말해 다른 일반 함수들의 실행이 끝나 call stack이 비워지기 전에 순서를 제공받는 것이다.</p></div><div style="margin-top:30px"></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="블로그 게시물 탐색"><a class="pagination-nav__link pagination-nav__link--prev" href="/blog/post/2023/02/20/pyscript-란"><div class="pagination-nav__sublabel">이전 게시물</div><div class="pagination-nav__label">PyScript 란? - HTML에서 파이썬 코드 작성</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/blog/post/2023/02/12/이사중/inde"><div class="pagination-nav__sublabel">다음 게시물</div><div class="pagination-nav__label">다시 깃헙페이지로 이사갑니다.</div></a></nav></main><div class="col col--2"><div class="tableOfContents_bqdL thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#11-자바스크립트의-특성" class="table-of-contents__link toc-highlight">1.1. 자바스크립트의 특성</a></li><li><a href="#12-크롬-v8엔진" class="table-of-contents__link toc-highlight">1.2. 크롬 V8엔진</a></li><li><a href="#21-동기적인-실행-방식" class="table-of-contents__link toc-highlight">2.1. 동기적인 실행 방식</a></li><li><a href="#22-예제" class="table-of-contents__link toc-highlight">2.2. 예제</a></li><li><a href="#31-비동기-함수" class="table-of-contents__link toc-highlight">3.1. 비동기 함수</a></li><li><a href="#32-javascript-runtime" class="table-of-contents__link toc-highlight">3.2. Javascript Runtime</a></li><li><a href="#33-자바스크립트-엔진의-코드-처리-방식" class="table-of-contents__link toc-highlight">3.3. 자바스크립트 엔진의 코드 처리 방식</a><ul><li><a href="#331-일반적인-코드-처리" class="table-of-contents__link toc-highlight">3.3.1. 일반적인 코드 처리</a></li><li><a href="#332-비동기-함수-처리" class="table-of-contents__link toc-highlight">3.3.2. 비동기 함수 처리</a></li><li><a href="#333-callback-queue와-event-loop" class="table-of-contents__link toc-highlight">3.3.3. callback queue와 event loop</a></li></ul></li><li><a href="#34-비동기-처리-방식의-이유" class="table-of-contents__link toc-highlight">3.4. 비동기 처리 방식의 이유</a></li></ul></div></div></div></div></div><footer class="footer"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 100milliongold. Built with Docusaurus.</div></div></div></footer></div>
<script src="/blog/assets/js/runtime~main.c55e048d.js"></script>
<script src="/blog/assets/js/main.96f9ffb8.js"></script>
</body>
</html>